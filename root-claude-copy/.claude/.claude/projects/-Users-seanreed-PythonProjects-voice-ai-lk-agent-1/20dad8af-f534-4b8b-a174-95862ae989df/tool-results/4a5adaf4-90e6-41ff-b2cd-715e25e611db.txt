diff --git a/.claude/settings.local.json b/.claude/settings.local.json
index 4003557..3528e59 100644
--- a/.claude/settings.local.json
+++ b/.claude/settings.local.json
@@ -26,7 +26,8 @@
       "WebFetch(domain:broadinstitute.github.io)",
       "Skill(commit-push-pr)",
       "Bash(git add:*)",
-      "Bash(git commit:*)"
+      "Bash(git commit:*)",
+      "Skill(makefile)"
     ]
   }
 }
diff --git a/.gitignore b/.gitignore
index c0f4286..2ee31d3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -23,3 +23,5 @@ KMS
 
 
 temp/
+
+.cursor/
\ No newline at end of file
diff --git a/Makefile b/Makefile
index db9b845..b053670 100644
--- a/Makefile
+++ b/Makefile
@@ -1,53 +1,130 @@
-.PHONY: help test format lint check console dev start download-files clean
+# =============================================================================
+# McDonald's Drive-Thru Agent - Makefile
+# =============================================================================
+# Quick Reference:
+#   make console       - Run drive-thru agent in console mode (testing)
+#   make dev           - Run drive-thru agent with LiveKit (voice testing)
+#   make test          - Run all tests
+#   make setup         - Install dependencies and download models
+# =============================================================================
 
-# Default target
+.PHONY: help console dev start setup test format lint clean
+.DEFAULT_GOAL := help
+
+# -----------------------------------------------------------------------------
+# Colors
+# -----------------------------------------------------------------------------
+BLUE   := \033[0;34m
+GREEN  := \033[0;32m
+YELLOW := \033[0;33m
+CYAN   := \033[0;36m
+BOLD   := \033[1m
+NC     := \033[0m
+
+# -----------------------------------------------------------------------------
+# Default Variables
+# -----------------------------------------------------------------------------
+ARGS   ?=
+SCOPE  ?= all
+
+# =============================================================================
+# HELP
+# =============================================================================
 help:
-	@echo "Available targets:"
-	@echo "  make test           - Run all tests with pytest"
-	@echo "  make format         - Format code with ruff"
-	@echo "  make lint           - Lint code with ruff"
-	@echo "  make check          - Run linting and tests"
+	@echo "$(CYAN)$(BOLD)McDonald's Drive-Thru Agent$(NC)"
+	@echo ""
+	@echo "$(BOLD)Most Common Commands:$(NC)"
+	@echo "  $(GREEN)make console$(NC)              Test agent in terminal (no voice)"
+	@echo "  $(GREEN)make dev$(NC)                  Run agent with LiveKit (voice enabled)"
+	@echo "  $(GREEN)make test$(NC)                 Run all tests"
 	@echo ""
-	@echo "Run targets:"
-	@echo "  make console        - Run agent in console mode"
-	@echo "  make dev            - Run agent in dev mode"
-	@echo "  make start          - Run agent in production mode"
+	@echo "$(BOLD)Setup:$(NC)"
+	@echo "  $(GREEN)make setup$(NC)                Install dependencies and download models"
 	@echo ""
-	@echo "Utilities:"
-	@echo "  make download-files - Download required model files (VAD, turn detector)"
-	@echo "  make clean          - Remove generated files and cache"
+	@echo "$(BOLD)Development:$(NC)"
+	@echo "  $(GREEN)make format$(NC)               Format code with ruff"
+	@echo "  $(GREEN)make lint$(NC)                 Lint code with ruff"
+	@echo "  $(GREEN)make test SCOPE=unit$(NC)      Run unit tests only"
+	@echo "  $(GREEN)make test SCOPE=integration$(NC) Run integration tests only"
+	@echo "  $(GREEN)make test ARGS=\"-k order\"$(NC) Run tests matching 'order'"
+	@echo ""
+	@echo "$(BOLD)Production:$(NC)"
+	@echo "  $(GREEN)make start$(NC)                Run agent in production mode"
+	@echo ""
+	@echo "$(BOLD)Utilities:$(NC)"
+	@echo "  $(GREEN)make clean$(NC)                Remove caches and generated files"
 
-# Testing
-test:
-	uv run python -m pytest tests/ -v
+# =============================================================================
+# RUN - Drive-Thru Agent Execution
+# =============================================================================
 
-# Code formatting and linting
-format:
-	uv run ruff format
+console:  ## Run drive-thru agent in console mode (text-only, for testing)
+	@echo "$(BLUE)Starting drive-thru agent in console mode...$(NC)"
+	uv run python src/agent.py console
+	@echo "$(GREEN)Agent session complete$(NC)"
 
-lint:
-	uv run ruff check --fix
+dev:  ## Run drive-thru agent in dev mode (LiveKit connection, voice enabled)
+	@echo "$(BLUE)Starting drive-thru agent in dev mode...$(NC)"
+	uv run python src/agent.py dev
+
+start:  ## Run drive-thru agent in production mode
+	@echo "$(BLUE)Starting drive-thru agent in production mode...$(NC)"
+	uv run python src/agent.py start
+
+# =============================================================================
+# SETUP - Dependencies and Models
+# =============================================================================
+
+setup:  ## Install dependencies and download required models
+	@echo "$(BLUE)Installing dependencies...$(NC)"
+	uv sync
+	@echo "$(GREEN)Dependencies installed$(NC)"
+	@echo "$(BLUE)Downloading model files (VAD, turn detector)...$(NC)"
+	uv run python src/agent.py download-files
+	@echo "$(GREEN)Setup complete!$(NC)"
 
-check: format lint test
+# =============================================================================
+# TEST - Run Tests
+# =============================================================================
 
-# Run targets (requires API keys configured for the chosen models)
-console:
-	uv run python src/app.py console
+test:  ## Run tests (use SCOPE=unit|integration|all, ARGS for pytest flags)
+	@echo "$(BLUE)Running tests (SCOPE=$(SCOPE))...$(NC)"
+	@case "$(SCOPE)" in \
+		unit) \
+			uv run pytest tests/ -m "not integration" -v $(ARGS) ;; \
+		integration) \
+			uv run pytest tests/ -m integration -v $(ARGS) ;; \
+		all) \
+			uv run pytest tests/ -v $(ARGS) ;; \
+		*) \
+			echo "$(YELLOW)Unknown SCOPE: $(SCOPE)$(NC)"; \
+			echo "Usage: make test SCOPE=[unit|integration|all] [ARGS=\"pytest-flags\"]"; \
+			exit 1 ;; \
+	esac
+	@echo "$(GREEN)Tests complete$(NC)"
 
-dev:
-	uv run python src/app.py dev
+# =============================================================================
+# CODE QUALITY - Formatting and Linting
+# =============================================================================
 
+format:  ## Format code with ruff
+	@echo "$(BLUE)Formatting code...$(NC)"
+	uv run ruff format
+	@echo "$(GREEN)Code formatted$(NC)"
+
+lint:  ## Lint and fix code with ruff
+	@echo "$(BLUE)Linting code...$(NC)"
+	uv run ruff check --fix
+	@echo "$(GREEN)Linting complete$(NC)"
 
-# Download required model files
-download-files:
-	uv run python src/app.py download-files
+# =============================================================================
+# UTILITIES
+# =============================================================================
 
-# Clean generated files
-clean:
+clean:  ## Remove caches and generated files
+	@echo "$(BLUE)Cleaning caches and generated files...$(NC)"
 	rm -rf .pytest_cache
-	rm -rf __pycache__
-	rm -rf src/__pycache__
-	rm -rf src/**/__pycache__
-	rm -rf tests/__pycache__
 	rm -rf .ruff_cache
-	@echo "Cleaned generated files and caches"
+	find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
+	find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
+	@echo "$(GREEN)Clean complete$(NC)"
diff --git a/README.md b/README.md
index 1fdce56..0169cb8 100644
--- a/README.md
+++ b/README.md
@@ -2,233 +2,420 @@
   <img src="./.github/assets/livekit-mark.png" alt="LiveKit logo" width="100" height="100">
 </a>
 
-# LiveKit Agents Starter - Python
+# McDonald's Drive-Thru Voice AI Agent
+
+A voice AI agent system built with [LiveKit Agents for Python](https://github.com/livekit/agents) and [LiveKit Cloud](https://cloud.livekit.io/). This repository contains **two main applications**:
+
+1. **McDonald's Drive-Thru Agent** (`src/agent.py`) - A specialized AI agent that takes drive-thru orders using McDonald's menu data
+2. **Generic Voice Assistant** (`src/app.py`) - A general-purpose voice AI assistant
+
+## Table of Contents
+
+- [Overview](#overview)
+- [Quick Start](#quick-start)
+  - [Prerequisites](#prerequisites)
+  - [Installation](#installation)
+  - [Environment Setup](#environment-setup)
+  - [Download Model Files](#download-model-files)
+- [McDonald's Drive-Thru Agent](#mcdonalds-drive-thru-agent)
+  - [What It Does](#what-it-does)
+  - [How It Works](#how-it-works)
+  - [Running the Drive-Thru Agent](#running-the-drive-thru-agent)
+  - [Menu Data](#menu-data)
+  - [Order Output](#order-output)
+- [Generic Voice Assistant](#generic-voice-assistant)
+  - [What It Does](#what-it-does-1)
+  - [Running the Voice Assistant](#running-the-voice-assistant)
+- [Development](#development)
+  - [Project Structure](#project-structure)
+  - [Testing](#testing)
+  - [Code Formatting](#code-formatting)
+  - [Using the Makefile](#using-the-makefile)
+- [Architecture](#architecture)
+  - [Dependency Injection](#dependency-injection)
+  - [Pydantic Models](#pydantic-models)
+- [Frontend & Deployment](#frontend--deployment)
+  - [Frontend Options](#frontend-options)
+  - [Production Deployment](#production-deployment)
+- [Coding Agents and MCP](#coding-agents-and-mcp)
+- [License](#license)
+
+## Overview
+
+This repository demonstrates how to build specialized voice AI agents using LiveKit. The codebase is organized around **two distinct entry points**:
+
+- **`src/agent.py`** - McDonald's Drive-Thru Agent (specialized ordering system)
+- **`src/app.py`** - Generic Voice Assistant (general-purpose AI)
+
+Both applications share common infrastructure (STT, TTS, LLM) but serve different purposes.
+
+## Quick Start
+
+### Prerequisites
+
+- Python 3.11 or later
+- [uv](https://docs.astral.sh/uv/) package manager
+- [LiveKit Cloud](https://cloud.livekit.io/) account (free tier available)
+- API keys for:
+  - OpenAI (for LLM)
+  - AssemblyAI (for STT)
+  - Cartesia (for TTS)
+
+### Installation
 
-A complete starter project for building voice AI apps with [LiveKit Agents for Python](https://github.com/livekit/agents) and [LiveKit Cloud](https://cloud.livekit.io/).
+Clone the repository and install dependencies:
 
-The starter project includes:
+```bash
+git clone <repository-url>
+cd lk-agent-1
+uv sync
+```
 
-- A simple voice AI assistant, ready for extension and customization
-- A voice AI pipeline with [models](https://docs.livekit.io/agents/models) from OpenAI, Cartesia, and AssemblyAI served through LiveKit Cloud
-  - Easily integrate your preferred [LLM](https://docs.livekit.io/agents/models/llm/), [STT](https://docs.livekit.io/agents/models/stt/), and [TTS](https://docs.livekit.io/agents/models/tts/) instead, or swap to a realtime model like the [OpenAI Realtime API](https://docs.livekit.io/agents/models/realtime/openai)
-- Eval suite based on the LiveKit Agents [testing & evaluation framework](https://docs.livekit.io/agents/build/testing/)
-- [LiveKit Turn Detector](https://docs.livekit.io/agents/build/turns/turn-detector/) for contextually-aware speaker detection, with multilingual support
-- [Background voice cancellation](https://docs.livekit.io/home/cloud/noise-cancellation/)
-- Integrated [metrics and logging](https://docs.livekit.io/agents/build/metrics/)
-- A Dockerfile ready for [production deployment](https://docs.livekit.io/agents/ops/deployment/)
+**IMPORTANT:** This project uses `uv` for dependency management. Always use `uv run` to execute commands (e.g., `uv run python src/agent.py`). Do not manually activate virtual environments - `uv run` handles this automatically.
 
-This starter app is compatible with any [custom web/mobile frontend](https://docs.livekit.io/agents/start/frontend/) or [SIP-based telephony](https://docs.livekit.io/agents/start/telephony/).
+### Environment Setup
 
-## Coding agents and MCP
+1. Sign up for [LiveKit Cloud](https://cloud.livekit.io/)
 
-This project is designed to work with coding agents like [Cursor](https://www.cursor.com/) and [Claude Code](https://www.anthropic.com/claude-code). 
+2. Copy the example environment file:
+   ```bash
+   cp .env.example .env.local
+   ```
 
-To get the most out of these tools, install the [LiveKit Docs MCP server](https://docs.livekit.io/mcp).
+3. Fill in the required keys in `.env.local`:
+   - `LIVEKIT_URL`
+   - `LIVEKIT_API_KEY`
+   - `LIVEKIT_API_SECRET`
+   - `OPENAI_API_KEY`
+   - `ASSEMBLYAI_API_KEY`
+   - `CARTESIA_API_KEY`
 
-For Cursor, use this link:
+You can also use the [LiveKit CLI](https://docs.livekit.io/home/cli/cli-setup) to automatically load environment variables:
 
-[![Install MCP Server](https://cursor.com/deeplink/mcp-install-light.svg)](https://cursor.com/en-US/install-mcp?name=livekit-docs&config=eyJ1cmwiOiJodHRwczovL2RvY3MubGl2ZWtpdC5pby9tY3AifQ%3D%3D)
+```bash
+lk cloud auth
+lk app env -w -d .env.local
+```
 
-For Claude Code, run this command:
+### Download Model Files
 
-```
-claude mcp add --transport http livekit-docs https://docs.livekit.io/mcp
-```
+Before running either application for the first time, download required models:
 
-For Codex CLI, use this command to install the server:
-```
-codex mcp add --url https://docs.livekit.io/mcp livekit-docs
+```bash
+uv run python src/agent.py download-files
 ```
 
-For Gemini CLI, use this command to install the server:
+This downloads:
+- Silero VAD (Voice Activity Detection) model
+- LiveKit multilingual turn detector model
+
+## McDonald's Drive-Thru Agent
+
+### What It Does
+
+The Drive-Thru Agent is a specialized voice AI that:
+
+- Takes customer orders for McDonald's menu items
+- Searches and validates items against a real McDonald's menu
+- Handles item modifiers (add-ons, substitutions)
+- Confirms each item as it's added
+- Reads back the complete order
+- Saves orders as JSON files for processing
+
+### How It Works
+
+The Drive-Thru Agent consists of several components:
+
+1. **DriveThruAgent** (`src/drive_thru_agent.py`)
+   - Orchestrates the ordering conversation
+   - Defines the agent's persona and instructions
+   - Manages order state via `OrderStateManager`
+   - Provides tools for adding/confirming orders
+
+2. **DriveThruLLM** (`src/drive_thru_llm.py`)
+   - Wraps the base LLM (e.g., GPT-4)
+   - Intercepts chat requests to inject menu context
+   - Searches menu based on keywords in user messages
+   - Reduces hallucination by grounding LLM in actual menu items
+
+3. **MenuProvider** (`src/menu_provider.py`)
+   - Loads McDonald's menu from JSON
+   - Provides search functionality
+   - Returns structured menu items (categories, modifiers)
+
+4. **OrderStateManager** (`src/order_state_manager.py`)
+   - Tracks order items during conversation
+   - Saves completed orders to JSON files
+   - One instance per session
+
+### Running the Drive-Thru Agent
+
+#### Console Mode (Testing)
+
+Test the agent directly in your terminal:
+
+```bash
+uv run python src/agent.py console
 ```
-gemini mcp add --transport http livekit-docs https://docs.livekit.io/mcp
+
+This mode is perfect for:
+- Quick testing and debugging
+- Trying out the ordering flow
+- Experimenting with menu items
+
+#### Dev Mode (LiveKit Connection)
+
+Run the agent with a LiveKit connection for testing with real voice:
+
+```bash
+uv run python src/agent.py dev
 ```
 
-The project includes a complete [AGENTS.md](AGENTS.md) file for these assistants. You can modify this file  your needs. To learn more about this file, see [https://agents.md](https://agents.md).
+This mode:
+- Connects to LiveKit Cloud
+- Supports frontend applications
+- Includes noise cancellation
+- Enables real voice interactions
 
-## Dev Setup
+#### Production Mode
 
-Clone the repository and install dependencies:
+For production deployment:
 
-```console
-cd agent-starter-python
-uv sync
+```bash
+uv run python src/agent.py start
 ```
 
-**Important:** This project uses `uv` for dependency management. Always use `uv run` to execute commands (e.g., `uv run python src/agent.py`). Do not manually activate the virtual environment - `uv run` handles this automatically. If your IDE or shell auto-activates `.venv`, you can safely ignore it and continue using `uv run` for all commands.
+This is the production-ready entry point used in Docker deployments.
+
+### Menu Data
+
+The McDonald's menu is stored as structured Pydantic models in `menus/mcdonalds/`:
+
+- **Menu Structure** - `transformed-data/menu-structure-2026-01-21.json`
+- **Pydantic Models** - `models.py`
+  - `Menu` - Complete menu with categories
+  - `Item` - Individual menu item with modifiers
+  - `Modifier` - Item variations (e.g., "Extra Cheese", "No Pickles")
+
+Categories include:
+- Breakfast
+- Beef & Pork
+- Chicken & Fish
+- Snacks & Sides
+- Beverages
+- Coffee & Tea
+- Desserts
+- Smoothies & Shakes
+
+### Order Output
+
+Completed orders are saved to the `orders/` directory as JSON files:
+
+```json
+{
+  "session_id": "abc123",
+  "items": [
+    {
+      "item_name": "Big Mac",
+      "category": "Beef & Pork",
+      "modifiers": ["Extra Cheese", "No Pickles"]
+    }
+  ],
+  "timestamp": "2026-01-22T10:30:00Z"
+}
+```
+
+## Generic Voice Assistant
+
+### What It Does
 
-Sign up for [LiveKit Cloud](https://cloud.livekit.io/) then set up the environment by copying `.env.example` to `.env.local` and filling in the required keys:
+The Generic Voice Assistant is a general-purpose AI that:
 
-- `LIVEKIT_URL`
-- `LIVEKIT_API_KEY`
-- `LIVEKIT_API_SECRET`
+- Answers questions on various topics
+- Provides helpful information
+- Maintains a friendly, conversational tone
+- Works with any topic (not menu-specific)
 
-You can load the LiveKit environment automatically using the [LiveKit CLI](https://docs.livekit.io/home/cli/cli-setup):
+### Running the Voice Assistant
 
 ```bash
-lk cloud auth
-lk app env -w -d .env.local
+uv run python src/app.py
 ```
 
-## Run the agent
+This runs a generic voice assistant without menu integration. Use this for:
+- General Q&A applications
+- Non-specialized voice interactions
+- Testing the base voice pipeline
 
-Before your first run, you must download certain models such as [Silero VAD](https://docs.livekit.io/agents/build/turns/vad/) and the [LiveKit turn detector](https://docs.livekit.io/agents/build/turns/turn-detector/):
+## Development
 
-```console
-uv run python src/agent.py download-files
+### Project Structure
+
+```
+src/
+â”œâ”€â”€ agent.py                  # Drive-Thru Agent CLI (main entry point)
+â”œâ”€â”€ app.py                    # Generic Voice Assistant
+â”œâ”€â”€ config.py                 # Pydantic configuration models
+â”œâ”€â”€ factories.py              # Creates STT/LLM/TTS instances
+â”œâ”€â”€ session_handler.py        # Session orchestration
+â”œâ”€â”€ drive_thru_agent.py       # Drive-Thru Agent implementation
+â”œâ”€â”€ drive_thru_llm.py         # Menu-aware LLM wrapper
+â”œâ”€â”€ menu_provider.py          # Menu search and loading
+â”œâ”€â”€ order_state_manager.py   # Order tracking
+â””â”€â”€ tools/
+    â””â”€â”€ order_tools.py        # Order management tools
+
+menus/mcdonalds/
+â”œâ”€â”€ models.py                 # Pydantic menu models
+â”œâ”€â”€ transformed-data/         # Menu JSON files
+â””â”€â”€ raw-data/                 # Original menu data
+
+tests/
+â”œâ”€â”€ conftest.py              # Shared pytest fixtures
+â”œâ”€â”€ test_drive_thru_agent.py # Agent tests
+â”œâ”€â”€ test_menu_models.py      # Menu model tests
+â””â”€â”€ ...
 ```
 
-Next, run this command to speak to your agent directly in your terminal:
+### Testing
 
-```console
-uv run python src/agent.py console
+Run all tests:
+
+```bash
+uv run pytest
 ```
 
-To run the agent for use with a frontend or telephony, use the `dev` command:
+Run specific test file:
 
-```console
-uv run python src/agent.py dev
+```bash
+uv run pytest tests/test_drive_thru_agent.py -v
 ```
 
-In production, use the `start` command:
+Run with coverage:
 
-```console
-uv run python src/agent.py start
+```bash
+uv run pytest --cov=src --cov-report=html
 ```
 
-## Makefile
-
-This project includes a `Makefile` for convenient development workflows.
+### Code Formatting
 
-### Quick Commands
+Format code with ruff:
 
 ```bash
-# See all available commands
-make help
+uv run ruff format
+```
 
-# Run the agent (requires API keys configured for the chosen models)
-make console        # Console mode
-make dev            # Dev mode
-make start          # Production mode
+Lint code:
 
-# Development
-make test           # Run all tests
-make format         # Format code with ruff
-make lint           # Lint code with ruff
+```bash
+uv run ruff check
+```
+
+Fix linting issues:
 
-# Utilities
-make download-files # Download required model files
-make clean          # Remove generated files
+```bash
+uv run ruff check --fix
 ```
 
-## Frontend & Telephony
+### Using the Makefile
 
-Get started quickly with our pre-built frontend starter apps, or add telephony support:
+This project includes a Makefile for common tasks:
 
-| Platform | Link | Description |
-|----------|----------|-------------|
-| **Web** | [`livekit-examples/agent-starter-react`](https://github.com/livekit-examples/agent-starter-react) | Web voice AI assistant with React & Next.js |
-| **iOS/macOS** | [`livekit-examples/agent-starter-swift`](https://github.com/livekit-examples/agent-starter-swift) | Native iOS, macOS, and visionOS voice AI assistant |
-| **Flutter** | [`livekit-examples/agent-starter-flutter`](https://github.com/livekit-examples/agent-starter-flutter) | Cross-platform voice AI assistant app |
-| **React Native** | [`livekit-examples/voice-assistant-react-native`](https://github.com/livekit-examples/voice-assistant-react-native) | Native mobile app with React Native & Expo |
-| **Android** | [`livekit-examples/agent-starter-android`](https://github.com/livekit-examples/agent-starter-android) | Native Android app with Kotlin & Jetpack Compose |
-| **Web Embed** | [`livekit-examples/agent-starter-embed`](https://github.com/livekit-examples/agent-starter-embed) | Voice AI widget for any website |
-| **Telephony** | [ðŸ“š Documentation](https://docs.livekit.io/agents/start/telephony/) | Add inbound or outbound calling to your agent |
+```bash
+make help           # Show all available commands
+make console        # Run drive-thru agent in console mode
+make dev            # Run drive-thru agent in dev mode
+make test           # Run all tests
+make format         # Format code
+make lint           # Lint code
+make download-files # Download model files
+```
 
-For advanced customization, see the [complete frontend guide](https://docs.livekit.io/agents/start/frontend/).
+## Architecture
 
-## Tests and evals
+### Dependency Injection
 
-This project includes a complete suite of evals, based on the LiveKit Agents [testing & evaluation framework](https://docs.livekit.io/agents/build/testing/). To run them:
+This codebase uses dependency injection (DI) to construct components:
 
-```console
-make test
-# or
-uv run pytest
-```
+1. **Configuration** - `src/config.py` (Pydantic v2 models, env-driven)
+2. **Construction** - `src/factories.py` (builds STT/LLM/TTS)
+3. **Wiring** - `src/agent.py` or `src/app.py` (creates app + server)
+4. **Runtime** - `src/session_handler.py` (manages sessions)
 
+No custom adapters or protocols are used - components are constructed directly using LiveKit's concrete types.
 
+### Pydantic Models
 
-## McDonald's Menu Models
+This project uses **Pydantic v2** for all data models:
 
-This project includes Pydantic v2 models for representing McDonald's menu data, designed to provide structured menu information to the LLM agent.
+- Runtime validation
+- JSON serialization/deserialization
+- Schema generation
+- Environment variable integration
+- Better IDE support
 
-### Models
+See `AGENTS.md` for detailed guidelines on when to use Pydantic vs dataclasses.
 
-The menu system consists of three main models located in `menus/mcdonalds/models.py`:
+## Frontend & Deployment
 
-- **Modifier**: Represents a menu item variation/modifier
-  - `modifier_name: str` - Name of the modifier (e.g., "Egg Whites", "Cheese")
-  - `modifier_id: str` - Auto-generated UUID for each modifier
+### Frontend Options
 
-- **Item**: Represents a menu item
-  - `category_name: str` - Category (e.g., "Breakfast", "Beef & Pork")
-  - `item_name: str` - Item name (e.g., "Big Mac")
-  - `available_as_base: bool` - Whether item can be ordered without modifications
-  - `modifiers: list[Modifier]` - Available variations for this item
+Get started with pre-built frontend applications:
 
-- **Menu**: Complete menu structure
-  - `categories: dict[str, list[Item]]` - All items organized by category
-  - Helper methods for accessing and manipulating menu items
+| Platform | Repository | Description |
+|----------|-----------|-------------|
+| **Web** | [`agent-starter-react`](https://github.com/livekit-examples/agent-starter-react) | React & Next.js web app |
+| **iOS/macOS** | [`agent-starter-swift`](https://github.com/livekit-examples/agent-starter-swift) | Native iOS, macOS, visionOS |
+| **Flutter** | [`agent-starter-flutter`](https://github.com/livekit-examples/agent-starter-flutter) | Cross-platform mobile |
+| **React Native** | [`voice-assistant-react-native`](https://github.com/livekit-examples/voice-assistant-react-native) | React Native & Expo |
+| **Android** | [`agent-starter-android`](https://github.com/livekit-examples/agent-starter-android) | Native Android (Kotlin) |
+| **Web Embed** | [`agent-starter-embed`](https://github.com/livekit-examples/agent-starter-embed) | Embeddable widget |
+| **Telephony** | [Documentation](https://docs.livekit.io/agents/start/telephony/) | Phone integration |
 
-### Usage
+See the [complete frontend guide](https://docs.livekit.io/agents/start/frontend/) for advanced customization.
 
-```python
-from menus.mcdonalds.models import Menu
+### Production Deployment
 
-# Load the menu from the JSON file
-menu = Menu.load_from_file("menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json")
+This project includes a production-ready `Dockerfile`. To deploy:
 
-# Access items by category
-breakfast_items = menu.get_category("Breakfast")
+1. Build the Docker image:
+   ```bash
+   docker build -t drive-thru-agent .
+   ```
 
-# Get a specific item
-big_mac = menu.get_item("Beef & Pork", "Big Mac")
+2. Deploy to LiveKit Cloud or your preferred platform
 
-# Add new items
-from menus.mcdonalds.models import Item
-new_item = Item(
-    category_name="Breakfast",
-    item_name="New Item",
-    available_as_base=True
-)
-new_item.add_modifier("Extra Cheese")
-menu.add_item(new_item)
+See the [deploying to production guide](https://docs.livekit.io/agents/ops/deployment/) for details.
 
-# Save modified menu
-menu.save_to_file("updated_menu.json")
-```
+## Coding Agents and MCP
 
-### Serialization
+This project works with coding agents like [Cursor](https://www.cursor.com/) and [Claude Code](https://www.anthropic.com/claude-code).
 
-All models support JSON serialization and deserialization:
+Install the [LiveKit Docs MCP server](https://docs.livekit.io/mcp) for best results:
 
-```python
-# Serialize individual items or modifiers
-json_str = item.to_json()
-item = Item.from_json(json_str)
+**For Cursor:**
 
-# Serialize entire menu
-json_str = menu.to_json()
-menu = Menu.from_json(json_str)
+[![Install MCP Server](https://cursor.com/deeplink/mcp-install-light.svg)](https://cursor.com/en-US/install-mcp?name=livekit-docs&config=eyJ1cmwiOiJodHRwczovL2RvY3MubGl2ZWtpdC5pby9tY3AifQ%3D%3D)
 
-# Save/Load from files
-menu.save_to_file("output.json")
-menu = Menu.load_from_file("menu-structure-2026-01-21.json")
-```
+**For Claude Code:**
 
-### Testing
+```bash
+claude mcp add --transport http livekit-docs https://docs.livekit.io/mcp
+```
 
-Run the menu model tests:
+**For Codex CLI:**
 
-```console
-uv run python -m pytest tests/test_menu_models.py -v
+```bash
+codex mcp add --url https://docs.livekit.io/mcp livekit-docs
 ```
 
-## Deploying to production
+**For Gemini CLI:**
+
+```bash
+gemini mcp add --transport http livekit-docs https://docs.livekit.io/mcp
+```
 
-This project is production-ready and includes a working `Dockerfile`. To deploy it to LiveKit Cloud or another environment, see the [deploying to production](https://docs.livekit.io/agents/ops/deployment/) guide.
+The project includes a complete [AGENTS.md](AGENTS.md) file with coding guidelines. See [https://agents.md](https://agents.md) to learn more.
 
 
 
diff --git a/plan/thoughts/drive-thru-llm/01-menu-models-and-validation.md b/plan/thoughts/drive-thru-llm/01-menu-models-and-validation.md
deleted file mode 100644
index 3704081..0000000
--- a/plan/thoughts/drive-thru-llm/01-menu-models-and-validation.md
+++ /dev/null
@@ -1,433 +0,0 @@
-# Plan 01: Menu Models and Validation (Foundation Layer)
-
-**Created**: 2026-01-21
-**Status**: Ready for Implementation
-**Dependencies**: None (Foundation layer)
-**Estimated Complexity**: Low-Medium
-
----
-
-## Overview
-
-This is the **foundation layer** of the McDonald's Drive-Thru Agent. It implements pure functions and data models with **zero external dependencies**. Everything in this plan is:
-- Fast to test (no I/O, no API calls)
-- Deterministic (no randomness)
-- Pure (no side effects)
-- Easy to reason about
-
-**Success Criteria**: All unit tests pass in <1 second total.
-
----
-
-## Components to Build
-
-### 1. Enhanced Menu Models
-
-**File**: `menus/mcdonalds/models.py` (existing, needs enhancements)
-
-**Current State**: Already has `Item`, `Modifier`, and `Menu` classes
-
-**Enhancements Needed**:
-
-#### 1.1 Add `quantity` field to `Item`
-```python
-quantity: int = Field(default=1, description="Number of this item")
-```
-
-#### 1.2 Add `item_id` field to `Item`
-```python
-item_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique identifier")
-```
-
-#### 1.3 Implement `__add__` method for `Item`
-- **Purpose**: Allow combining identical items (e.g., 2 Big Macs + 1 Big Mac = 3 Big Macs)
-- **Rules**:
-  - Can only add items with same `item_name`
-  - Can only add items with same modifiers (set equality, order doesn't matter)
-  - Result has `quantity = item1.quantity + item2.quantity`
-  - Result gets new `item_id`
-- **Error Handling**: Raise `ValueError` if items don't match
-
-**Example**:
-```python
-item1 = Item(category_name="Beef & Pork", item_name="Big Mac", quantity=1)
-item2 = Item(category_name="Beef & Pork", item_name="Big Mac", quantity=2)
-combined = item1 + item2  # quantity=3
-
-# With modifiers - must match
-item3 = Item(category_name="Beef & Pork", item_name="Big Mac", quantity=1)
-item3.add_modifier("No Pickles")
-combined = item1 + item3  # ValueError! Different modifiers
-```
-
----
-
-### 2. Pure Validation Functions
-
-**File**: `src/menu_validation.py` (new)
-
-**Purpose**: Pure functions for menu item validation and fuzzy matching
-
-**Dependencies**:
-- `rapidfuzz` library (for fuzzy string matching)
-- Menu models (for type hints)
-
-#### 2.1 Data Classes
-
-```python
-@dataclass
-class ValidationResult:
-    """Result of a validation operation."""
-    is_valid: bool
-    matched_item: Item | None = None
-    confidence_score: float = 0.0
-    error_message: str | None = None
-```
-
-#### 2.2 Functions to Implement
-
-##### `fuzzy_match_item()`
-```python
-def fuzzy_match_item(
-    item_name: str,
-    menu_items: list[Item],
-    threshold: int = 85
-) -> ValidationResult:
-    """
-    Fuzzy match an item name against menu items.
-
-    Args:
-        item_name: The item name to match (e.g., "big mac", "Big Mack")
-        menu_items: List of menu items to search
-        threshold: Minimum score (0-100) to accept match
-
-    Returns:
-        ValidationResult with best match if above threshold
-
-    Examples:
-        - "Big Mack" â†’ matches "Big Mac" with high confidence
-        - "chicken nuggets" â†’ matches "Chicken McNuggets"
-        - "whopper" â†’ no match (not on menu)
-    """
-```
-
-**Implementation Notes**:
-- Use `rapidfuzz.process.extractOne()` with `fuzz.ratio` scorer
-- Return best match only if score >= threshold
-- Case-insensitive matching
-- Handle empty inputs gracefully
-
-##### `validate_item_exists()`
-```python
-def validate_item_exists(
-    item_name: str,
-    category: str,
-    menu_provider: MenuProvider
-) -> ValidationResult:
-    """
-    Validate that an item exists in the specified category.
-
-    First tries exact match, then falls back to fuzzy matching.
-
-    Args:
-        item_name: The item to validate
-        category: The menu category
-        menu_provider: Menu data provider
-
-    Returns:
-        ValidationResult indicating if item exists
-    """
-```
-
-**Implementation Notes**:
-- First try exact match (case-insensitive)
-- If no exact match, try fuzzy match
-- Return detailed error message if not found
-
-##### `validate_modifiers()`
-```python
-def validate_modifiers(
-    item: Item,
-    requested_modifiers: list[str],
-    fuzzy_threshold: int = 85
-) -> ValidationResult:
-    """
-    Validate that all requested modifiers are available for the item.
-
-    Args:
-        item: The menu item
-        requested_modifiers: List of modifier names requested
-        fuzzy_threshold: Threshold for fuzzy matching modifier names
-
-    Returns:
-        ValidationResult indicating if all modifiers are valid
-
-    Examples:
-        - Item: Big Mac, Modifiers: ["No Pickles"] â†’ valid
-        - Item: Big Mac, Modifiers: ["Anchovies"] â†’ invalid
-    """
-```
-
-**Implementation Notes**:
-- Use fuzzy matching for modifier names too
-- Return list of invalid modifiers in error message
-- Handle "No X" style modifiers (removal)
-
-##### `validate_order_item()` (Convenience Function)
-```python
-def validate_order_item(
-    item_name: str,
-    category: str,
-    modifiers: list[str],
-    menu_provider: MenuProvider,
-    fuzzy_threshold: int = 85
-) -> ValidationResult:
-    """
-    Complete validation: item exists + modifiers valid.
-
-    Convenience function that combines item existence and modifier validation.
-
-    Returns:
-        ValidationResult with either success or detailed error
-    """
-```
-
----
-
-## Testing Strategy
-
-### Unit Tests for Menu Models
-
-**File**: `tests/test_menu_models.py` (enhance existing)
-
-**New Tests**:
-
-1. **Test `quantity` field default**
-   ```python
-   def test_item_quantity_defaults_to_one():
-       item = Item(category_name="Beef & Pork", item_name="Big Mac")
-       assert item.quantity == 1
-   ```
-
-2. **Test `item_id` generation**
-   ```python
-   def test_item_id_is_unique():
-       item1 = Item(category_name="Beef & Pork", item_name="Big Mac")
-       item2 = Item(category_name="Beef & Pork", item_name="Big Mac")
-       assert item1.item_id != item2.item_id
-   ```
-
-3. **Test `__add__` with same items**
-   ```python
-   def test_add_identical_items():
-       item1 = Item(category_name="Beef & Pork", item_name="Big Mac", quantity=1)
-       item2 = Item(category_name="Beef & Pork", item_name="Big Mac", quantity=2)
-       combined = item1 + item2
-       assert combined.quantity == 3
-       assert combined.item_name == "Big Mac"
-   ```
-
-4. **Test `__add__` with different modifiers fails**
-   ```python
-   def test_add_items_with_different_modifiers_raises_error():
-       item1 = Item(category_name="Beef & Pork", item_name="Big Mac")
-       item2 = Item(category_name="Beef & Pork", item_name="Big Mac")
-       item2.add_modifier("No Pickles")
-
-       with pytest.raises(ValueError):
-           combined = item1 + item2
-   ```
-
-5. **Test `__add__` with same modifiers (different order)**
-   ```python
-   def test_add_items_with_same_modifiers_different_order():
-       item1 = Item(category_name="Beef & Pork", item_name="Big Mac")
-       item1.add_modifier("No Pickles")
-       item1.add_modifier("Extra Sauce")
-
-       item2 = Item(category_name="Beef & Pork", item_name="Big Mac")
-       item2.add_modifier("Extra Sauce")
-       item2.add_modifier("No Pickles")
-
-       combined = item1 + item2
-       assert combined.quantity == 2
-   ```
-
-### Unit Tests for Validation Functions
-
-**File**: `tests/test_menu_validation.py` (new)
-
-**Tests** (aim for 20+ tests, fast execution):
-
-#### Fuzzy Matching Tests
-
-1. `test_fuzzy_match_exact_match()` - "Big Mac" â†’ "Big Mac" (100% confidence)
-2. `test_fuzzy_match_case_insensitive()` - "big mac" â†’ "Big Mac"
-3. `test_fuzzy_match_typo()` - "Big Mack" â†’ "Big Mac"
-4. `test_fuzzy_match_synonym()` - "chicken nuggets" â†’ "Chicken McNuggets"
-5. `test_fuzzy_match_no_match()` - "whopper" â†’ None
-6. `test_fuzzy_match_below_threshold()` - "pizza" â†’ None (no valid match)
-7. `test_fuzzy_match_empty_input()` - "" â†’ error
-8. `test_fuzzy_match_empty_menu()` - any input with empty menu â†’ None
-
-#### Item Validation Tests
-
-9. `test_validate_item_exists_exact_match()`
-10. `test_validate_item_exists_fuzzy_match()`
-11. `test_validate_item_not_in_category()`
-12. `test_validate_item_wrong_category()`
-13. `test_validate_item_invalid_name()`
-
-#### Modifier Validation Tests
-
-14. `test_validate_modifiers_all_valid()`
-15. `test_validate_modifiers_one_invalid()`
-16. `test_validate_modifiers_empty_list()` - should be valid
-17. `test_validate_modifiers_fuzzy_match()` - "no pickles" â†’ "No Pickles"
-18. `test_validate_modifiers_no_modifiers_available()` - item has no modifiers
-
-#### Combined Validation Tests
-
-19. `test_validate_order_item_success()`
-20. `test_validate_order_item_invalid_item()`
-21. `test_validate_order_item_invalid_modifier()`
-22. `test_validate_order_item_both_invalid()`
-
-**Test Data Setup**:
-```python
-@pytest.fixture
-def sample_menu_items():
-    """Create a small test menu."""
-    return [
-        Item(category_name="Beef & Pork", item_name="Big Mac"),
-        Item(category_name="Beef & Pork", item_name="Quarter Pounder"),
-        Item(category_name="Chicken & Fish", item_name="Chicken McNuggets"),
-    ]
-
-@pytest.fixture
-def big_mac_with_modifiers():
-    """Create a Big Mac with available modifiers."""
-    item = Item(category_name="Beef & Pork", item_name="Big Mac")
-    item.add_modifier("No Pickles")
-    item.add_modifier("Extra Sauce")
-    item.add_modifier("No Onions")
-    return item
-```
-
----
-
-## BDD Scenarios (Behavior Testing)
-
-While this layer is primarily tested with unit tests, some behaviors map to BDD scenarios:
-
-### Related BDD Scenarios:
-- **Scenario 5.1** (Invalid menu item) - depends on `validate_item_exists()`
-- **Scenario 5.3** (Invalid modifier) - depends on `validate_modifiers()`
-- **Scenario 5.4** (STT error recovery) - depends on `fuzzy_match_item()`
-
-**BDD Step Definitions** (to be implemented in later phases):
-```python
-@then("the agent informs the customer the item is not available")
-def step_impl(context):
-    # Internally uses validate_item_exists()
-    pass
-
-@then("the agent confirms 'Big Mac' using fuzzy matching")
-def step_impl(context):
-    # Internally uses fuzzy_match_item()
-    pass
-```
-
----
-
-## Implementation Checklist
-
-### Phase 1: Menu Model Enhancements
-- [ ] Add `quantity: int = 1` field to `Item` class
-- [ ] Add `item_id: str = uuid4()` field to `Item` class
-- [ ] Implement `__add__()` method on `Item` class
-- [ ] Write unit tests for `quantity` field
-- [ ] Write unit tests for `item_id` uniqueness
-- [ ] Write unit tests for `__add__()` success cases
-- [ ] Write unit tests for `__add__()` error cases
-- [ ] Run tests: `uv run pytest tests/test_menu_models.py -v`
-- [ ] Verify all tests pass in <1 second
-
-### Phase 2: Validation Functions
-- [ ] Create `src/menu_validation.py`
-- [ ] Define `ValidationResult` dataclass
-- [ ] Implement `fuzzy_match_item()` function
-- [ ] Implement `validate_item_exists()` function
-- [ ] Implement `validate_modifiers()` function
-- [ ] Implement `validate_order_item()` function
-- [ ] Add type hints to all functions
-- [ ] Add docstrings to all functions
-
-### Phase 3: Validation Tests
-- [ ] Create `tests/test_menu_validation.py`
-- [ ] Write fuzzy matching tests (8 tests)
-- [ ] Write item validation tests (5 tests)
-- [ ] Write modifier validation tests (5 tests)
-- [ ] Write combined validation tests (4 tests)
-- [ ] Add test fixtures for menu items
-- [ ] Run tests: `uv run pytest tests/test_menu_validation.py -v`
-- [ ] Verify all tests pass in <1 second
-- [ ] Check code coverage: `uv run pytest --cov=src.menu_validation`
-- [ ] Aim for 100% coverage on pure functions
-
-### Phase 4: Edge Cases and Refinement
-- [ ] Test with empty inputs
-- [ ] Test with special characters in item names
-- [ ] Test with very long item names
-- [ ] Test with unicode characters
-- [ ] Optimize fuzzy matching threshold if needed
-- [ ] Document any edge cases found
-
-### Phase 5: Integration Prep
-- [ ] Verify all type hints are correct
-- [ ] Verify all docstrings are complete
-- [ ] Run formatter: `uv run ruff format src/menu_validation.py`
-- [ ] Run linter: `uv run ruff check src/menu_validation.py`
-- [ ] Commit changes with clear message
-
----
-
-## Success Criteria
-
-âœ… **All unit tests pass** (22+ tests)
-âœ… **Tests run in <1 second** (pure functions, no I/O)
-âœ… **100% code coverage** on validation functions
-âœ… **No external dependencies** (except rapidfuzz and menu models)
-âœ… **Type hints complete** (passes mypy --strict)
-âœ… **Docstrings complete** (all public functions documented)
-âœ… **Fuzzy matching works** for common typos and variations
-âœ… **Clear error messages** for validation failures
-
----
-
-## Dependencies for Next Plans
-
-**This plan provides**:
-- âœ… Enhanced `Item` model with `quantity` and `item_id`
-- âœ… `__add__()` method for combining items
-- âœ… `ValidationResult` dataclass
-- âœ… Pure validation functions
-- âœ… Foundation for all order taking logic
-
-**Next plans can now use**:
-- `fuzzy_match_item()` for STT error handling
-- `validate_item_exists()` for menu validation
-- `validate_modifiers()` for customization validation
-- `validate_order_item()` for complete order validation
-
----
-
-## Notes
-
-- This layer has **zero side effects** - all functions are pure
-- This layer is **fast to test** - no I/O, no API calls
-- This layer is **easy to debug** - deterministic behavior
-- This layer is **reusable** - functions can be used anywhere
-- This layer enables **TDD** - write test first, implement, iterate quickly
-
-**Key Principle**: Build a solid foundation before adding complexity. Pure functions are the most reliable building blocks.
diff --git a/plan/thoughts/drive-thru-llm/02-menu-provider.md b/plan/thoughts/drive-thru-llm/02-menu-provider.md
deleted file mode 100644
index 499f732..0000000
--- a/plan/thoughts/drive-thru-llm/02-menu-provider.md
+++ /dev/null
@@ -1,504 +0,0 @@
-# Plan 02: MenuProvider (Read-Only Data Access)
-
-**Created**: 2026-01-21
-**Status**: Ready for Implementation
-**Dependencies**: Plan 01 (Menu models must have `Item`, `Modifier`, `Menu` classes)
-**Estimated Complexity**: Low
-
----
-
-## Overview
-
-The `MenuProvider` is a **read-only data access layer** that loads the McDonald's menu from JSON and provides search/query interfaces. It follows the **Single Responsibility Principle** - it only provides menu data, never modifies it.
-
-**Key Principles**:
-- ðŸ“– **Read-only**: Never modifies menu data
-- ðŸ”’ **Immutable returns**: Returns copies, not mutable references
-- ðŸŽ¯ **Single source of truth**: Loads menu once, shares with all components
-- âš¡ **Fast queries**: Optimized for lookup operations
-
----
-
-## Component Design
-
-### File Structure
-
-**File**: `src/menu_provider.py` (new)
-
-**Dependencies**:
-- `menus/mcdonalds/models.py` (Menu, Item, Modifier Pydantic models)
-- `menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json`
-
----
-
-## Interface Contract
-
-```python
-class MenuProvider:
-    """Read-only menu data provider.
-
-    Loads the McDonald's menu from JSON and provides query methods.
-    All methods return immutable data (copies, not references).
-
-    Thread-safe: Can be shared across multiple agents/sessions.
-    """
-
-    def __init__(self, menu_file_path: str) -> None:
-        """
-        Load menu from JSON file.
-
-        Args:
-            menu_file_path: Path to menu JSON file
-
-        Raises:
-            FileNotFoundError: If menu file doesn't exist
-            ValueError: If menu JSON is invalid
-        """
-
-    def search_items(
-        self,
-        keyword: str,
-        category: str | None = None
-    ) -> list[Item]:
-        """
-        Search for items by keyword, optionally filtered by category.
-
-        Args:
-            keyword: Search term (case-insensitive)
-            category: Optional category to filter by
-
-        Returns:
-            List of matching items (copies, not references)
-
-        Examples:
-            - search_items("mac") â†’ [Big Mac, Egg McMuffin, ...]
-            - search_items("burger", category="Beef & Pork") â†’ [burgers only]
-            - search_items("coffee", category="Coffee & Tea") â†’ [coffee items]
-        """
-
-    def get_category(self, category_name: str) -> list[Item]:
-        """
-        Get all items in a category.
-
-        Args:
-            category_name: Name of category (e.g., "Breakfast")
-
-        Returns:
-            List of items in category (empty list if category not found)
-
-        Examples:
-            - get_category("Breakfast") â†’ [Egg McMuffin, Hash Browns, ...]
-            - get_category("Invalid") â†’ []
-        """
-
-    def get_item(
-        self,
-        category_name: str,
-        item_name: str
-    ) -> Item | None:
-        """
-        Get a specific item by category and name.
-
-        Args:
-            category_name: Category the item is in
-            item_name: Name of the item (case-insensitive)
-
-        Returns:
-            Item if found, None otherwise
-
-        Examples:
-            - get_item("Beef & Pork", "Big Mac") â†’ Item(...)
-            - get_item("Breakfast", "Big Mac") â†’ None (wrong category)
-        """
-
-    def get_all_categories(self) -> list[str]:
-        """
-        Get list of all category names.
-
-        Returns:
-            List of category names
-
-        Example:
-            â†’ ["Breakfast", "Beef & Pork", "Chicken & Fish", ...]
-        """
-
-    def get_menu(self) -> Menu:
-        """
-        Get the complete menu.
-
-        Returns:
-            Complete Menu object (immutable copy)
-        """
-
-    def get_items_count(self) -> int:
-        """Get total number of items across all categories."""
-
-    def category_exists(self, category_name: str) -> bool:
-        """Check if a category exists."""
-```
-
----
-
-## Implementation Details
-
-### 1. Constructor
-
-**Responsibility**: Load and validate menu data
-
-```python
-def __init__(self, menu_file_path: str) -> None:
-    """Load menu from JSON file."""
-    # 1. Validate file exists
-    if not Path(menu_file_path).exists():
-        raise FileNotFoundError(f"Menu file not found: {menu_file_path}")
-
-    # 2. Load menu using Pydantic model
-    self._menu = Menu.load_from_file(menu_file_path)
-
-    # 3. Build lookup indices for fast queries (optional optimization)
-    self._build_indices()
-```
-
-**Private State**:
-- `self._menu: Menu` - The loaded menu (private, immutable)
-- `self._category_index: dict[str, list[Item]]` - Category name â†’ items
-- `self._item_index: dict[str, Item]` - Item name â†’ item (for fast lookup)
-
-### 2. Search Methods
-
-#### `search_items()`
-
-**Implementation**:
-```python
-def search_items(self, keyword: str, category: str | None = None) -> list[Item]:
-    """Search for items by keyword."""
-    keyword_lower = keyword.lower()
-    results = []
-
-    # Get items to search
-    if category:
-        items_to_search = self.get_category(category)
-    else:
-        items_to_search = self._get_all_items()
-
-    # Search item names (case-insensitive substring match)
-    for item in items_to_search:
-        if keyword_lower in item.item_name.lower():
-            # Return copy, not reference
-            results.append(item.model_copy())
-
-    return results
-```
-
-#### `get_category()`
-
-**Implementation**:
-```python
-def get_category(self, category_name: str) -> list[Item]:
-    """Get all items in a category."""
-    # Use index for O(1) lookup
-    items = self._category_index.get(category_name, [])
-
-    # Return copies, not references
-    return [item.model_copy() for item in items]
-```
-
-#### `get_item()`
-
-**Implementation**:
-```python
-def get_item(self, category_name: str, item_name: str) -> Item | None:
-    """Get a specific item."""
-    items = self.get_category(category_name)
-
-    for item in items:
-        if item.item_name.lower() == item_name.lower():
-            return item.model_copy()  # Return copy
-
-    return None
-```
-
-### 3. Helper Methods
-
-```python
-def _build_indices(self) -> None:
-    """Build lookup indices for fast queries (called once on init)."""
-    self._category_index = {}
-
-    for category_name, items in self._menu.categories.items():
-        self._category_index[category_name] = items
-
-def _get_all_items(self) -> list[Item]:
-    """Get all items across all categories."""
-    all_items = []
-    for items in self._category_index.values():
-        all_items.extend(items)
-    return all_items
-```
-
----
-
-## Testing Strategy
-
-### Unit Tests
-
-**File**: `tests/test_menu_provider.py` (new)
-
-**Test Fixture**:
-```python
-@pytest.fixture
-def menu_provider():
-    """Create MenuProvider with real menu file."""
-    menu_path = "menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json"
-    return MenuProvider(menu_path)
-
-@pytest.fixture
-def test_menu_provider(tmp_path):
-    """Create MenuProvider with small test menu."""
-    # Create minimal test menu JSON
-    test_menu = {
-        "categories": {
-            "Breakfast": [
-                {
-                    "category_name": "Breakfast",
-                    "item_name": "Egg McMuffin",
-                    "available_as_base": True,
-                    "modifiers": []
-                }
-            ],
-            "Beef & Pork": [
-                {
-                    "category_name": "Beef & Pork",
-                    "item_name": "Big Mac",
-                    "available_as_base": True,
-                    "modifiers": [
-                        {"modifier_name": "No Pickles", "modifier_id": "abc"}
-                    ]
-                }
-            ]
-        }
-    }
-
-    menu_file = tmp_path / "test_menu.json"
-    menu_file.write_text(json.dumps(test_menu))
-    return MenuProvider(str(menu_file))
-```
-
-**Test Cases** (aim for 15+ tests):
-
-#### Construction Tests
-1. `test_menu_provider_loads_successfully()` - Constructor works with valid file
-2. `test_menu_provider_file_not_found()` - Raises FileNotFoundError for missing file
-3. `test_menu_provider_invalid_json()` - Raises ValueError for bad JSON
-
-#### Search Tests
-4. `test_search_items_finds_exact_match()` - "Big Mac" finds Big Mac
-5. `test_search_items_case_insensitive()` - "big mac" finds Big Mac
-6. `test_search_items_partial_match()` - "mac" finds Big Mac, Egg McMuffin
-7. `test_search_items_with_category_filter()` - Search within category only
-8. `test_search_items_no_matches()` - Returns empty list for "whopper"
-9. `test_search_items_empty_keyword()` - Returns all items or empty list
-
-#### Category Tests
-10. `test_get_category_valid()` - Get Breakfast category
-11. `test_get_category_invalid()` - Returns empty list for invalid category
-12. `test_get_category_case_sensitive()` - Category names are case-sensitive
-13. `test_get_all_categories()` - Returns all category names
-
-#### Item Lookup Tests
-14. `test_get_item_exists()` - Get Big Mac from Beef & Pork
-15. `test_get_item_wrong_category()` - Returns None for Big Mac in Breakfast
-16. `test_get_item_not_found()` - Returns None for invalid item
-17. `test_get_item_case_insensitive()` - "big mac" finds "Big Mac"
-
-#### Immutability Tests
-18. `test_returns_copies_not_references()` - Modifying returned item doesn't affect menu
-```python
-def test_returns_copies_not_references(menu_provider):
-    """Verify MenuProvider returns copies, not mutable references."""
-    item1 = menu_provider.get_item("Beef & Pork", "Big Mac")
-    item2 = menu_provider.get_item("Beef & Pork", "Big Mac")
-
-    # Modify item1
-    item1.quantity = 999
-
-    # item2 should be unaffected
-    assert item2.quantity == 1  # Default
-
-    # Re-fetch should also be unaffected
-    item3 = menu_provider.get_item("Beef & Pork", "Big Mac")
-    assert item3.quantity == 1
-```
-
-#### Count and Utility Tests
-19. `test_get_items_count()` - Total items = 212 (for real menu)
-20. `test_category_exists()` - Returns True/False correctly
-
----
-
-## BDD Scenarios
-
-While MenuProvider is tested primarily with unit tests, it supports these BDD scenarios:
-
-**Related BDD Scenarios**:
-- **Scenario 1.1** (Order a Big Mac) - uses `get_item()`
-- **Scenario 1.3** (Order breakfast) - uses `get_category()`
-- **Scenario 5.1** (Invalid menu item) - uses `get_item()` returning None
-- **Scenario 5.2** (Ambiguous request) - uses `search_items()` for suggestions
-
-**Example BDD Step** (implemented in later phases):
-```python
-@given("the McDonald's menu is loaded")
-def step_impl(context):
-    context.menu_provider = MenuProvider(
-        "menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json"
-    )
-```
-
----
-
-## Implementation Checklist
-
-### Phase 1: Basic Structure
-- [ ] Create `src/menu_provider.py`
-- [ ] Define `MenuProvider` class skeleton
-- [ ] Implement `__init__()` with file loading
-- [ ] Add error handling for file not found
-- [ ] Add error handling for invalid JSON
-- [ ] Test constructor with valid menu file
-- [ ] Test constructor with invalid inputs
-
-### Phase 2: Query Methods
-- [ ] Implement `get_all_categories()`
-- [ ] Implement `get_category()`
-- [ ] Implement `get_item()`
-- [ ] Implement `search_items()` (basic)
-- [ ] Implement `get_menu()`
-- [ ] Test each method individually
-
-### Phase 3: Optimization
-- [ ] Implement `_build_indices()` for fast lookups
-- [ ] Add `get_items_count()` method
-- [ ] Add `category_exists()` method
-- [ ] Optimize `search_items()` with indices
-- [ ] Test performance with full menu (212 items)
-
-### Phase 4: Immutability
-- [ ] Ensure all methods return copies via `model_copy()`
-- [ ] Write immutability tests
-- [ ] Verify no mutable references escape
-- [ ] Document immutability guarantees
-
-### Phase 5: Testing
-- [ ] Create `tests/test_menu_provider.py`
-- [ ] Write construction tests (3 tests)
-- [ ] Write search tests (6 tests)
-- [ ] Write category tests (4 tests)
-- [ ] Write item lookup tests (4 tests)
-- [ ] Write immutability tests (1 test)
-- [ ] Write utility tests (2 tests)
-- [ ] Run tests: `uv run pytest tests/test_menu_provider.py -v`
-- [ ] Verify tests complete in <2 seconds
-
-### Phase 6: Code Quality
-- [ ] Add type hints to all methods
-- [ ] Add docstrings to all public methods
-- [ ] Run formatter: `uv run ruff format src/menu_provider.py`
-- [ ] Run linter: `uv run ruff check src/menu_provider.py`
-- [ ] Check coverage: `uv run pytest --cov=src.menu_provider`
-
-### Phase 7: Integration Prep
-- [ ] Test with real menu file (212 items, 9 categories)
-- [ ] Verify all 9 categories load correctly
-- [ ] Verify search works across all items
-- [ ] Document any performance considerations
-- [ ] Commit changes
-
----
-
-## Success Criteria
-
-âœ… **All unit tests pass** (20+ tests)
-âœ… **Tests run in <2 seconds** (fast file I/O)
-âœ… **Loads real menu correctly** (212 items, 9 categories)
-âœ… **Returns immutable data** (copies, not references)
-âœ… **Fast queries** (O(1) category lookup, O(n) search)
-âœ… **Type hints complete** (passes mypy --strict)
-âœ… **Docstrings complete** (all public methods documented)
-âœ… **Thread-safe** (read-only, no mutable state)
-
----
-
-## Dependencies for Next Plans
-
-**This plan provides**:
-- âœ… `MenuProvider` class for read-only menu access
-- âœ… Fast query methods: `get_item()`, `get_category()`, `search_items()`
-- âœ… Immutable data guarantees
-- âœ… Single source of truth for menu data
-
-**Next plans can now use**:
-- `MenuProvider` for menu queries in validation
-- `MenuProvider` for context injection in DriveThruLLM
-- `MenuProvider` for tool implementations
-- `MenuProvider` as singleton in agent app
-
----
-
-## Design Notes
-
-### Why Read-Only?
-
-Making MenuProvider read-only provides several benefits:
-1. **Thread-safe**: Can be shared across sessions without locks
-2. **No corruption**: Menu cannot be accidentally modified
-3. **Single source of truth**: Menu data is guaranteed consistent
-4. **Testable**: Predictable behavior, no hidden state changes
-
-### Why Return Copies?
-
-Returning copies (via `model_copy()`) prevents:
-- Callers modifying internal menu data
-- Reference aliasing bugs
-- Unexpected mutations affecting other components
-
-Trade-off: Slight memory overhead, but worth it for safety.
-
-### Why Build Indices?
-
-Pre-building indices on construction gives us:
-- O(1) category lookups instead of O(n)
-- Faster queries overall
-- One-time cost at startup, benefits for all queries
-
-For a 212-item menu, this is negligible overhead with significant benefit.
-
----
-
-## Example Usage
-
-```python
-# Initialize (typically done once at app startup)
-menu_provider = MenuProvider(
-    "menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json"
-)
-
-# Query for an item
-big_mac = menu_provider.get_item("Beef & Pork", "Big Mac")
-if big_mac:
-    print(f"Found: {big_mac.item_name}")
-
-# Search for items
-mac_items = menu_provider.search_items("mac")
-print(f"Found {len(mac_items)} items with 'mac': {[i.item_name for i in mac_items]}")
-
-# Get a category
-breakfast_items = menu_provider.get_category("Breakfast")
-print(f"Breakfast has {len(breakfast_items)} items")
-
-# Get all categories
-categories = menu_provider.get_all_categories()
-print(f"Menu has {len(categories)} categories: {categories}")
-```
-
-**Key Principle**: MenuProvider is a pure data access layer. It loads, queries, and returns menu data. Nothing more, nothing less.
diff --git a/plan/thoughts/drive-thru-llm/03-order-state-manager.md b/plan/thoughts/drive-thru-llm/03-order-state-manager.md
deleted file mode 100644
index 8a9a092..0000000
--- a/plan/thoughts/drive-thru-llm/03-order-state-manager.md
+++ /dev/null
@@ -1,761 +0,0 @@
-# Plan 03: OrderStateManager (State & Persistence)
-
-**Created**: 2026-01-21
-**Status**: Ready for Implementation
-**Dependencies**: Plan 01 (OrderItem dataclass)
-**Estimated Complexity**: Medium
-
----
-
-## Overview
-
-The `OrderStateManager` is the **single source of truth** for all order state. Every order mutation (add, remove, update) flows through this component. It handles both in-memory state and persistence (incremental logs + final JSON).
-
-**Key Principles**:
-- ðŸŽ¯ **Single Source of Truth**: ALL order state lives here
-- ðŸ“ **Tell, Don't Ask**: Components tell it what to do, don't query and manipulate
-- ðŸ’¾ **Dual Persistence**: Incremental log (append-only) + final JSON (on complete)
-- ðŸ”’ **Encapsulation**: Private state, public command/query methods
-- âš¡ **Fast Testing**: In-memory operations are fast; file I/O tested separately
-
----
-
-## Component Design
-
-### File Structure
-
-**File**: `src/order_state_manager.py` (new)
-
-**Dependencies**:
-- Standard library: `dataclasses`, `datetime`, `json`, `pathlib`, `uuid`
-- No external dependencies (lightweight, fast)
-
----
-
-## Data Model
-
-### OrderItem Dataclass
-
-```python
-from dataclasses import dataclass, field
-from datetime import datetime
-import uuid
-
-@dataclass
-class OrderItem:
-    """A single item in an order.
-
-    Represents one line item with all its details.
-    Immutable after creation (use update methods on OrderStateManager).
-    """
-
-    item_name: str
-    category: str
-    modifiers: list[str] = field(default_factory=list)
-    quantity: int = 1
-    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))
-    timestamp: datetime = field(default_factory=datetime.now)
-
-    def to_dict(self) -> dict:
-        """Convert to dictionary for JSON serialization."""
-        return {
-            "item_id": self.item_id,
-            "item_name": self.item_name,
-            "category": self.category,
-            "modifiers": self.modifiers,
-            "quantity": self.quantity,
-            "timestamp": self.timestamp.isoformat(),
-        }
-
-    @classmethod
-    def from_dict(cls, data: dict) -> "OrderItem":
-        """Create OrderItem from dictionary."""
-        return cls(
-            item_id=data["item_id"],
-            item_name=data["item_name"],
-            category=data["category"],
-            modifiers=data.get("modifiers", []),
-            quantity=data.get("quantity", 1),
-            timestamp=datetime.fromisoformat(data["timestamp"]),
-        )
-```
-
----
-
-## Interface Contract
-
-```python
-class OrderStateManager:
-    """Single source of truth for order state and persistence.
-
-    Manages:
-    - In-memory order state (list of OrderItem)
-    - Incremental logging (append after each mutation)
-    - Final JSON output (on order completion)
-    - Session lifecycle
-
-    Thread-safety: NOT thread-safe. Each agent session gets its own instance.
-    """
-
-    def __init__(self, session_id: str, output_dir: str = "orders") -> None:
-        """
-        Initialize order state for a session.
-
-        Args:
-            session_id: Unique session identifier (UUID)
-            output_dir: Directory to save order files
-
-        Creates:
-            - {output_dir}/{session_id}/ directory
-            - incremental_log.jsonl file (empty initially)
-        """
-
-    # Command Methods (mutations)
-
-    def add_item(
-        self,
-        item_name: str,
-        category: str,
-        modifiers: list[str] | None = None,
-        quantity: int = 1
-    ) -> OrderItem:
-        """
-        Add item to order.
-
-        Args:
-            item_name: Name of the menu item
-            category: Menu category
-            modifiers: List of modifier names (default: empty list)
-            quantity: Number of items (default: 1)
-
-        Returns:
-            The created OrderItem
-
-        Side effects:
-            - Appends item to in-memory order
-            - Appends to incremental log file
-        """
-
-    def remove_item(self, item_id: str) -> bool:
-        """
-        Remove item by ID.
-
-        Args:
-            item_id: The UUID of the item to remove
-
-        Returns:
-            True if found and removed, False otherwise
-
-        Side effects:
-            - Removes item from in-memory order
-            - Appends removal event to incremental log
-        """
-
-    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:
-        """
-        Update quantity for an item.
-
-        Args:
-            item_id: The UUID of the item
-            new_quantity: New quantity (must be > 0)
-
-        Returns:
-            True if found and updated, False otherwise
-
-        Side effects:
-            - Updates item quantity in-memory
-            - Appends update event to incremental log
-        """
-
-    def complete_order(self) -> dict:
-        """
-        Mark order complete and generate final JSON.
-
-        Returns:
-            Final order dictionary
-
-        Side effects:
-            - Writes final_order.json file
-            - Appends completion event to incremental log
-        """
-
-    def clear_order(self) -> None:
-        """
-        Clear all items (for cancellation/restart).
-
-        Side effects:
-            - Clears in-memory order
-            - Appends clear event to incremental log
-        """
-
-    # Query Methods (read-only)
-
-    def get_items(self) -> list[OrderItem]:
-        """
-        Get all items in current order (read-only copy).
-
-        Returns:
-            List of OrderItem (copies, not references)
-        """
-
-    def get_item_by_id(self, item_id: str) -> OrderItem | None:
-        """Get a specific item by its ID."""
-
-    def get_total_count(self) -> int:
-        """
-        Get total number of items (accounting for quantities).
-
-        Example: If order has 2x Big Mac (quantity=2) and 1x Fries (quantity=1),
-        returns 3.
-        """
-
-    def get_order_summary(self) -> str:
-        """
-        Get human-readable order summary.
-
-        Returns:
-            String like "2 Big Mac, 1 Medium Fries, 1 Coke"
-        """
-
-    def is_empty(self) -> bool:
-        """Check if order has no items."""
-
-    # Private Methods (implementation details)
-
-    def _append_to_log(self, event: dict) -> None:
-        """Append event to incremental log file."""
-
-    def _ensure_session_directory(self) -> None:
-        """Create session directory if it doesn't exist."""
-```
-
----
-
-## Implementation Details
-
-### 1. Constructor
-
-```python
-def __init__(self, session_id: str, output_dir: str = "orders") -> None:
-    """Initialize order state for a session."""
-    self._session_id = session_id
-    self._output_dir = Path(output_dir)
-    self._session_dir = self._output_dir / session_id
-
-    # In-memory state
-    self._items: list[OrderItem] = []
-    self._start_time = datetime.now()
-    self._status = "in_progress"  # or "completed", "cancelled"
-
-    # File paths
-    self._incremental_log_path = self._session_dir / "incremental_log.jsonl"
-    self._final_order_path = self._session_dir / "final_order.json"
-
-    # Create session directory and empty log file
-    self._ensure_session_directory()
-```
-
-### 2. Command Methods
-
-#### `add_item()`
-
-```python
-def add_item(
-    self,
-    item_name: str,
-    category: str,
-    modifiers: list[str] | None = None,
-    quantity: int = 1
-) -> OrderItem:
-    """Add item to order."""
-    # Create OrderItem
-    item = OrderItem(
-        item_name=item_name,
-        category=category,
-        modifiers=modifiers or [],
-        quantity=quantity,
-    )
-
-    # Add to in-memory state
-    self._items.append(item)
-
-    # Log event
-    self._append_to_log({
-        "event": "add_item",
-        "timestamp": datetime.now().isoformat(),
-        "item": item.to_dict(),
-    })
-
-    return item
-```
-
-#### `remove_item()`
-
-```python
-def remove_item(self, item_id: str) -> bool:
-    """Remove item by ID."""
-    # Find item
-    item_to_remove = None
-    for item in self._items:
-        if item.item_id == item_id:
-            item_to_remove = item
-            break
-
-    if item_to_remove is None:
-        return False
-
-    # Remove from in-memory state
-    self._items.remove(item_to_remove)
-
-    # Log event
-    self._append_to_log({
-        "event": "remove_item",
-        "timestamp": datetime.now().isoformat(),
-        "item_id": item_id,
-        "item_name": item_to_remove.item_name,
-    })
-
-    return True
-```
-
-#### `complete_order()`
-
-```python
-def complete_order(self) -> dict:
-    """Mark order complete and generate final JSON."""
-    self._status = "completed"
-
-    # Build final order dict
-    final_order = {
-        "session_id": self._session_id,
-        "start_time": self._start_time.isoformat(),
-        "completion_time": datetime.now().isoformat(),
-        "status": self._status,
-        "items": [item.to_dict() for item in self._items],
-        "total_items": self.get_total_count(),
-        "order_summary": self.get_order_summary(),
-    }
-
-    # Write final JSON
-    with open(self._final_order_path, "w") as f:
-        json.dump(final_order, f, indent=2)
-
-    # Log completion event
-    self._append_to_log({
-        "event": "complete_order",
-        "timestamp": datetime.now().isoformat(),
-        "total_items": self.get_total_count(),
-    })
-
-    return final_order
-```
-
-### 3. Query Methods
-
-#### `get_items()`
-
-```python
-def get_items(self) -> list[OrderItem]:
-    """Get all items (read-only copy)."""
-    # Return copy to prevent external mutations
-    return [
-        OrderItem(
-            item_id=item.item_id,
-            item_name=item.item_name,
-            category=item.category,
-            modifiers=item.modifiers.copy(),  # Copy modifiers list
-            quantity=item.quantity,
-            timestamp=item.timestamp,
-        )
-        for item in self._items
-    ]
-```
-
-#### `get_order_summary()`
-
-```python
-def get_order_summary(self) -> str:
-    """Get human-readable order summary."""
-    if not self._items:
-        return "No items"
-
-    # Group items for display
-    summary_parts = []
-    for item in self._items:
-        if item.quantity > 1:
-            summary_parts.append(f"{item.quantity} {item.item_name}")
-        else:
-            summary_parts.append(f"1 {item.item_name}")
-
-    return ", ".join(summary_parts)
-```
-
-### 4. Private Methods
-
-#### `_append_to_log()`
-
-```python
-def _append_to_log(self, event: dict) -> None:
-    """Append event to incremental log file (JSONL format)."""
-    with open(self._incremental_log_path, "a") as f:
-        f.write(json.dumps(event) + "\n")
-```
-
-#### `_ensure_session_directory()`
-
-```python
-def _ensure_session_directory(self) -> None:
-    """Create session directory if it doesn't exist."""
-    self._session_dir.mkdir(parents=True, exist_ok=True)
-
-    # Create empty log file if it doesn't exist
-    if not self._incremental_log_path.exists():
-        self._incremental_log_path.touch()
-```
-
----
-
-## Testing Strategy
-
-### Unit Tests
-
-**File**: `tests/test_order_state.py` (new)
-
-**Test Organization**:
-- In-memory tests (fast, no file I/O)
-- File I/O tests (use temp directory)
-- Edge case tests
-
-**Test Fixtures**:
-```python
-import tempfile
-import pytest
-from pathlib import Path
-
-@pytest.fixture
-def temp_output_dir(tmp_path):
-    """Create temporary output directory for tests."""
-    return str(tmp_path / "orders")
-
-@pytest.fixture
-def order_manager(temp_output_dir):
-    """Create OrderStateManager with temp directory."""
-    return OrderStateManager(
-        session_id="test-session-123",
-        output_dir=temp_output_dir
-    )
-```
-
-**Test Cases** (aim for 25+ tests):
-
-#### Construction Tests
-1. `test_order_manager_creates_session_directory()`
-2. `test_order_manager_creates_empty_log_file()`
-3. `test_order_manager_starts_with_empty_order()`
-
-#### Add Item Tests
-4. `test_add_item_single_item()`
-5. `test_add_item_with_modifiers()`
-6. `test_add_item_with_quantity()`
-7. `test_add_item_returns_order_item()`
-8. `test_add_item_assigns_unique_id()`
-9. `test_add_item_appends_to_log()`
-
-#### Remove Item Tests
-10. `test_remove_item_by_id_success()`
-11. `test_remove_item_by_id_not_found()`
-12. `test_remove_item_appends_to_log()`
-
-#### Update Item Tests
-13. `test_update_item_quantity_success()`
-14. `test_update_item_quantity_not_found()`
-15. `test_update_item_quantity_invalid_value()` (quantity <= 0)
-
-#### Query Tests
-16. `test_get_items_returns_copies()`
-```python
-def test_get_items_returns_copies(order_manager):
-    """Verify get_items() returns copies, not references."""
-    order_manager.add_item("Big Mac", "Beef & Pork")
-
-    items1 = order_manager.get_items()
-    items2 = order_manager.get_items()
-
-    # Modify first item
-    items1[0].quantity = 999
-
-    # Second call should be unaffected
-    assert items2[0].quantity == 1
-```
-
-17. `test_get_total_count_single_item()`
-18. `test_get_total_count_multiple_quantities()`
-```python
-def test_get_total_count_multiple_quantities(order_manager):
-    """Total count sums quantities."""
-    order_manager.add_item("Big Mac", "Beef & Pork", quantity=2)
-    order_manager.add_item("Fries", "Snacks & Sides", quantity=1)
-
-    assert order_manager.get_total_count() == 3
-```
-
-19. `test_get_order_summary_format()`
-20. `test_is_empty_true_and_false()`
-
-#### Complete Order Tests
-21. `test_complete_order_writes_final_json()`
-```python
-def test_complete_order_writes_final_json(order_manager, temp_output_dir):
-    """Verify final JSON is written on completion."""
-    order_manager.add_item("Big Mac", "Beef & Pork")
-    order_manager.add_item("Fries", "Snacks & Sides")
-
-    final_order = order_manager.complete_order()
-
-    # Check return value
-    assert final_order["total_items"] == 2
-    assert len(final_order["items"]) == 2
-
-    # Check file was created
-    final_path = Path(temp_output_dir) / "test-session-123" / "final_order.json"
-    assert final_path.exists()
-
-    # Check file contents
-    with open(final_path) as f:
-        saved_order = json.load(f)
-    assert saved_order == final_order
-```
-
-22. `test_complete_order_includes_session_info()`
-23. `test_complete_order_includes_summary()`
-
-#### Clear Order Tests
-24. `test_clear_order_removes_all_items()`
-25. `test_clear_order_logs_event()`
-
-#### Incremental Log Tests
-26. `test_incremental_log_format_is_jsonl()`
-```python
-def test_incremental_log_format_is_jsonl(order_manager, temp_output_dir):
-    """Verify incremental log is valid JSONL."""
-    order_manager.add_item("Big Mac", "Beef & Pork")
-    order_manager.add_item("Fries", "Snacks & Sides")
-    order_manager.remove_item(order_manager.get_items()[0].item_id)
-
-    log_path = Path(temp_output_dir) / "test-session-123" / "incremental_log.jsonl"
-
-    # Read log
-    with open(log_path) as f:
-        lines = f.readlines()
-
-    # Should have 3 events: add, add, remove
-    assert len(lines) == 3
-
-    # Each line should be valid JSON
-    for line in lines:
-        event = json.loads(line)
-        assert "event" in event
-        assert "timestamp" in event
-```
-
-27. `test_incremental_log_contains_all_events()`
-
-#### Edge Cases
-28. `test_add_item_empty_modifiers_list()`
-29. `test_remove_item_from_empty_order()`
-30. `test_complete_order_empty_order()`
-
----
-
-## BDD Scenarios
-
-OrderStateManager supports all BDD scenarios through its state management:
-
-**Related BDD Scenarios**:
-- **All scenarios in 01-06** depend on OrderStateManager for state
-- **Scenario 1.1** (Order Big Mac) - uses `add_item()`
-- **Scenario 2.1** (Multiple items) - uses `add_item()` multiple times
-- **Scenario 4.1** (Corrections) - uses `remove_item()` and `add_item()`
-- **Scenario 4.3** (Remove item) - uses `remove_item()`
-- **Scenario 6.1** (Complete order) - uses `complete_order()`
-- **Scenario 6.2** (Cancel order) - uses `clear_order()`
-
-**BDD Step Example**:
-```python
-@then("the order file contains {n:d} items")
-def step_impl(context, n):
-    # Load final order JSON
-    order_data = load_final_order(context.session_id)
-    assert len(order_data["items"]) == n
-
-@then('the order file shows "Big Mac" in category "Beef & Pork"')
-def step_impl(context):
-    order_data = load_final_order(context.session_id)
-    big_mac = next(
-        (item for item in order_data["items"] if item["item_name"] == "Big Mac"),
-        None
-    )
-    assert big_mac is not None
-    assert big_mac["category"] == "Beef & Pork"
-```
-
----
-
-## Implementation Checklist
-
-### Phase 1: Data Model
-- [ ] Create `src/order_state_manager.py`
-- [ ] Define `OrderItem` dataclass
-- [ ] Implement `OrderItem.to_dict()`
-- [ ] Implement `OrderItem.from_dict()`
-- [ ] Write tests for OrderItem serialization
-
-### Phase 2: OrderStateManager Skeleton
-- [ ] Define `OrderStateManager` class
-- [ ] Implement `__init__()` with directory creation
-- [ ] Implement `_ensure_session_directory()`
-- [ ] Test constructor creates directories correctly
-
-### Phase 3: Command Methods
-- [ ] Implement `add_item()`
-- [ ] Implement `remove_item()`
-- [ ] Implement `update_item_quantity()`
-- [ ] Implement `clear_order()`
-- [ ] Implement `complete_order()`
-- [ ] Test each method individually
-
-### Phase 4: Query Methods
-- [ ] Implement `get_items()` (with copy logic)
-- [ ] Implement `get_item_by_id()`
-- [ ] Implement `get_total_count()`
-- [ ] Implement `get_order_summary()`
-- [ ] Implement `is_empty()`
-- [ ] Test each method individually
-
-### Phase 5: Persistence
-- [ ] Implement `_append_to_log()`
-- [ ] Wire logging into all command methods
-- [ ] Test incremental log format (JSONL)
-- [ ] Test final JSON generation
-- [ ] Verify log events are correct
-
-### Phase 6: Testing
-- [ ] Create `tests/test_order_state.py`
-- [ ] Write construction tests (3 tests)
-- [ ] Write add item tests (6 tests)
-- [ ] Write remove/update tests (5 tests)
-- [ ] Write query tests (5 tests)
-- [ ] Write complete order tests (3 tests)
-- [ ] Write clear order tests (2 tests)
-- [ ] Write incremental log tests (2 tests)
-- [ ] Write edge case tests (3 tests)
-- [ ] Run tests: `uv run pytest tests/test_order_state.py -v`
-
-### Phase 7: Code Quality
-- [ ] Add type hints to all methods
-- [ ] Add docstrings to all public methods
-- [ ] Run formatter: `uv run ruff format src/order_state_manager.py`
-- [ ] Run linter: `uv run ruff check src/order_state_manager.py`
-- [ ] Check coverage: `uv run pytest --cov=src.order_state_manager`
-- [ ] Aim for 95%+ coverage
-
-### Phase 8: Integration Prep
-- [ ] Test with realistic session flows
-- [ ] Verify incremental log is useful for debugging
-- [ ] Verify final JSON has all required fields
-- [ ] Document file formats
-- [ ] Commit changes
-
----
-
-## Success Criteria
-
-âœ… **All unit tests pass** (30+ tests)
-âœ… **Fast in-memory tests** (<1 second for non-I/O tests)
-âœ… **File I/O works correctly** (incremental log + final JSON)
-âœ… **Returns copies, not references** (encapsulation)
-âœ… **Single source of truth** (all state in one place)
-âœ… **Type hints complete** (passes mypy --strict)
-âœ… **Docstrings complete** (all public methods documented)
-âœ… **95%+ code coverage**
-
----
-
-## Dependencies for Next Plans
-
-**This plan provides**:
-- âœ… `OrderStateManager` class for state management
-- âœ… `OrderItem` dataclass for representing order items
-- âœ… Command methods: `add_item()`, `remove_item()`, `update_item_quantity()`, `complete_order()`
-- âœ… Query methods: `get_items()`, `get_total_count()`, `get_order_summary()`
-- âœ… Persistence: incremental log + final JSON
-
-**Next plans can now use**:
-- OrderStateManager for storing order state
-- Command methods for tools to mutate state
-- Query methods for reading current order
-- Session directory structure for file output
-
----
-
-## Design Notes
-
-### Why Single Source of Truth?
-
-Having all state in OrderStateManager prevents:
-- **Inconsistency**: No risk of state being out of sync across components
-- **Debugging nightmares**: Always know where to look for state
-- **Testing complexity**: Only one component to mock/verify
-
-### Why Command/Query Separation?
-
-Commands (add, remove, update) mutate state and have side effects.
-Queries (get_items, get_total_count) are read-only and have no side effects.
-
-This makes the API clear: "Is this going to change something?"
-
-### Why Incremental Logging?
-
-Provides a complete audit trail of the conversation:
-- Debug failures: "What did the agent do?"
-- Analyze patterns: "What errors are common?"
-- Replay sessions: "Re-create the conversation"
-
-### Why Return Copies?
-
-Prevents external code from mutating internal state:
-```python
-items = order_manager.get_items()
-items[0].quantity = 999  # Doesn't affect internal state
-```
-
-Trade-off: Small performance cost for big safety win.
-
----
-
-## Example Usage
-
-```python
-# Create manager for a session
-order_manager = OrderStateManager(
-    session_id="550e8400-e29b-41d4-a716-446655440000",
-    output_dir="orders"
-)
-
-# Add items
-item1 = order_manager.add_item("Big Mac", "Beef & Pork", quantity=2)
-item2 = order_manager.add_item("Fries", "Snacks & Sides", modifiers=["No Salt"])
-
-# Query state
-print(order_manager.get_order_summary())  # "2 Big Mac, 1 Fries"
-print(order_manager.get_total_count())     # 3
-
-# Modify order
-order_manager.remove_item(item2.item_id)
-
-# Complete
-final_order = order_manager.complete_order()
-# Writes: orders/550e8400.../final_order.json
-```
-
-**Key Principle**: OrderStateManager owns ALL order state. Other components ask it to make changes; they never manipulate state directly.
diff --git a/plan/thoughts/drive-thru-llm/04-order-tools.md b/plan/thoughts/drive-thru-llm/04-order-tools.md
deleted file mode 100644
index 7113790..0000000
--- a/plan/thoughts/drive-thru-llm/04-order-tools.md
+++ /dev/null
@@ -1,619 +0,0 @@
-# Plan 04: OrderTools (LLM Tool Definitions)
-
-**Created**: 2026-01-21
-**Status**: Ready for Implementation
-**Dependencies**: Plans 01-03 (OrderStateManager, MenuProvider, menu_validation)
-**Estimated Complexity**: Medium
-
----
-
-## Overview
-
-`OrderTools` is the **coordination layer** between the LLM and our order taking system. It defines LiveKit Tools that the LLM can call via function calling, orchestrating validation â†’ state mutation flow.
-
-**Key Principles**:
-- ðŸŽ¯ **Thin Coordination Layer**: Tools coordinate, don't implement logic
-- âœ… **Validate Before Mutate**: Always validate using menu_validation before calling OrderStateManager
-- ðŸ“ž **Function Calling Interface**: Structured schemas for LLM to call
-- ðŸ”„ **Dependency Injection**: Receives OrderStateManager and MenuProvider
-
----
-
-## Component Design
-
-### File Structure
-
-**File**: `src/tools/order_tools.py` (new)
-
-**Dependencies**:
-- `src/order_state_manager.py` (OrderStateManager)
-- `src/menu_provider.py` (MenuProvider)
-- `src/menu_validation.py` (validation functions)
-- `livekit.plugins.openai` (Tool, FunctionContext)
-
----
-
-## Tools to Implement
-
-### Tool 1: `add_item_to_order`
-
-**Purpose**: Add a menu item to the customer's order
-
-**Schema**:
-```python
-{
-    "type": "function",
-    "function": {
-        "name": "add_item_to_order",
-        "description": "Add a menu item to the customer's order. Always validate the item exists on the menu before adding.",
-        "parameters": {
-            "type": "object",
-            "properties": {
-                "category": {
-                    "type": "string",
-                    "description": "The menu category (e.g., 'Beef & Pork', 'Breakfast', 'Beverages')",
-                    "enum": [
-                        "Breakfast",
-                        "Beef & Pork",
-                        "Chicken & Fish",
-                        "Salads",
-                        "Snacks & Sides",
-                        "Desserts",
-                        "Beverages",
-                        "Coffee & Tea",
-                        "Smoothies & Shakes"
-                    ]
-                },
-                "item_name": {
-                    "type": "string",
-                    "description": "The exact name of the menu item (e.g., 'Big Mac', 'Egg McMuffin')"
-                },
-                "modifiers": {
-                    "type": "array",
-                    "items": {"type": "string"},
-                    "description": "List of modifiers or customizations (e.g., ['No Pickles', 'Extra Sauce'])",
-                    "default": []
-                },
-                "quantity": {
-                    "type": "integer",
-                    "description": "Number of this item to add",
-                    "default": 1,
-                    "minimum": 1
-                }
-            },
-            "required": ["category", "item_name"]
-        }
-    }
-}
-```
-
-**Implementation Flow**:
-```python
-async def add_item_to_order(
-    ctx: FunctionContext,
-    category: str,
-    item_name: str,
-    modifiers: list[str] | None = None,
-    quantity: int = 1
-) -> str:
-    """Add item to order with validation."""
-
-    # 1. Validate item exists and modifiers are valid
-    validation_result = validate_order_item(
-        item_name=item_name,
-        category=category,
-        modifiers=modifiers or [],
-        menu_provider=menu_provider,
-        fuzzy_threshold=85
-    )
-
-    # 2. If invalid, return error message
-    if not validation_result.is_valid:
-        return f"Sorry, I couldn't add that item: {validation_result.error_message}"
-
-    # 3. If valid, use matched item (might be fuzzy matched)
-    matched_item = validation_result.matched_item
-    order_state_manager.add_item(
-        item_name=matched_item.item_name,  # Use exact match
-        category=category,
-        modifiers=modifiers or [],
-        quantity=quantity
-    )
-
-    # 4. Return confirmation
-    modifier_text = ""
-    if modifiers:
-        modifier_text = f" with {', '.join(modifiers)}"
-
-    if quantity > 1:
-        return f"Added {quantity} {matched_item.item_name}{modifier_text} to your order."
-    else:
-        return f"Added one {matched_item.item_name}{modifier_text} to your order."
-```
-
----
-
-### Tool 2: `complete_order`
-
-**Purpose**: Finalize the order and generate output files
-
-**Schema**:
-```python
-{
-    "type": "function",
-    "function": {
-        "name": "complete_order",
-        "description": "Complete the order and generate the final order summary. Call this when the customer says they're done ordering.",
-        "parameters": {
-            "type": "object",
-            "properties": {},
-            "required": []
-        }
-    }
-}
-```
-
-**Implementation Flow**:
-```python
-async def complete_order(ctx: FunctionContext) -> str:
-    """Complete the order."""
-
-    # 1. Check if order is empty
-    if order_state_manager.is_empty():
-        return "Your order is empty. Would you like to add something?"
-
-    # 2. Complete order (writes final JSON)
-    final_order = order_state_manager.complete_order()
-
-    # 3. Return summary
-    summary = final_order["order_summary"]
-    total_items = final_order["total_items"]
-
-    return f"Order complete! You ordered: {summary}. Total items: {total_items}. Thank you!"
-```
-
----
-
-### Tool 3: `remove_item_from_order` (Optional)
-
-**Purpose**: Remove an item from the order
-
-**Schema**:
-```python
-{
-    "type": "function",
-    "function": {
-        "name": "remove_item_from_order",
-        "description": "Remove an item from the order. Useful when customer wants to cancel an item.",
-        "parameters": {
-            "type": "object",
-            "properties": {
-                "item_name": {
-                    "type": "string",
-                    "description": "Name of the item to remove (e.g., 'Big Mac')"
-                }
-            },
-            "required": ["item_name"]
-        }
-    }
-}
-```
-
-**Implementation**:
-```python
-async def remove_item_from_order(ctx: FunctionContext, item_name: str) -> str:
-    """Remove item from order."""
-
-    # Find item by name (use latest item with that name)
-    items = order_state_manager.get_items()
-    item_to_remove = None
-
-    for item in reversed(items):  # Start from end (most recent)
-        if item.item_name.lower() == item_name.lower():
-            item_to_remove = item
-            break
-
-    if item_to_remove is None:
-        return f"I don't see '{item_name}' in your order."
-
-    # Remove item
-    success = order_state_manager.remove_item(item_to_remove.item_id)
-
-    if success:
-        return f"Removed {item_name} from your order."
-    else:
-        return f"Couldn't remove {item_name}. Please try again."
-```
-
----
-
-## Factory Function
-
-**Purpose**: Create all tools with dependencies injected
-
-```python
-from livekit.plugins.openai import Tool
-
-def create_order_tools(
-    order_state: OrderStateManager,
-    menu_provider: MenuProvider,
-) -> list[Tool]:
-    """
-    Create LiveKit Tool instances with dependencies injected.
-
-    Args:
-        order_state: OrderStateManager instance for this session
-        menu_provider: MenuProvider instance (shared singleton)
-
-    Returns:
-        List of Tool objects that can be registered with an Agent
-
-    Example:
-        tools = create_order_tools(order_state_manager, menu_provider)
-        agent = Agent(tools=tools, ...)
-    """
-
-    # Closure to capture dependencies
-    async def _add_item_to_order(
-        ctx: FunctionContext,
-        category: str,
-        item_name: str,
-        modifiers: list[str] | None = None,
-        quantity: int = 1
-    ) -> str:
-        # Implementation here (access order_state and menu_provider from closure)
-        ...
-
-    async def _complete_order(ctx: FunctionContext) -> str:
-        # Implementation here
-        ...
-
-    async def _remove_item_from_order(ctx: FunctionContext, item_name: str) -> str:
-        # Implementation here
-        ...
-
-    # Create Tool instances
-    return [
-        Tool(
-            name="add_item_to_order",
-            description="Add a menu item to the customer's order",
-            function=_add_item_to_order,
-            # Schema defined separately or inferred from function signature
-        ),
-        Tool(
-            name="complete_order",
-            description="Complete the order",
-            function=_complete_order,
-        ),
-        Tool(
-            name="remove_item_from_order",
-            description="Remove an item from the order",
-            function=_remove_item_from_order,
-        ),
-    ]
-```
-
----
-
-## Testing Strategy
-
-### Integration Tests
-
-**File**: `tests/test_order_tools.py` (new)
-
-**Test Setup**:
-```python
-import pytest
-from unittest.mock import Mock, AsyncMock
-from livekit.plugins.openai import FunctionContext
-
-@pytest.fixture
-def menu_provider():
-    """Real MenuProvider with test menu."""
-    return MenuProvider("menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json")
-
-@pytest.fixture
-def order_state_manager(tmp_path):
-    """OrderStateManager with temp directory."""
-    return OrderStateManager(
-        session_id="test-session",
-        output_dir=str(tmp_path / "orders")
-    )
-
-@pytest.fixture
-def order_tools(order_state_manager, menu_provider):
-    """Create tools with real dependencies."""
-    return create_order_tools(order_state_manager, menu_provider)
-
-@pytest.fixture
-def mock_ctx():
-    """Mock FunctionContext."""
-    return Mock(spec=FunctionContext)
-```
-
-**Test Cases** (aim for 20+ tests):
-
-#### `add_item_to_order` Tests
-
-1. **Valid item addition**
-```python
-@pytest.mark.asyncio
-async def test_add_item_valid_item(order_tools, order_state_manager, mock_ctx):
-    """Adding a valid item succeeds."""
-    add_item_tool = order_tools[0]  # add_item_to_order
-
-    result = await add_item_tool.function(
-        mock_ctx,
-        category="Beef & Pork",
-        item_name="Big Mac",
-        quantity=1
-    )
-
-    # Check response
-    assert "Added one Big Mac" in result
-
-    # Check state was updated
-    items = order_state_manager.get_items()
-    assert len(items) == 1
-    assert items[0].item_name == "Big Mac"
-```
-
-2. **Valid item with modifiers**
-3. **Valid item with quantity > 1**
-4. **Fuzzy match success** (e.g., "Big Mack" â†’ "Big Mac")
-5. **Invalid item** (e.g., "Whopper")
-6. **Invalid modifier**
-7. **Wrong category**
-8. **Case insensitive item name**
-
-#### `complete_order` Tests
-
-9. **Complete order with items**
-```python
-@pytest.mark.asyncio
-async def test_complete_order_success(order_tools, order_state_manager, mock_ctx):
-    """Completing order with items succeeds."""
-    add_item_tool = order_tools[0]
-    complete_tool = order_tools[1]
-
-    # Add items
-    await add_item_tool.function(mock_ctx, "Beef & Pork", "Big Mac")
-    await add_item_tool.function(mock_ctx, "Snacks & Sides", "Medium Fries")
-
-    # Complete
-    result = await complete_tool.function(mock_ctx)
-
-    assert "Order complete" in result
-    assert "Big Mac" in result
-    assert "Medium Fries" in result
-```
-
-10. **Complete empty order**
-11. **Verify final JSON is created**
-
-#### `remove_item_from_order` Tests
-
-12. **Remove existing item**
-13. **Remove non-existent item**
-14. **Remove from empty order**
-15. **Remove specific item when duplicates exist**
-
-#### Edge Cases
-
-16. **Add item with empty modifiers list**
-17. **Add item with quantity = 0** (should fail validation)
-18. **Add item with very long name**
-19. **Concurrent tool calls** (if applicable)
-
-#### Validation Integration
-
-20. **Validation errors are handled gracefully**
-```python
-@pytest.mark.asyncio
-async def test_validation_error_doesnt_mutate_state(order_tools, order_state_manager, mock_ctx):
-    """Failed validation doesn't mutate order state."""
-    add_item_tool = order_tools[0]
-
-    # Try to add invalid item
-    result = await add_item_tool.function(
-        mock_ctx,
-        category="Beef & Pork",
-        item_name="Whopper"  # Invalid
-    )
-
-    # Check error message returned
-    assert "couldn't add" in result.lower() or "not available" in result.lower()
-
-    # Verify state is unchanged
-    assert order_state_manager.is_empty()
-```
-
----
-
-## BDD Scenarios
-
-OrderTools directly supports these BDD scenarios:
-
-**Related BDD Scenarios**:
-- **Scenario 1.1** (Order Big Mac) - uses `add_item_to_order` tool
-- **Scenario 1.2** (Multiple quantities) - uses `quantity` parameter
-- **Scenario 2.1** (Multiple items) - calls `add_item_to_order` multiple times
-- **Scenario 3.1** (With modifiers) - uses `modifiers` parameter
-- **Scenario 4.1** (Corrections) - uses `remove_item_from_order`
-- **Scenario 5.1** (Invalid item) - validation fails, error returned
-- **Scenario 6.1** (Complete order) - uses `complete_order` tool
-
-**BDD Step Verification**:
-```python
-@then("the agent calls the add_item_to_order function")
-def step_impl(context):
-    # Verify function call was made
-    result.expect.next_event().is_function_call(
-        function_name="add_item_to_order",
-        arguments={
-            "category": "Beef & Pork",
-            "item_name": "Big Mac",
-            "quantity": 1,
-            "modifiers": []
-        }
-    )
-```
-
----
-
-## Implementation Checklist
-
-### Phase 1: Tool Implementation
-- [ ] Create `src/tools/` directory
-- [ ] Create `src/tools/__init__.py`
-- [ ] Create `src/tools/order_tools.py`
-- [ ] Define tool schemas (JSON schema or function signatures)
-- [ ] Implement `_add_item_to_order()` function
-- [ ] Implement `_complete_order()` function
-- [ ] Implement `_remove_item_from_order()` function (optional)
-
-### Phase 2: Factory Function
-- [ ] Implement `create_order_tools()` factory
-- [ ] Use closure to inject dependencies
-- [ ] Return list of Tool instances
-- [ ] Add type hints and docstrings
-
-### Phase 3: Validation Integration
-- [ ] Import validation functions from `menu_validation.py`
-- [ ] Call `validate_order_item()` in `_add_item_to_order()`
-- [ ] Handle validation errors gracefully
-- [ ] Return helpful error messages to LLM
-
-### Phase 4: Testing
-- [ ] Create `tests/test_order_tools.py`
-- [ ] Write fixtures for tools, state, and menu provider
-- [ ] Write add_item tests (8 tests)
-- [ ] Write complete_order tests (3 tests)
-- [ ] Write remove_item tests (4 tests)
-- [ ] Write edge case tests (3 tests)
-- [ ] Write validation integration tests (2 tests)
-- [ ] Run tests: `uv run pytest tests/test_order_tools.py -v`
-
-### Phase 5: Code Quality
-- [ ] Add type hints to all functions
-- [ ] Add docstrings to all functions
-- [ ] Run formatter: `uv run ruff format src/tools/`
-- [ ] Run linter: `uv run ruff check src/tools/`
-- [ ] Check coverage: `uv run pytest --cov=src.tools`
-- [ ] Aim for 90%+ coverage
-
-### Phase 6: Integration
-- [ ] Test tools with mock LLM
-- [ ] Verify tool schemas are LLM-friendly
-- [ ] Test error message clarity
-- [ ] Document tool usage for agent
-- [ ] Commit changes
-
----
-
-## Success Criteria
-
-âœ… **All integration tests pass** (20+ tests)
-âœ… **Tools work with real dependencies** (OrderStateManager, MenuProvider)
-âœ… **Validation integrated correctly** (invalid items don't mutate state)
-âœ… **Error messages are helpful** (LLM can understand and relay to user)
-âœ… **Type hints complete** (passes mypy --strict)
-âœ… **Docstrings complete** (all public functions documented)
-âœ… **90%+ code coverage**
-
----
-
-## Dependencies for Next Plans
-
-**This plan provides**:
-- âœ… `create_order_tools()` factory function
-- âœ… `add_item_to_order` tool (with validation)
-- âœ… `complete_order` tool
-- âœ… `remove_item_from_order` tool (optional)
-- âœ… Coordination layer between LLM and state management
-
-**Next plans can now use**:
-- Tools in agent definition
-- Tools for E2E testing
-- Tool schemas for LLM prompting
-
----
-
-## Design Notes
-
-### Why Thin Coordination Layer?
-
-Tools should orchestrate, not implement:
-- **Validation logic** lives in `menu_validation.py` (pure functions)
-- **State mutations** live in `OrderStateManager` (state owner)
-- **Tools** just coordinate: validate â†’ mutate â†’ return result
-
-This keeps tools simple and testable.
-
-### Why Dependency Injection via Closure?
-
-Using closure to capture dependencies:
-```python
-def create_order_tools(order_state, menu_provider):
-    async def _add_item(...):
-        # Can access order_state and menu_provider
-        ...
-    return [Tool(function=_add_item, ...)]
-```
-
-Benefits:
-- Tools have access to dependencies
-- Dependencies can be different per session
-- Easy to test with mocks or real instances
-
-### Why Validate Before Mutate?
-
-**Never mutate state unless validation passes.**
-
-This prevents:
-- Invalid items in order
-- Corrupted state from bad inputs
-- Need for rollback logic
-
-Validation is cheap; state corruption is expensive.
-
-### Why Return String Responses?
-
-Tools return strings that the LLM can use to formulate responses:
-- "Added one Big Mac to your order."
-- "Sorry, I couldn't add that item: Whopper is not on the menu."
-
-This gives LLM context to generate natural responses while maintaining structure.
-
----
-
-## Example Usage
-
-```python
-# Create tools for a session
-order_state = OrderStateManager(session_id="abc-123")
-menu_provider = MenuProvider("menus/mcdonalds/menu.json")
-
-tools = create_order_tools(order_state, menu_provider)
-
-# Agent uses tools
-agent = Agent(
-    instructions="You are a drive-thru order taker...",
-    tools=tools,
-    ...
-)
-
-# LLM calls tool
-result = await add_item_to_order_tool(
-    ctx=...,
-    category="Beef & Pork",
-    item_name="Big Mac",
-    quantity=2
-)
-# Returns: "Added 2 Big Mac to your order."
-
-# State is updated
-assert order_state.get_total_count() == 2
-```
-
-**Key Principle**: Tools are the bridge between unstructured LLM output and structured system operations. They validate, coordinate, and provide feedback.
diff --git a/plan/thoughts/drive-thru-llm/05-drive-thru-llm.md b/plan/thoughts/drive-thru-llm/05-drive-thru-llm.md
deleted file mode 100644
index 7c3aab7..0000000
--- a/plan/thoughts/drive-thru-llm/05-drive-thru-llm.md
+++ /dev/null
@@ -1,551 +0,0 @@
-# Plan 05: DriveThruLLM (Context Injection Wrapper)
-
-**Created**: 2026-01-21
-**Status**: Ready for Implementation
-**Dependencies**: Plan 02 (MenuProvider)
-**Estimated Complexity**: Medium
-
----
-
-## Overview
-
-`DriveThruLLM` is a **stateless LLM wrapper** that intercepts chat calls to inject relevant menu context. This implements **Strategy 2: Menu Context Injection** from the main plan, helping ground the LLM in actual menu items and reducing hallucination.
-
-**Key Principles**:
-- ðŸŽ¯ **Stateless Wrapper**: No state stored, just intercepts and delegates
-- ðŸ“ **Context Injection**: Dynamically adds menu items to chat context
-- ðŸ”„ **Delegation**: Wraps another LLM, delegates actual inference
-- âš¡ **Keyword-Based**: Extracts keywords from user input to find relevant items
-
----
-
-## Component Design
-
-### File Structure
-
-**File**: `src/drive_thru_llm.py` (new)
-
-**Dependencies**:
-- `livekit.agents.llm` (LLM, ChatContext, ChatMessage, LLMStream)
-- `src/menu_provider.py` (MenuProvider)
-
-**Pattern**: Similar to `KeywordInterceptLLM` from LiveKit examples
-
----
-
-## Interface Contract
-
-```python
-from livekit.agents.llm import LLM, ChatContext, LLMStream
-
-class DriveThruLLM(LLM):
-    """Stateless LLM wrapper that injects menu context.
-
-    Intercepts chat() calls to:
-    1. Extract keywords from latest user message
-    2. Query MenuProvider for relevant menu items
-    3. Inject items into chat context
-    4. Delegate to wrapped LLM
-
-    This helps ground the LLM in actual menu items and reduces hallucination.
-    """
-
-    def __init__(
-        self,
-        wrapped_llm: LLM,
-        menu_provider: MenuProvider,
-        max_context_items: int = 50
-    ) -> None:
-        """
-        Initialize wrapper.
-
-        Args:
-            wrapped_llm: The LLM to wrap (e.g., OpenAI GPT-4.1)
-            menu_provider: MenuProvider for menu queries
-            max_context_items: Max number of menu items to inject
-        """
-
-    def chat(
-        self,
-        *,
-        chat_ctx: ChatContext,
-        tools: list[Tool] | None = None,
-        **kwargs
-    ) -> LLMStream:
-        """
-        Intercept chat to inject menu context.
-
-        Flow:
-        1. Extract keywords from latest user message
-        2. Search for relevant menu items
-        3. Inject items into chat_ctx
-        4. Delegate to wrapped_llm.chat()
-
-        Returns:
-            LLMStream from wrapped LLM
-        """
-```
-
----
-
-## Implementation Details
-
-### 1. Constructor
-
-```python
-def __init__(
-    self,
-    wrapped_llm: LLM,
-    menu_provider: MenuProvider,
-    max_context_items: int = 50
-) -> None:
-    """Initialize wrapper."""
-    super().__init__()  # Initialize LLM base class
-    self._wrapped_llm = wrapped_llm
-    self._menu_provider = menu_provider
-    self._max_context_items = max_context_items
-```
-
-### 2. Chat Method
-
-```python
-def chat(
-    self,
-    *,
-    chat_ctx: ChatContext,
-    tools: list[Tool] | None = None,
-    **kwargs
-) -> LLMStream:
-    """Intercept chat to inject menu context."""
-
-    # 1. Extract keywords from latest user message
-    latest_message = self._get_latest_user_message(chat_ctx)
-    if latest_message:
-        keywords = self._extract_keywords(latest_message)
-
-        # 2. Search for relevant menu items
-        relevant_items = self._find_relevant_items(keywords)
-
-        # 3. Inject into context
-        if relevant_items:
-            augmented_ctx = self._inject_menu_context(chat_ctx, relevant_items)
-        else:
-            augmented_ctx = chat_ctx
-    else:
-        augmented_ctx = chat_ctx
-
-    # 4. Delegate to wrapped LLM
-    return self._wrapped_llm.chat(
-        chat_ctx=augmented_ctx,
-        tools=tools,
-        **kwargs
-    )
-```
-
-### 3. Helper Methods
-
-#### Extract Keywords
-
-```python
-def _extract_keywords(self, message: str) -> list[str]:
-    """
-    Extract potential menu-related keywords from user message.
-
-    Simple approach: Split on spaces, filter stopwords, lowercase.
-
-    Args:
-        message: User's message text
-
-    Returns:
-        List of keywords to search
-
-    Examples:
-        "I want a Big Mac" â†’ ["big", "mac"]
-        "Two cheeseburgers please" â†’ ["two", "cheeseburgers", "please"]
-    """
-    # Lowercase and split
-    words = message.lower().split()
-
-    # Remove common stopwords
-    stopwords = {"i", "want", "a", "an", "the", "please", "thanks", "and", "with"}
-    keywords = [w for w in words if w not in stopwords]
-
-    return keywords
-```
-
-#### Find Relevant Items
-
-```python
-def _find_relevant_items(self, keywords: list[str]) -> list[Item]:
-    """
-    Find menu items matching keywords.
-
-    Args:
-        keywords: List of keywords to search
-
-    Returns:
-        List of relevant menu items (up to max_context_items)
-
-    Strategy:
-        - Search for each keyword
-        - Deduplicate results
-        - Limit to max_context_items
-    """
-    all_matches = []
-    seen_items = set()
-
-    for keyword in keywords:
-        matches = self._menu_provider.search_items(keyword)
-        for item in matches:
-            if item.item_name not in seen_items:
-                all_matches.append(item)
-                seen_items.add(item.item_name)
-
-            if len(all_matches) >= self._max_context_items:
-                break
-
-        if len(all_matches) >= self._max_context_items:
-            break
-
-    return all_matches
-```
-
-#### Inject Context
-
-```python
-def _inject_menu_context(
-    self,
-    chat_ctx: ChatContext,
-    items: list[Item]
-) -> ChatContext:
-    """
-    Inject menu items into chat context.
-
-    Strategy: Add a system message with relevant menu items.
-
-    Args:
-        chat_ctx: Original chat context
-        items: Relevant menu items to inject
-
-    Returns:
-        New ChatContext with injected menu items
-    """
-    # Format items for injection
-    items_text = self._format_items_for_context(items)
-
-    # Create system message with menu context
-    menu_message = ChatMessage(
-        role="system",
-        content=f"Relevant menu items:\n{items_text}"
-    )
-
-    # Create new context with injected message
-    # (Insert after system prompt but before conversation)
-    new_messages = [chat_ctx.messages[0], menu_message] + chat_ctx.messages[1:]
-
-    return ChatContext(messages=new_messages)
-```
-
-#### Format Items
-
-```python
-def _format_items_for_context(self, items: list[Item]) -> str:
-    """
-    Format menu items for LLM context.
-
-    Args:
-        items: List of menu items
-
-    Returns:
-        Formatted string of items
-
-    Example:
-        "- Big Mac (Beef & Pork)
-         - Quarter Pounder (Beef & Pork)
-         - Egg McMuffin (Breakfast)"
-    """
-    lines = []
-    for item in items:
-        # Group by category for clarity
-        lines.append(f"- {item.item_name} ({item.category})")
-
-        # Optionally include modifiers
-        if item.modifiers:
-            modifier_names = [m.modifier_name for m in item.modifiers]
-            lines.append(f"  Modifiers: {', '.join(modifier_names)}")
-
-    return "\n".join(lines)
-```
-
----
-
-## Testing Strategy
-
-### Unit Tests
-
-**File**: `tests/test_drive_thru_llm.py` (new)
-
-**Test Strategy**: Mock wrapped LLM, real MenuProvider
-
-```python
-import pytest
-from unittest.mock import Mock, AsyncMock
-from livekit.agents.llm import ChatContext, ChatMessage, LLMStream
-
-@pytest.fixture
-def menu_provider():
-    """Real MenuProvider."""
-    return MenuProvider("menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json")
-
-@pytest.fixture
-def mock_wrapped_llm():
-    """Mock the wrapped LLM."""
-    llm = Mock(spec=LLM)
-    llm.chat = AsyncMock(return_value=Mock(spec=LLMStream))
-    return llm
-
-@pytest.fixture
-def drive_thru_llm(mock_wrapped_llm, menu_provider):
-    """Create DriveThruLLM with mock."""
-    return DriveThruLLM(
-        wrapped_llm=mock_wrapped_llm,
-        menu_provider=menu_provider,
-        max_context_items=20
-    )
-```
-
-**Test Cases** (aim for 15+ tests):
-
-#### Keyword Extraction Tests
-
-1. `test_extract_keywords_simple()` - "I want a Big Mac" â†’ ["big", "mac"]
-2. `test_extract_keywords_removes_stopwords()`
-3. `test_extract_keywords_lowercase()`
-4. `test_extract_keywords_empty_message()`
-
-#### Menu Search Tests
-
-5. `test_find_relevant_items_single_keyword()` - "mac" finds Big Mac, Egg McMuffin
-6. `test_find_relevant_items_multiple_keywords()` - "big mac" is more specific
-7. `test_find_relevant_items_no_matches()`
-8. `test_find_relevant_items_respects_max_limit()`
-
-#### Context Injection Tests
-
-9. `test_chat_injects_menu_context()`
-```python
-@pytest.mark.asyncio
-async def test_chat_injects_menu_context(drive_thru_llm, mock_wrapped_llm):
-    """Verify menu context is injected into chat."""
-    # Create chat context with user message
-    chat_ctx = ChatContext(messages=[
-        ChatMessage(role="system", content="You are a drive-thru agent"),
-        ChatMessage(role="user", content="I want a Big Mac")
-    ])
-
-    # Call chat
-    await drive_thru_llm.chat(chat_ctx=chat_ctx)
-
-    # Verify wrapped LLM was called
-    mock_wrapped_llm.chat.assert_called_once()
-
-    # Get the augmented context passed to wrapped LLM
-    call_args = mock_wrapped_llm.chat.call_args
-    augmented_ctx = call_args.kwargs["chat_ctx"]
-
-    # Verify menu context was injected
-    assert len(augmented_ctx.messages) > len(chat_ctx.messages)
-
-    # Check that menu items were included
-    menu_message = augmented_ctx.messages[1]
-    assert "Big Mac" in menu_message.content
-    assert "Beef & Pork" in menu_message.content
-```
-
-10. `test_chat_delegates_to_wrapped_llm()`
-11. `test_chat_preserves_tools_parameter()`
-12. `test_chat_no_context_injection_if_no_keywords()`
-
-#### Integration Tests
-
-13. `test_full_flow_with_real_menu()`
-14. `test_handles_empty_user_message()`
-15. `test_stateless_multiple_calls()`
-```python
-@pytest.mark.asyncio
-async def test_stateless_multiple_calls(drive_thru_llm, mock_wrapped_llm):
-    """Verify wrapper is stateless - multiple calls don't interfere."""
-    ctx1 = ChatContext(messages=[
-        ChatMessage(role="system", content="System"),
-        ChatMessage(role="user", content="I want a Big Mac")
-    ])
-
-    ctx2 = ChatContext(messages=[
-        ChatMessage(role="system", content="System"),
-        ChatMessage(role="user", content="I want fries")
-    ])
-
-    # Make two calls
-    await drive_thru_llm.chat(chat_ctx=ctx1)
-    await drive_thru_llm.chat(chat_ctx=ctx2)
-
-    # Both should work independently (no shared state)
-    assert mock_wrapped_llm.chat.call_count == 2
-```
-
----
-
-## BDD Scenarios
-
-DriveThruLLM supports all scenarios by providing menu context:
-
-**Related BDD Scenarios**:
-- **All scenarios** benefit from menu context injection
-- **Scenario 1.1** (Order Big Mac) - "Big Mac" triggers injection of Beef & Pork items
-- **Scenario 5.2** (Ambiguous request) - "burger" triggers all burger items
-- **Scenario 5.4** (STT error recovery) - Context helps LLM understand "Big Mack"
-
----
-
-## Implementation Checklist
-
-### Phase 1: Basic Structure
-- [ ] Create `src/drive_thru_llm.py`
-- [ ] Define `DriveThruLLM` class extending `LLM`
-- [ ] Implement `__init__()` with dependency injection
-- [ ] Add type hints and docstrings
-
-### Phase 2: Helper Methods
-- [ ] Implement `_extract_keywords()`
-- [ ] Implement `_find_relevant_items()`
-- [ ] Implement `_format_items_for_context()`
-- [ ] Implement `_inject_menu_context()`
-- [ ] Test each method individually
-
-### Phase 3: Chat Method
-- [ ] Implement `chat()` method
-- [ ] Wire together keyword extraction â†’ search â†’ injection â†’ delegation
-- [ ] Handle edge cases (no keywords, no matches, empty messages)
-
-### Phase 4: Testing
-- [ ] Create `tests/test_drive_thru_llm.py`
-- [ ] Write keyword extraction tests (4 tests)
-- [ ] Write menu search tests (4 tests)
-- [ ] Write context injection tests (4 tests)
-- [ ] Write integration tests (3 tests)
-- [ ] Run tests: `uv run pytest tests/test_drive_thru_llm.py -v`
-
-### Phase 5: Optimization
-- [ ] Consider caching frequent searches (optional)
-- [ ] Optimize keyword extraction (use NLP library if needed)
-- [ ] Tune max_context_items parameter
-- [ ] Measure token usage impact
-
-### Phase 6: Code Quality
-- [ ] Add type hints to all methods
-- [ ] Add docstrings to all methods
-- [ ] Run formatter: `uv run ruff format src/drive_thru_llm.py`
-- [ ] Run linter: `uv run ruff check src/drive_thru_llm.py`
-- [ ] Check coverage: `uv run pytest --cov=src.drive_thru_llm`
-
----
-
-## Success Criteria
-
-âœ… **All unit tests pass** (15+ tests)
-âœ… **Wrapper is stateless** (no instance variables except config)
-âœ… **Context injection works** (menu items appear in augmented context)
-âœ… **Delegates correctly** (wrapped LLM is called with augmented context)
-âœ… **Type hints complete** (passes mypy --strict)
-âœ… **Docstrings complete** (all public methods documented)
-âœ… **90%+ code coverage**
-
----
-
-## Dependencies for Next Plans
-
-**This plan provides**:
-- âœ… `DriveThruLLM` wrapper class
-- âœ… Menu context injection (Strategy 2)
-- âœ… Stateless LLM wrapper pattern
-- âœ… Keyword-based search for relevant items
-
-**Next plans can now use**:
-- DriveThruLLM in agent definition
-- Wrapped LLM for improved accuracy
-
----
-
-## Design Notes
-
-### Why Stateless?
-
-Stateless wrapper means:
-- No instance state to corrupt
-- Thread-safe (could be shared, though not needed)
-- Predictable behavior
-- Easy to test
-
-### Why Keyword Extraction?
-
-Simple keyword extraction is:
-- Fast (no extra API calls)
-- Good enough for this use case
-- Easily understood and debugged
-
-Could upgrade to NLP later if needed.
-
-### Why System Message for Injection?
-
-Injecting as system message:
-- Clearly separates menu context from conversation
-- LLM treats it as reference material
-- Doesn't pollute conversation history
-
-Alternative: Augment existing system prompt (more complex).
-
-### Token Usage Impact
-
-Injecting 20-50 menu items adds ~500-1000 tokens per request.
-
-Trade-off:
-- **Cost**: Slightly higher (more input tokens)
-- **Benefit**: Better accuracy, less hallucination
-
-Worth it for accuracy-critical application.
-
----
-
-## Example Usage
-
-```python
-# Create wrapped LLM
-base_llm = openai.LLM(model="gpt-4.1")
-
-# Create menu provider (singleton)
-menu_provider = MenuProvider("menus/mcdonalds/menu.json")
-
-# Wrap LLM
-drive_thru_llm = DriveThruLLM(
-    wrapped_llm=base_llm,
-    menu_provider=menu_provider,
-    max_context_items=30
-)
-
-# Use in agent
-agent = Agent(
-    llm=drive_thru_llm,  # Use wrapped LLM
-    instructions="...",
-    tools=tools
-)
-```
-
-**Flow**:
-1. User: "I want a Big Mac"
-2. DriveThruLLM extracts keywords: ["big", "mac"]
-3. Searches menu: finds Big Mac, Egg McMuffin, etc.
-4. Injects context: "Relevant items: Big Mac (Beef & Pork), ..."
-5. Delegates to base LLM with augmented context
-6. LLM sees menu items and makes better decision
-
-**Key Principle**: Context injection grounds the LLM in reality (the actual menu), reducing hallucination.
diff --git a/plan/thoughts/drive-thru-llm/06-drive-thru-agent.md b/plan/thoughts/drive-thru-llm/06-drive-thru-agent.md
deleted file mode 100644
index 272204c..0000000
--- a/plan/thoughts/drive-thru-llm/06-drive-thru-agent.md
+++ /dev/null
@@ -1,426 +0,0 @@
-# Plan 06: DriveThruAgent (Agent Orchestration)
-
-**Created**: 2026-01-21
-**Status**: Ready for Implementation
-**Dependencies**: Plans 01-05 (All components)
-**Estimated Complexity**: Medium
-
----
-
-## Overview
-
-`DriveThruAgent` is the **orchestrator** that brings together all components to create the complete drive-thru order taking agent. It defines the agent's persona, registers tools, and coordinates the conversation flow.
-
-**Key Principles**:
-- ðŸŽ¯ **Orchestration**: Wires components together, doesn't implement logic
-- ðŸ“ **Owns State**: Owns OrderStateManager instance (composition)
-- ðŸ”§ **Receives Dependencies**: Gets MenuProvider, DriveThruLLM via DI
-- ðŸ’¬ **Defines Persona**: Sets instructions and conversation style
-
----
-
-## Component Design
-
-### File Structure
-
-**File**: `src/drive_thru_agent.py` (new)
-
-**Dependencies**:
-- `livekit.agents` (Agent, Session)
-- `src/order_state_manager.py` (OrderStateManager)
-- `src/menu_provider.py` (MenuProvider)
-- `src/drive_thru_llm.py` (DriveThruLLM)
-- `src/tools/order_tools.py` (create_order_tools)
-
----
-
-## Implementation
-
-### DriveThruAgent Class
-
-```python
-from livekit.agents import Agent
-from livekit.agents.llm import ChatContext, ChatMessage
-
-class DriveThruAgent:
-    """McDonald's drive-thru order taking agent.
-
-    Orchestrates:
-    - OrderStateManager (owns instance per session)
-    - Tools (created with dependencies)
-    - DriveThruLLM (wrapped LLM with context injection)
-    - Instructions/persona
-    """
-
-    def __init__(
-        self,
-        session_id: str,
-        llm: DriveThruLLM,
-        menu_provider: MenuProvider,
-        output_dir: str = "orders"
-    ) -> None:
-        """
-        Initialize drive-thru agent.
-
-        Args:
-            session_id: Unique session ID
-            llm: DriveThruLLM (wrapped LLM)
-            menu_provider: MenuProvider for menu access
-            output_dir: Directory for order files
-        """
-        # Create OrderStateManager for this session (agent owns it)
-        self._order_state = OrderStateManager(
-            session_id=session_id,
-            output_dir=output_dir
-        )
-
-        # Store dependencies
-        self._llm = llm
-        self._menu_provider = menu_provider
-        self._session_id = session_id
-
-        # Create tools with dependencies injected
-        self._tools = create_order_tools(
-            order_state=self._order_state,
-            menu_provider=self._menu_provider
-        )
-
-        # Create LiveKit Agent
-        self._agent = Agent(
-            llm=self._llm,
-            tools=self._tools,
-            instructions=self._get_instructions()
-        )
-
-    def _get_instructions(self) -> str:
-        """Get agent instructions/persona."""
-        return """You are a friendly and efficient McDonald's drive-thru order taker.
-
-Your responsibilities:
-1. Greet customers warmly when they arrive
-2. Listen carefully to their order
-3. Use the add_item_to_order function to record each item
-4. Confirm each item after adding it
-5. When customer is done, use complete_order function
-6. Read back the complete order
-7. Thank the customer
-
-Guidelines:
-- Be concise and natural - avoid overly formal language
-- If unsure about an item, ask for clarification
-- Always confirm items before adding to order
-- Use exact menu item names when confirming
-- If customer mentions an item not on the menu, politely inform them
-- Be helpful with suggestions if they seem uncertain
-
-Menu Categories:
-- Breakfast: Morning items like Egg McMuffin, Hash Browns
-- Beef & Pork: Big Mac, Quarter Pounder, burgers
-- Chicken & Fish: McNuggets, Filet-O-Fish
-- Snacks & Sides: Fries, Apple Slices
-- Beverages: Soft drinks
-- Coffee & Tea: Hot and iced coffee
-- Desserts: Apple Pie, McFlurry
-- Smoothies & Shakes
-
-Remember: You have access to the complete menu via your tools. Use them!
-"""
-
-    @property
-    def agent(self) -> Agent:
-        """Get the LiveKit Agent instance."""
-        return self._agent
-
-    @property
-    def order_state(self) -> OrderStateManager:
-        """Get the order state manager (for testing)."""
-        return self._order_state
-
-    async def close(self) -> None:
-        """Clean up resources."""
-        # Could add cleanup logic here if needed
-        pass
-```
-
----
-
-## Agent Instructions Design
-
-### Persona Elements
-
-**Tone**: Friendly, efficient, professional
-**Style**: Conversational, concise, natural
-**Behavior**: Confirming, helpful, patient
-
-### Key Instructions
-
-1. **Greeting**: "Welcome to McDonald's! What can I get for you today?"
-
-2. **Active Listening**: Process customer requests carefully
-
-3. **Tool Usage**: Always use `add_item_to_order` function for adding items
-
-4. **Confirmation**: Confirm each item: "Got it, one Big Mac"
-
-5. **Clarification**: If uncertain: "Just to clarify, did you want..."
-
-6. **Completion**: When done: "Your order is [summary]. [Total] items."
-
-7. **Error Handling**: "I'm sorry, we don't have [item]. Can I suggest [alternative]?"
-
----
-
-## Testing Strategy
-
-### Unit Tests
-
-**File**: `tests/test_drive_thru_agent.py` (new)
-
-**Test Focus**: Agent initialization and wiring
-
-```python
-import pytest
-from unittest.mock import Mock
-
-@pytest.fixture
-def menu_provider():
-    """Real menu provider."""
-    return MenuProvider("menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json")
-
-@pytest.fixture
-def mock_llm():
-    """Mock DriveThruLLM."""
-    return Mock(spec=DriveThruLLM)
-
-@pytest.fixture
-def drive_thru_agent(mock_llm, menu_provider, tmp_path):
-    """Create DriveThruAgent."""
-    return DriveThruAgent(
-        session_id="test-session",
-        llm=mock_llm,
-        menu_provider=menu_provider,
-        output_dir=str(tmp_path / "orders")
-    )
-```
-
-**Test Cases**:
-
-1. `test_agent_initialization()` - Agent creates correctly
-2. `test_agent_creates_order_state()` - OrderStateManager is created
-3. `test_agent_creates_tools()` - Tools are created and registered
-4. `test_agent_has_instructions()` - Instructions are set
-5. `test_agent_owns_order_state()` - Can access order_state property
-6. `test_agent_session_directory_created()` - Session dir exists
-
-### Integration Tests (E2E)
-
-**File**: `tests/test_drive_thru_agent_e2e.py` (new)
-
-**Test Focus**: Complete conversation flows using BDD scenarios
-
-Use LiveKit's testing framework with judge-based evaluation:
-
-```python
-@pytest.mark.asyncio
-async def test_scenario_1_1_order_big_mac() -> None:
-    """
-    BDD Scenario 1.1: Customer orders a Big Mac
-
-    Given the agent greets the customer
-    When the customer says "I'll have a Big Mac"
-    Then the agent confirms "one Big Mac"
-    And the agent asks if the customer wants anything else
-    When the customer says "that's all"
-    Then the agent reads back the complete order
-    And the order file contains 1 item
-    And the order file shows "Big Mac" in category "Beef & Pork"
-    """
-    # Create real agent
-    menu_provider = MenuProvider("menus/mcdonalds/menu.json")
-    base_llm = openai.LLM(model="gpt-4o-mini")
-    drive_thru_llm = DriveThruLLM(base_llm, menu_provider)
-    agent = DriveThruAgent("test-123", drive_thru_llm, menu_provider)
-
-    # Create judge LLM
-    judge_llm = openai.LLM(model="gpt-4o")
-
-    # Run test session
-    async with AgentSession(llm=drive_thru_llm) as session:
-        await session.start(agent.agent)
-
-        # Customer orders
-        result = await session.run(user_input="I'll have a Big Mac")
-
-        # Verify function call
-        result.expect.next_event().is_function_call(
-            function_name="add_item_to_order",
-            arguments={
-                "category": "Beef & Pork",
-                "item_name": "Big Mac",
-                "quantity": 1,
-                "modifiers": []
-            }
-        )
-
-        # Verify confirmation
-        await (
-            result.expect.next_event()
-            .is_message(role="assistant")
-            .judge(
-                judge_llm,
-                intent="Confirms one Big Mac was added and asks if customer wants anything else"
-            )
-        )
-
-        # End order
-        result = await session.run(user_input="that's all")
-
-        # Verify completion
-        result.expect.next_event().is_function_call(
-            function_name="complete_order"
-        )
-
-        # Verify order file
-        final_order = agent.order_state.complete_order()
-        assert len(final_order["items"]) == 1
-        assert final_order["items"][0]["item_name"] == "Big Mac"
-        assert final_order["items"][0]["category"] == "Beef & Pork"
-```
-
----
-
-## BDD Scenarios
-
-DriveThruAgent is tested against ALL BDD scenarios from the testing strategy:
-
-**Priority 1** (Must implement):
-- Scenario 1.1: Order a Big Mac
-- Scenario 1.2: Order with quantity
-- Scenario 2.1: Multiple items sequentially
-- Scenario 3.1: Item with modifier
-- Scenario 5.1: Invalid menu item
-- Scenario 5.2: Ambiguous request
-- Scenario 6.1: Complete order
-
-**Priority 2** (Should implement):
-- All remaining scenarios from bdd-testing-strategy.md
-
----
-
-## Implementation Checklist
-
-### Phase 1: Basic Structure
-- [ ] Create `src/drive_thru_agent.py`
-- [ ] Define `DriveThruAgent` class
-- [ ] Implement `__init__()` with dependency injection
-- [ ] Implement `_get_instructions()` method
-- [ ] Add properties: `agent`, `order_state`
-
-### Phase 2: Instructions
-- [ ] Write comprehensive agent instructions
-- [ ] Define persona and tone
-- [ ] Include menu category overview
-- [ ] Add tool usage guidelines
-- [ ] Add error handling guidelines
-
-### Phase 3: Wiring
-- [ ] Create OrderStateManager in constructor
-- [ ] Create tools with `create_order_tools()`
-- [ ] Create LiveKit Agent with llm, tools, instructions
-- [ ] Test that all components wire together
-
-### Phase 4: Unit Tests
-- [ ] Create `tests/test_drive_thru_agent.py`
-- [ ] Write initialization tests (6 tests)
-- [ ] Test dependency wiring
-- [ ] Run tests: `uv run pytest tests/test_drive_thru_agent.py -v`
-
-### Phase 5: E2E Tests
-- [ ] Create `tests/test_drive_thru_agent_e2e.py`
-- [ ] Implement BDD Scenario 1.1 (Big Mac order)
-- [ ] Implement BDD Scenario 1.2 (with quantity)
-- [ ] Implement BDD Scenario 2.1 (multiple items)
-- [ ] Implement BDD Scenario 5.1 (invalid item)
-- [ ] Run E2E tests: `uv run pytest tests/test_drive_thru_agent_e2e.py -v`
-
-### Phase 6: Code Quality
-- [ ] Add type hints
-- [ ] Add docstrings
-- [ ] Run formatter: `uv run ruff format src/drive_thru_agent.py`
-- [ ] Run linter: `uv run ruff check src/drive_thru_agent.py`
-
----
-
-## Success Criteria
-
-âœ… **Agent initializes correctly** with all dependencies
-âœ… **Tools are registered** and accessible to LLM
-âœ… **Instructions are clear** and comprehensive
-âœ… **E2E tests pass** for Priority 1 BDD scenarios
-âœ… **Order state is managed** correctly through full conversation
-âœ… **Type hints complete**
-âœ… **Docstrings complete**
-
----
-
-## Dependencies for Next Plans
-
-**This plan provides**:
-- âœ… Complete `DriveThruAgent` class
-- âœ… Agent orchestration and wiring
-- âœ… Comprehensive instructions/persona
-- âœ… E2E test framework
-
-**Next plan can now**:
-- Wire agent into application
-- Test full system integration
-- Deploy to production
-
----
-
-## Design Notes
-
-### Why Agent Owns OrderStateManager?
-
-Agent is responsible for the conversation session, so it owns the session state:
-- Creates OrderStateManager for its session
-- Passes it to tools
-- Can access it for testing/debugging
-
-### Why Dependency Injection?
-
-Agent receives llm and menu_provider instead of creating them:
-- Easier to test (can inject mocks)
-- Flexible (can use different LLMs)
-- Decoupled (agent doesn't know about LLM creation)
-
-### Instructions Design Philosophy
-
-Instructions are:
-- **Clear**: Unambiguous about what to do
-- **Concise**: Not overwhelming
-- **Action-oriented**: Tell agent what to do, not what to think
-- **Tool-focused**: Emphasize using functions
-
-**Example Usage**
-
-```python
-# App-level setup
-menu_provider = MenuProvider("menus/mcdonalds/menu.json")
-base_llm = openai.LLM(model="gpt-4o")
-drive_thru_llm = DriveThruLLM(base_llm, menu_provider)
-
-# Create agent for session
-agent = DriveThruAgent(
-    session_id=str(uuid.uuid4()),
-    llm=drive_thru_llm,
-    menu_provider=menu_provider,
-    output_dir="orders"
-)
-
-# Use agent in session
-async with Session() as session:
-    await session.start(agent.agent)
-```
-
-**Key Principle**: Agent is the conductor - it orchestrates all components but delegates actual work to specialized components.
diff --git a/plan/thoughts/drive-thru-llm/07-integration-and-wiring.md b/plan/thoughts/drive-thru-llm/07-integration-and-wiring.md
deleted file mode 100644
index aaa949f..0000000
--- a/plan/thoughts/drive-thru-llm/07-integration-and-wiring.md
+++ /dev/null
@@ -1,545 +0,0 @@
-# Plan 07: Integration and Application Wiring
-
-**Created**: 2026-01-21
-**Status**: Ready for Implementation
-**Dependencies**: Plans 01-06 (All components complete)
-**Estimated Complexity**: Medium-High
-
----
-
-## Overview
-
-This plan covers **app-level wiring** and **end-to-end integration**. It brings together all components into a working drive-thru agent application, adds configuration, and implements comprehensive E2E testing against all BDD scenarios.
-
-**Key Objectives**:
-- ðŸ”Œ Wire all components into the main application
-- âš™ï¸ Add configuration for drive-thru agent
-- ðŸ§ª Implement all Priority 1 & 2 BDD scenarios as E2E tests
-- ðŸš€ Enable console and dev modes for testing
-- âœ… Verify 95%+ accuracy on test suite
-
----
-
-## 1. Configuration
-
-### Add DriveThruConfig
-
-**File**: `src/config.py` (modify existing)
-
-```python
-from pydantic import BaseModel, Field
-
-class DriveThruConfig(BaseModel):
-    """Configuration for McDonald's drive-thru agent."""
-
-    # Menu configuration
-    menu_file_path: str = Field(
-        default="menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json",
-        description="Path to menu JSON file"
-    )
-
-    # Order output
-    orders_output_dir: str = Field(
-        default="orders",
-        description="Directory to save order files"
-    )
-
-    # Accuracy strategies
-    fuzzy_match_threshold: int = Field(
-        default=85,
-        description="Minimum fuzzy match score (0-100) for item names",
-        ge=0,
-        le=100
-    )
-
-    max_context_items: int = Field(
-        default=50,
-        description="Maximum number of menu items to inject into LLM context",
-        ge=10,
-        le=100
-    )
-
-    # Feature flags
-    enable_confirmation_loop: bool = Field(
-        default=True,
-        description="Require confirmation before adding items"
-    )
-
-    enable_semantic_search: bool = Field(
-        default=False,
-        description="Use embeddings for semantic item search (future)"
-    )
-
-
-class Config(BaseModel):
-    """Root configuration (extend existing)."""
-    # ... existing fields ...
-
-    # Add drive-thru config
-    drive_thru: DriveThruConfig = Field(
-        default_factory=DriveThruConfig,
-        description="Drive-thru agent configuration"
-    )
-```
-
----
-
-## 2. Application Wiring
-
-### Session Handler
-
-**File**: `src/session_handler.py` (modify or create new)
-
-```python
-from uuid import uuid4
-from livekit.agents import Session
-from src.drive_thru_agent import DriveThruAgent
-from src.drive_thru_llm import DriveThruLLM
-from src.menu_provider import MenuProvider
-from src.config import Config
-
-class DriveThruSessionHandler:
-    """Handles creation of drive-thru agent sessions."""
-
-    def __init__(self, config: Config):
-        """Initialize session handler with config."""
-        self.config = config
-
-        # Create shared MenuProvider (singleton - loaded once)
-        self.menu_provider = MenuProvider(
-            config.drive_thru.menu_file_path
-        )
-
-    async def create_agent(self, session_id: str) -> DriveThruAgent:
-        """Create a new DriveThruAgent for a session."""
-
-        # Create base LLM (from config)
-        from src.factories import create_llm
-        base_llm = create_llm(self.config)
-
-        # Wrap with DriveThruLLM
-        drive_thru_llm = DriveThruLLM(
-            wrapped_llm=base_llm,
-            menu_provider=self.menu_provider,
-            max_context_items=self.config.drive_thru.max_context_items
-        )
-
-        # Create DriveThruAgent
-        agent = DriveThruAgent(
-            session_id=session_id,
-            llm=drive_thru_llm,
-            menu_provider=self.menu_provider,
-            output_dir=self.config.drive_thru.orders_output_dir
-        )
-
-        return agent
-```
-
-### Main Application
-
-**File**: `src/agent.py` (modify existing)
-
-Add drive-thru mode option:
-
-```python
-import click
-from src.session_handler import DriveThruSessionHandler
-
-@click.group()
-def cli():
-    """McDonald's Drive-Thru Agent CLI."""
-    pass
-
-@cli.command()
-def console():
-    """Run drive-thru agent in console mode (for testing)."""
-    # Load config
-    config = load_config()
-
-    # Create session handler
-    handler = DriveThruSessionHandler(config)
-
-    # Create agent
-    session_id = str(uuid4())
-    agent = await handler.create_agent(session_id)
-
-    # Run console session
-    async with Console(agent.agent) as console:
-        await console.run()
-
-@cli.command()
-def dev():
-    """Run drive-thru agent in dev mode."""
-    # Similar to console but with LiveKit connection
-    config = load_config()
-    handler = DriveThruSessionHandler(config)
-
-    # Create app
-    app = DriveThruApp(handler, config)
-    app.run()
-
-# ... existing commands ...
-
-if __name__ == "__main__":
-    cli()
-```
-
----
-
-## 3. BDD Test Implementation
-
-### Feature Files
-
-**Directory**: `tests/features/agent/`
-
-Create actual Gherkin feature files based on `plan/bdd-testing-strategy.md`:
-
-**File**: `tests/features/agent/01_basic_ordering.feature`
-
-```gherkin
-@voice-agent @order-taking @priority-1
-Feature: Basic Single-Item Ordering
-  As a McDonald's customer
-  I want to order a single menu item
-  So that I can quickly get my food
-
-  Background:
-    Given the McDonald's menu is loaded
-    And the agent is ready to take orders
-
-  @smoke
-  Scenario: Customer orders a Big Mac
-    Given the agent greets the customer
-    When the customer says "I'll have a Big Mac"
-    Then the agent confirms "one Big Mac"
-    And the agent asks if the customer wants anything else
-    When the customer says "that's all"
-    Then the agent reads back the complete order
-    And a final order JSON file is created
-    And the order file contains 1 item
-    And the order file shows "Big Mac" in category "Beef & Pork"
-    And the item has quantity 1
-
-  @quantities
-  Scenario: Customer orders multiple Big Macs
-    Given the agent greets the customer
-    When the customer says "Two Big Macs please"
-    Then the agent confirms "two Big Macs"
-    When the customer says "no thanks"
-    Then the order file contains 1 line item
-    And the line item has quantity 2
-```
-
-**(Similar files for 02-06 features)**
-
-### Step Definitions
-
-**File**: `tests/features/steps/agent_steps.py`
-
-```python
-import pytest
-from behave import given, when, then
-from livekit.agents.testing import AgentSession
-import json
-from pathlib import Path
-
-# Setup steps
-
-@given("the McDonald's menu is loaded")
-def step_menu_loaded(context):
-    """Load menu provider."""
-    from src.menu_provider import MenuProvider
-    context.menu_provider = MenuProvider(
-        "menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json"
-    )
-
-@given("the agent is ready to take orders")
-async def step_agent_ready(context):
-    """Create and start agent."""
-    from src.drive_thru_agent import DriveThruAgent
-    from src.drive_thru_llm import DriveThruLLM
-    from livekit.plugins import openai
-
-    # Create components
-    base_llm = openai.LLM(model="gpt-4o-mini")
-    drive_thru_llm = DriveThruLLM(base_llm, context.menu_provider)
-
-    session_id = f"test-{uuid4()}"
-    agent = DriveThruAgent(
-        session_id=session_id,
-        llm=drive_thru_llm,
-        menu_provider=context.menu_provider,
-        output_dir="test_orders"
-    )
-
-    # Store for later steps
-    context.agent = agent
-    context.session_id = session_id
-
-    # Start session
-    context.session = AgentSession(llm=drive_thru_llm)
-    await context.session.start(agent.agent)
-
-@given("the agent greets the customer")
-async def step_agent_greets(context):
-    """Agent sends greeting."""
-    # Wait for initial greeting
-    result = await context.session.wait_for_message()
-    # Store result for verification if needed
-    context.last_result = result
-
-# Action steps
-
-@when('the customer says "{utterance}"')
-async def step_customer_says(context, utterance):
-    """Customer speaks."""
-    context.last_result = await context.session.run(user_input=utterance)
-
-# Verification steps
-
-@then('the agent confirms "{text}"')
-async def step_agent_confirms(context, text):
-    """Verify agent confirmed something."""
-    from livekit.plugins import openai
-    judge_llm = openai.LLM(model="gpt-4o")
-
-    await (
-        context.last_result.expect.next_event()
-        .is_message(role="assistant")
-        .judge(
-            judge_llm,
-            intent=f"Confirms {text} was added to the order"
-        )
-    )
-
-@then("the agent asks if the customer wants anything else")
-async def step_agent_asks_more(context):
-    """Verify agent asks for more items."""
-    # Use judge to verify intent
-    from livekit.plugins import openai
-    judge_llm = openai.LLM(model="gpt-4o")
-
-    await (
-        context.last_result.expect.next_event()
-        .is_message(role="assistant")
-        .judge(
-            judge_llm,
-            intent="Asks if customer wants anything else or is done ordering"
-        )
-    )
-
-@then("a final order JSON file is created")
-def step_final_json_created(context):
-    """Verify final order JSON exists."""
-    order_path = Path("test_orders") / context.session_id / "final_order.json"
-    assert order_path.exists(), f"Final order JSON not found at {order_path}"
-
-@then("the order file contains {n:d} item")
-@then("the order file contains {n:d} items")
-def step_order_contains_items(context, n):
-    """Verify number of items."""
-    order_path = Path("test_orders") / context.session_id / "final_order.json"
-    with open(order_path) as f:
-        order_data = json.load(f)
-
-    assert len(order_data["items"]) == n
-
-@then('the order file shows "{item_name}" in category "{category}"')
-def step_order_shows_item_in_category(context, item_name, category):
-    """Verify specific item in order."""
-    order_path = Path("test_orders") / context.session_id / "final_order.json"
-    with open(order_path) as f:
-        order_data = json.load(f)
-
-    # Find item
-    item = next(
-        (i for i in order_data["items"] if i["item_name"] == item_name),
-        None
-    )
-
-    assert item is not None, f"{item_name} not found in order"
-    assert item["category"] == category
-
-@then("the item has quantity {quantity:d}")
-@then("the line item has quantity {quantity:d}")
-def step_item_has_quantity(context, quantity):
-    """Verify item quantity."""
-    order_path = Path("test_orders") / context.session_id / "final_order.json"
-    with open(order_path) as f:
-        order_data = json.load(f)
-
-    # Check first item (or last added item)
-    assert order_data["items"][0]["quantity"] == quantity
-```
-
-### Test Runner
-
-**File**: `tests/test_bdd_scenarios.py`
-
-```python
-"""Run BDD scenarios using pytest-bdd."""
-import pytest
-from pytest_bdd import scenarios
-
-# Load all feature files
-scenarios('features/agent/01_basic_ordering.feature')
-scenarios('features/agent/02_multi_item_ordering.feature')
-scenarios('features/agent/03_modifiers.feature')
-scenarios('features/agent/04_order_corrections.feature')
-scenarios('features/agent/05_error_handling.feature')
-scenarios('features/agent/06_order_completion.feature')
-
-# Step definitions are auto-discovered from features/steps/
-```
-
----
-
-## 4. Testing Strategy
-
-### Test Levels
-
-1. **Unit Tests** (Plans 01-06) - Fast, isolated, comprehensive
-   - Already implemented in previous plans
-   - ~100+ tests across all components
-
-2. **Integration Tests** (Plans 04-06) - Component interactions
-   - Tools + State + Validation
-   - Agent wiring
-
-3. **E2E BDD Tests** (This plan) - Full conversation flows
-   - All Priority 1 scenarios (8 scenarios)
-   - All Priority 2 scenarios (18 total scenarios)
-
-### Running Tests
-
-```bash
-# Run all tests
-uv run pytest
-
-# Run unit tests only (fast)
-uv run pytest tests/test_*.py -v
-
-# Run BDD scenarios only
-uv run pytest tests/test_bdd_scenarios.py -v
-
-# Run specific feature
-uv run pytest tests/test_bdd_scenarios.py -k "basic_ordering"
-
-# Run with coverage
-uv run pytest --cov=src --cov-report=html
-```
-
----
-
-## Implementation Checklist
-
-### Phase 1: Configuration
-- [ ] Add `DriveThruConfig` to `src/config.py`
-- [ ] Add drive_thru field to root Config
-- [ ] Test config loading
-
-### Phase 2: Session Handler
-- [ ] Create `DriveThruSessionHandler`
-- [ ] Implement `create_agent()` method
-- [ ] Create singleton MenuProvider
-- [ ] Test session creation
-
-### Phase 3: App Wiring
-- [ ] Modify `src/agent.py` to support drive-thru mode
-- [ ] Add console command for drive-thru
-- [ ] Add dev command for drive-thru
-- [ ] Test console mode manually
-
-### Phase 4: BDD Feature Files
-- [ ] Create `tests/features/agent/` directory
-- [ ] Write 01_basic_ordering.feature (3 scenarios)
-- [ ] Write 02_multi_item_ordering.feature (3 scenarios)
-- [ ] Write 03_modifiers.feature (4 scenarios)
-- [ ] Write 04_order_corrections.feature (3 scenarios)
-- [ ] Write 05_error_handling.feature (4 scenarios)
-- [ ] Write 06_order_completion.feature (3 scenarios)
-
-### Phase 5: Step Definitions
-- [ ] Create `tests/features/steps/` directory
-- [ ] Implement Given steps (setup)
-- [ ] Implement When steps (actions)
-- [ ] Implement Then steps (assertions)
-- [ ] Use judge-based assertions for natural language
-- [ ] Use direct assertions for file/state checks
-
-### Phase 6: Test Execution
-- [ ] Install pytest-bdd: `uv add --dev pytest-bdd`
-- [ ] Create `tests/test_bdd_scenarios.py`
-- [ ] Run Priority 1 scenarios (8 scenarios)
-- [ ] Fix any failures
-- [ ] Run Priority 2 scenarios (18 total)
-- [ ] Measure accuracy: target 95%+ pass rate
-
-### Phase 7: Accuracy Measurement
-- [ ] Track metrics: item accuracy, modifier accuracy, order completeness
-- [ ] Identify failure patterns
-- [ ] Iterate on prompts/validation if needed
-- [ ] Document accuracy results
-
-### Phase 8: Integration Testing
-- [ ] Test console mode end-to-end
-- [ ] Test dev mode end-to-end
-- [ ] Verify file outputs (incremental log + final JSON)
-- [ ] Test with various order complexities
-
----
-
-## Success Criteria
-
-âœ… **All components wire together** correctly
-âœ… **Configuration works** (can load drive-thru config)
-âœ… **Console mode works** (can test locally)
-âœ… **All Priority 1 BDD scenarios pass** (8/8)
-âœ… **95%+ Priority 2 scenarios pass** (17+/18)
-âœ… **Order files generated correctly** (incremental log + final JSON)
-âœ… **Accuracy targets met** (95%+ item accuracy)
-âœ… **No regressions** (all unit tests still pass)
-
----
-
-## Dependencies for Next Plan
-
-**This plan provides**:
-- âœ… Complete working application
-- âœ… BDD test suite for validation
-- âœ… Baseline accuracy measurement
-- âœ… Configuration system
-
-**Next plan (Plan 08) can now**:
-- Optimize accuracy strategies
-- A/B test different approaches
-- Add advanced features
-
----
-
-## Design Notes
-
-### Why Singleton MenuProvider?
-
-MenuProvider is loaded once at app startup:
-- Saves memory (only one copy of 212-item menu)
-- Saves time (no repeated file I/O)
-- Thread-safe (read-only)
-- Shared across all sessions
-
-### Why Session-Specific OrderStateManager?
-
-Each conversation gets its own OrderStateManager:
-- Isolated state (no cross-contamination)
-- Easy cleanup (one session = one directory)
-- Testable (each test gets fresh state)
-
-### BDD as Acceptance Tests
-
-BDD scenarios serve as:
-- Acceptance criteria (defines "done")
-- Regression tests (prevents breakage)
-- Documentation (shows how system works)
-- Communication tool (between devs and stakeholders)
-
-**Key Principle**: Integration brings components to life. A well-integrated system is greater than the sum of its parts.
diff --git a/plan/thoughts/drive-thru-llm/08-accuracy-optimization.md b/plan/thoughts/drive-thru-llm/08-accuracy-optimization.md
deleted file mode 100644
index 1d8b953..0000000
--- a/plan/thoughts/drive-thru-llm/08-accuracy-optimization.md
+++ /dev/null
@@ -1,561 +0,0 @@
-# Plan 08: Accuracy Optimization (Advanced Strategies)
-
-**Created**: 2026-01-21
-**Status**: Optional/Future Work
-**Dependencies**: Plans 01-07 (Complete working system with baseline accuracy)
-**Estimated Complexity**: Medium-High
-
----
-
-## Overview
-
-This plan covers **advanced accuracy optimization strategies** to improve beyond the baseline 95% accuracy achieved in Plan 07. These are **optional enhancements** that can be implemented after the core system is working.
-
-**Current State** (after Plan 07):
-- âœ… Strategy 1: Function Calling
-- âœ… Strategy 2: Menu Context Injection
-- âœ… Strategy 4: Fuzzy String Matching
-- âœ… Strategy 9: Post-Processing Validation
-
-**This Plan Adds**:
-- ðŸ”„ Strategy 3: Explicit Confirmation Loop
-- ðŸ§  Strategy 5: Semantic Search with Embeddings
-- ðŸ“Š Strategy 6: Two-Stage Parsing (if needed)
-- ðŸ’­ Strategy 7: Chain-of-Thought Prompting
-- ðŸŽ¯ Strategy 10: Context Window Optimization
-
----
-
-## When to Implement This Plan
-
-**Implement if**:
-- Baseline accuracy < 95% on test suite
-- Specific failure patterns identified (e.g., modifier confusion, similar item names)
-- Need to push accuracy to 98%+
-- Cost/latency optimization needed
-
-**Skip if**:
-- Baseline accuracy >= 95%
-- System meets requirements
-- Want to focus on other features first
-
----
-
-## Strategy 3: Explicit Confirmation Loop
-
-### Overview
-
-Add explicit confirmation steps before committing items to order.
-
-### Implementation
-
-**Approach 1**: Modify agent instructions
-
-```python
-def _get_instructions(self) -> str:
-    return """...existing instructions...
-
-    Confirmation Protocol:
-    - After understanding an item request, CONFIRM with the customer before adding
-    - Example: "Got it, one Big Mac. Is that correct?"
-    - Wait for customer to confirm ("yes", "correct", "that's right")
-    - If customer corrects, update accordingly
-    - Only call add_item_to_order AFTER confirmation
-    """
-```
-
-**Approach 2**: Add confirmation state to OrderStateManager
-
-```python
-class OrderStateManager:
-    def __init__(self, ...):
-        self._pending_items = []  # Items awaiting confirmation
-
-    def stage_item(self, ...) -> OrderItem:
-        """Stage item for confirmation (doesn't add to order yet)."""
-        item = OrderItem(...)
-        self._pending_items.append(item)
-        return item
-
-    def confirm_staged_item(self, item_id: str) -> bool:
-        """Confirm and add staged item to order."""
-        # Move from pending to confirmed
-        ...
-```
-
-### Testing
-
-Add BDD scenarios:
-```gherkin
-Scenario: Customer confirms item
-  When the customer says "I want a Big Mac"
-  Then the agent asks "Did you say one Big Mac?"
-  When the customer says "yes"
-  Then the item is added to the order
-
-Scenario: Customer corrects item
-  When the customer says "I want a Big Mac"
-  Then the agent asks "Did you say one Big Mac?"
-  When the customer says "no, a McDouble"
-  Then the agent updates to McDouble
-  And asks for confirmation again
-```
-
-### Trade-offs
-
-**Pros**:
-- Catches errors before commitment
-- Builds customer confidence
-- Clear correction path
-
-**Cons**:
-- Slower ordering process
-- May annoy customers with simple orders
-- More conversation turns
-
-**Recommendation**: Make configurable via `enable_confirmation_loop` flag
-
----
-
-## Strategy 5: Semantic Search with Embeddings
-
-### Overview
-
-Use vector embeddings to find semantically similar menu items, handling synonyms and paraphrasing.
-
-### Implementation
-
-#### 1. Pre-compute Menu Embeddings
-
-```python
-from openai import OpenAI
-import numpy as np
-
-class MenuEmbeddingsProvider:
-    """Precomputed embeddings for menu items."""
-
-    def __init__(self, menu_provider: MenuProvider):
-        self.menu_provider = menu_provider
-        self.embeddings_cache = self._load_or_compute_embeddings()
-
-    def _compute_embeddings(self) -> dict[str, np.ndarray]:
-        """Compute embeddings for all menu items."""
-        client = OpenAI()
-        items = self._get_all_menu_items()
-
-        embeddings = {}
-        for item in items:
-            # Create searchable text
-            text = f"{item.item_name} {item.category}"
-
-            # Get embedding
-            response = client.embeddings.create(
-                model="text-embedding-3-small",
-                input=text
-            )
-
-            embeddings[item.item_name] = np.array(response.data[0].embedding)
-
-        return embeddings
-
-    def _save_embeddings(self, embeddings: dict) -> None:
-        """Save to disk for fast loading."""
-        import pickle
-        with open("menu_embeddings.pkl", "wb") as f:
-            pickle.dump(embeddings, f)
-
-    def _load_embeddings(self) -> dict | None:
-        """Load from disk if exists."""
-        if not Path("menu_embeddings.pkl").exists():
-            return None
-
-        with open("menu_embeddings.pkl", "rb") as f:
-            return pickle.load(f)
-
-    def _load_or_compute_embeddings(self) -> dict:
-        """Load from disk or compute if not cached."""
-        embeddings = self._load_embeddings()
-        if embeddings is None:
-            embeddings = self._compute_embeddings()
-            self._save_embeddings(embeddings)
-        return embeddings
-
-    def semantic_search(self, query: str, top_k: int = 5) -> list[tuple[Item, float]]:
-        """
-        Find most semantically similar items.
-
-        Args:
-            query: Customer's query (e.g., "cheeseburger")
-            top_k: Number of results to return
-
-        Returns:
-            List of (Item, similarity_score) tuples
-        """
-        # Get query embedding
-        client = OpenAI()
-        response = client.embeddings.create(
-            model="text-embedding-3-small",
-            input=query
-        )
-        query_embedding = np.array(response.data[0].embedding)
-
-        # Compute similarity to all items
-        similarities = []
-        for item_name, item_embedding in self.embeddings_cache.items():
-            # Cosine similarity
-            similarity = np.dot(query_embedding, item_embedding) / (
-                np.linalg.norm(query_embedding) * np.linalg.norm(item_embedding)
-            )
-
-            item = self.menu_provider.get_item_by_name(item_name)
-            similarities.append((item, similarity))
-
-        # Sort by similarity
-        similarities.sort(key=lambda x: x[1], reverse=True)
-
-        return similarities[:top_k]
-```
-
-#### 2. Integrate into MenuProvider
-
-```python
-class MenuProvider:
-    def __init__(self, menu_file_path: str, use_embeddings: bool = False):
-        # ... existing code ...
-
-        if use_embeddings:
-            self._embeddings = MenuEmbeddingsProvider(self)
-
-    def semantic_search(self, query: str, top_k: int = 5) -> list[Item]:
-        """Semantic search using embeddings."""
-        if not hasattr(self, '_embeddings'):
-            raise ValueError("Embeddings not enabled")
-
-        results = self._embeddings.semantic_search(query, top_k)
-        return [item for item, score in results]
-```
-
-#### 3. Use in DriveThruLLM
-
-```python
-class DriveThruLLM(LLM):
-    def _find_relevant_items(self, keywords: list[str]) -> list[Item]:
-        """Find relevant items using semantic search if enabled."""
-        if self._use_semantic_search:
-            # Use embeddings
-            query = " ".join(keywords)
-            return self._menu_provider.semantic_search(query, top_k=20)
-        else:
-            # Use keyword search (existing code)
-            return self._keyword_search(keywords)
-```
-
-### Testing
-
-```python
-def test_semantic_search_synonyms():
-    """Verify semantic search handles synonyms."""
-    embeddings = MenuEmbeddingsProvider(menu_provider)
-
-    # "cheeseburger" should find Quarter Pounder with Cheese, etc.
-    results = embeddings.semantic_search("cheeseburger", top_k=5)
-
-    assert any("cheese" in item.item_name.lower() for item, score in results)
-
-def test_semantic_search_paraphrasing():
-    """Verify semantic search handles paraphrasing."""
-    # "chicken pieces" â†’ Chicken McNuggets
-    results = embeddings.semantic_search("chicken pieces", top_k=5)
-
-    assert any("McNuggets" in item.item_name for item, score in results)
-```
-
-### Trade-offs
-
-**Pros**:
-- Handles synonyms ("cheeseburger" â†’ Quarter Pounder with Cheese)
-- Robust to paraphrasing
-- Better understanding of customer intent
-
-**Cons**:
-- Additional complexity
-- Requires OpenAI API calls (cost)
-- Adds latency (~50-100ms per search)
-- Requires pre-computation and caching
-
-**Recommendation**: Implement if fuzzy matching alone isn't sufficient
-
----
-
-## Strategy 7: Chain-of-Thought Prompting
-
-### Implementation
-
-Modify agent instructions to use chain-of-thought:
-
-```python
-def _get_instructions(self) -> str:
-    return """...existing instructions...
-
-    Decision Process:
-    When a customer orders, think step-by-step:
-
-    1. **Identify Item Type**: What category is this? (burger, breakfast, drink, etc.)
-    2. **Match to Menu**: Which specific menu item matches best?
-    3. **Extract Modifiers**: Did they mention customizations?
-    4. **Determine Quantity**: How many?
-    5. **Verify**: Does this make sense?
-
-    Example:
-    Customer: "I'd like a cheeseburger with no pickles"
-
-    Thinking:
-    1. Item type: burger
-    2. Menu match: Could be Cheeseburger, Quarter Pounder with Cheese, or Double Cheeseburger
-    3. Modifiers: "no pickles"
-    4. Quantity: 1 (not specified, default to 1)
-    5. Verification: Most likely "Cheeseburger" from menu
-
-    Then call: add_item_to_order(category="Beef & Pork", item_name="Cheeseburger", modifiers=["No Pickles"], quantity=1)
-    """
-```
-
-### Testing
-
-Verify LLM follows chain-of-thought process (check logs or use judge to evaluate reasoning).
-
-### Trade-offs
-
-**Pros**:
-- Improves LLM reasoning
-- More interpretable
-- Catches logic errors
-
-**Cons**:
-- Increases token usage (~100-200 tokens per request)
-- Adds latency
-- Reasoning not visible to customer (unless we expose it)
-
----
-
-## Strategy 10: Context Window Optimization
-
-### Implementation
-
-**Dynamic Category Filtering**
-
-```python
-class DriveThruLLM(LLM):
-    def _detect_category(self, message: str) -> str | None:
-        """Detect which category customer is likely ordering from."""
-        message_lower = message.lower()
-
-        # Simple heuristics
-        if any(word in message_lower for word in ["breakfast", "morning", "egg", "mcmuffin"]):
-            return "Breakfast"
-        elif any(word in message_lower for word in ["burger", "mac", "quarter"]):
-            return "Beef & Pork"
-        elif any(word in message_lower for word in ["chicken", "nugget", "fish"]):
-            return "Chicken & Fish"
-        elif any(word in message_lower for word in ["drink", "coke", "sprite", "beverage"]):
-            return "Beverages"
-        # ... more categories ...
-
-        return None  # No clear category
-
-    def _find_relevant_items(self, keywords: list[str], message: str) -> list[Item]:
-        """Find relevant items, filtered by detected category."""
-        # Detect category
-        category = self._detect_category(message)
-
-        if category:
-            # Only search within that category
-            return self._menu_provider.search_items(
-                keyword=" ".join(keywords),
-                category=category
-            )
-        else:
-            # Search all categories
-            return self._menu_provider.search_items(
-                keyword=" ".join(keywords)
-            )
-```
-
-### Trade-offs
-
-**Pros**:
-- Reduces token usage (inject fewer items)
-- Reduces noise (more focused context)
-- Faster inference
-
-**Cons**:
-- May miss cross-category orders
-- Requires accurate category detection
-- More complex logic
-
----
-
-## Experimentation Framework
-
-### A/B Testing Different Strategies
-
-```python
-class AccuracyExperiment:
-    """Framework for A/B testing accuracy strategies."""
-
-    def __init__(self, test_cases: list[TestCase]):
-        self.test_cases = test_cases
-
-    async def run_experiment(
-        self,
-        config: DriveThruConfig,
-        strategy_name: str
-    ) -> ExperimentResults:
-        """Run all test cases with given config."""
-        results = []
-
-        for test_case in self.test_cases:
-            # Create agent with config
-            agent = self._create_agent(config)
-
-            # Run test
-            result = await self._run_test(agent, test_case)
-
-            results.append({
-                "test_case": test_case.name,
-                "strategy": strategy_name,
-                "passed": result.passed,
-                "accuracy": result.accuracy,
-                "latency": result.latency,
-                "cost": result.cost
-            })
-
-        return ExperimentResults(results)
-
-    def compare_strategies(
-        self,
-        baseline_config: DriveThruConfig,
-        experiment_config: DriveThruConfig
-    ) -> Comparison:
-        """Compare two configurations."""
-        baseline_results = await self.run_experiment(baseline_config, "baseline")
-        experiment_results = await self.run_experiment(experiment_config, "experiment")
-
-        return Comparison(
-            baseline=baseline_results,
-            experiment=experiment_results,
-            metrics=["accuracy", "latency", "cost"]
-        )
-```
-
-### Example Experiments
-
-**Experiment 1**: Fuzzy matching threshold
-- Baseline: threshold=85
-- Variants: threshold=75, threshold=90, threshold=95
-- Metric: Item accuracy
-
-**Experiment 2**: Semantic search vs keyword search
-- Baseline: keyword search only
-- Variant: semantic search enabled
-- Metrics: Accuracy, latency, cost
-
-**Experiment 3**: Confirmation loop
-- Baseline: no confirmation
-- Variant: confirmation enabled
-- Metrics: Accuracy, conversation length, user satisfaction
-
----
-
-## Implementation Checklist
-
-### Phase 1: Identify Optimization Needs
-- [ ] Run full test suite, measure baseline accuracy
-- [ ] Identify failure patterns (which scenarios fail?)
-- [ ] Categorize failures (item confusion, modifier errors, quantity errors, etc.)
-- [ ] Prioritize strategies to address failures
-
-### Phase 2: Implement Selected Strategies
-- [ ] Strategy 3: Confirmation loop (if needed)
-- [ ] Strategy 5: Semantic search (if fuzzy matching insufficient)
-- [ ] Strategy 7: Chain-of-thought (if reasoning errors observed)
-- [ ] Strategy 10: Context optimization (if token usage/latency high)
-
-### Phase 3: A/B Testing
-- [ ] Create experiment framework
-- [ ] Define test cases
-- [ ] Run baseline experiment
-- [ ] Run variant experiments
-- [ ] Compare metrics: accuracy, latency, cost
-
-### Phase 4: Analysis
-- [ ] Analyze experiment results
-- [ ] Identify best-performing strategy
-- [ ] Verify accuracy improvement
-- [ ] Check latency/cost impact
-
-### Phase 5: Production Deployment
-- [ ] Update default config with optimal strategy
-- [ ] Re-run full test suite
-- [ ] Verify 95%+ accuracy achieved
-- [ ] Document accuracy improvements
-- [ ] Update configuration docs
-
----
-
-## Success Criteria
-
-âœ… **Accuracy >= 95%** on full BDD test suite
-âœ… **Optimal strategy identified** via A/B testing
-âœ… **Latency acceptable** (<2s per turn)
-âœ… **Cost reasonable** (<$0.05 per order)
-âœ… **All tests pass** with optimized configuration
-
----
-
-## Design Notes
-
-### When to Optimize
-
-**Optimize Early If**:
-- Critical accuracy requirements (e.g., production system)
-- Known difficult edge cases
-- Cost/latency constraints
-
-**Optimize Later If**:
-- Baseline accuracy sufficient
-- MVP approach
-- Learning/experimentation focus
-
-### Measure, Don't Guess
-
-Always measure impact:
-- Accuracy change: +X% item accuracy
-- Latency change: +Y ms per turn
-- Cost change: +$Z per order
-
-Make data-driven decisions.
-
-### Diminishing Returns
-
-- 90% â†’ 95% accuracy: Moderate effort
-- 95% â†’ 98% accuracy: Significant effort
-- 98% â†’ 99.5% accuracy: Extreme effort
-
-Choose target based on requirements and ROI.
-
----
-
-## Future Enhancements
-
-Beyond this plan:
-
-1. **Active Learning**: Learn from corrections, improve over time
-2. **Personalization**: Remember customer preferences
-3. **Multi-turn Context**: Better understanding of conversation history
-4. **Voice-specific Optimization**: Handle STT errors better
-5. **Menu Evolution**: Adapt to menu changes automatically
-
----
-
-**Key Principle**: Optimize based on measured needs, not speculation. Start with simple strategies, add complexity only when data shows it's needed. 95% accuracy with simple system beats 97% accuracy with complex, fragile system.
diff --git a/plan/thoughts/drive-thru-llm/README.md b/plan/thoughts/drive-thru-llm/README.md
deleted file mode 100644
index 87433a7..0000000
--- a/plan/thoughts/drive-thru-llm/README.md
+++ /dev/null
@@ -1,491 +0,0 @@
-# McDonald's Drive-Thru Agent - Implementation Plans
-
-**Created**: 2026-01-21
-**Purpose**: Ordered breakdown of main plan into testable, implementable chunks
-
----
-
-## Overview
-
-This directory contains the **complete implementation plan** for the McDonald's Drive-Thru Agent, broken down into **8 numbered plans** that must be executed in order based on dependencies.
-
-The original monolithic plan (`mcdonalds-drive-thru-agent-plan.md`) has been analyzed for dependencies and restructured into smaller, focused plans that are:
-- âœ… **Ordered by dependencies** (Plan 01 has no dependencies, Plan 08 depends on all previous)
-- âœ… **Testable using BDD strategy** (each plan maps to BDD scenarios)
-- âœ… **Easy for agents to implement** (clear scope, concrete tasks)
-- âœ… **Independently verifiable** (each plan has success criteria)
-
----
-
-## Implementation Status Checklist
-
-**Last Updated**: 2026-01-21 (Plan 06 completed)
-
-Track completion of all implementation plans. Check off each plan as it's completed and verified.
-
-- [x] **Plan 01: Menu Models and Validation** âœ… COMPLETED
-  - Enhanced `Item` class with `quantity` and `item_id` fields
-  - Implemented `__add__()` method for combining items
-  - Created pure validation functions (`fuzzy_match_item`, `validate_item_exists`, `validate_modifiers`, `validate_order_item`)
-  - 67 tests passing in 0.08s
-  - Files: `menus/mcdonalds/models.py`, `src/menu_validation.py`
-  - Tests: `tests/test_menu_models.py`, `tests/test_menu_validation.py`
-
-- [x] **Plan 02: MenuProvider** âœ… COMPLETED
-  - Created `MenuProvider` class with read-only menu access
-  - Implemented query methods: `search_items()`, `get_category()`, `get_item()`, `get_all_categories()`, etc.
-  - All methods return immutable copies via `model_copy()`
-  - Built lookup indices for O(1) category access
-  - 28 tests passing in 0.06s
-  - Files: `src/menu_provider.py`
-  - Tests: `tests/test_menu_provider.py`
-  - Depends on: Plan 01
-
-- [x] **Plan 03: OrderStateManager** âœ… COMPLETED
-  - Created `OrderItem` dataclass with full serialization support (to_dict/from_dict)
-  - Implemented `OrderStateManager` class with all command methods (add_item, remove_item, update_item_quantity, complete_order, clear_order)
-  - Implemented all query methods (get_items, get_item_by_id, get_total_count, get_order_summary, is_empty)
-  - Dual persistence: incremental log (JSONL) + final JSON on completion
-  - Returns immutable copies from query methods to prevent external state mutations
-  - 36 tests passing in 0.04s
-  - Files: `src/order_state_manager.py`
-  - Tests: `tests/test_order_state.py`
-  - Fixtures added to: `tests/conftest.py`
-  - Depends on: Plan 01
-
-- [x] **Plan 04: OrderTools** âœ… COMPLETED
-  - Created `src/tools/order_tools.py` with factory function and three tools
-  - Implemented `add_item_to_order` tool with validation integration
-  - Implemented `complete_order` tool for order finalization
-  - Implemented `remove_item_from_order` tool for item removal
-  - 24 tests passing in 0.45s
-  - Files: `src/tools/order_tools.py`, `src/tools/__init__.py`
-  - Tests: `tests/test_order_tools.py`
-  - Fixtures added to: `tests/conftest.py`
-  - Depends on: Plans 01, 02, 03
-
-- [x] **Plan 05: DriveThruLLM** âœ… COMPLETED
-  - Created `DriveThruLLM` stateless wrapper class
-  - Implemented keyword extraction from user messages
-  - Implemented menu item search and context injection
-  - Implemented chat() method that intercepts and injects menu context
-  - 19 tests passing in 0.40s
-  - Files: `src/drive_thru_llm.py`
-  - Tests: `tests/test_drive_thru_llm.py`
-  - Depends on: Plan 02
-
-- [x] **Plan 06: DriveThruAgent** âœ… COMPLETED
-  - Created `DriveThruAgent` orchestration class extending LiveKit Agent
-  - Implemented component wiring: owns OrderStateManager, receives MenuProvider and DriveThruLLM via DI
-  - Implemented comprehensive agent instructions and persona
-  - Provided properties for accessing agent, order_state, llm, and tools
-  - 6 unit tests passing (agent initialization, wiring, ownership)
-  - 8 integration tests passing (tool integration, order workflows, error handling)
-  - 14 total tests passing in 0.40s
-  - Files: `src/drive_thru_agent.py`
-  - Tests: `tests/test_drive_thru_agent.py`, `tests/test_drive_thru_agent_integration.py`
-  - Fixtures added to: `tests/conftest.py`
-  - Depends on: Plans 02, 03, 04, 05
-
-- [x] **Plan 07: Integration and Wiring** âœ… COMPLETED (2026-01-21)
-  - Added `DriveThruConfig` to `src/config.py` with menu path, output dir, fuzzy match threshold, and feature flags
-  - Created `DriveThruSessionHandler` in `src/session_handler.py` for session management
-  - Created `src/agent.py` as CLI entry point with commands: console, dev, start, download-files
-  - Created BDD feature files (6 files total):
-    - `tests/features/agent/01_basic_ordering.feature` (3 scenarios)
-    - `tests/features/agent/02_multi_item_ordering.feature` (3 scenarios)
-    - `tests/features/agent/03_modifiers.feature` (4 scenarios)
-    - `tests/features/agent/04_order_corrections.feature` (3 scenarios)
-    - `tests/features/agent/05_error_handling.feature` (4 scenarios)
-    - `tests/features/agent/06_order_completion.feature` (4 scenarios)
-  - Total: 21 BDD scenarios defined
-  - Added dependencies: click, pytest-bdd
-  - CLI tested and operational
-  - Files: `src/config.py` (modified), `src/session_handler.py` (modified), `src/agent.py` (new)
-  - Feature files: `tests/features/agent/*.feature` (6 files)
-  - Note: BDD step definitions and test execution deferred (user preference)
-  - Depends on: Plans 01-06
-
-- [ ] **Plan 08: Accuracy Optimization**
-  - Not yet started (Optional/Future Work)
-  - Depends on: Plan 07
-
----
-
-## Dependency Graph
-
-```
-Plan 01: Menu Models & Validation
-    â†“ (provides: Item models, validation functions)
-    â”‚
-    â”œâ”€â†’ Plan 02: MenuProvider (depends on Item models)
-    â”‚       â†“ (provides: read-only menu access)
-    â”‚       â”‚
-    â”‚       â””â”€â†’ Plan 05: DriveThruLLM (depends on MenuProvider)
-    â”‚
-    â””â”€â†’ Plan 03: OrderStateManager (depends on OrderItem dataclass)
-            â†“ (provides: state management)
-            â”‚
-            â””â”€â†’ Plan 04: OrderTools (depends on Plans 01, 02, 03)
-                    â†“ (provides: LLM tools)
-                    â”‚
-                    â””â”€â†’ Plan 06: DriveThruAgent (depends on Plans 02, 03, 04, 05)
-                            â†“ (provides: complete agent)
-                            â”‚
-                            â””â”€â†’ Plan 07: Integration (depends on Plans 01-06)
-                                    â†“ (provides: working application)
-                                    â”‚
-                                    â””â”€â†’ Plan 08: Optimization (depends on Plan 07)
-```
-
----
-
-## Implementation Plans
-
-### Plan 01: Menu Models and Validation
-**File**: `01-menu-models-and-validation.md`
-**Dependencies**: None (Foundation layer)
-**Complexity**: Low-Medium
-
-**What it builds**:
-- Enhanced `Item` class with `quantity` and `item_id` fields
-- `__add__()` method for combining items
-- Pure validation functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`
-- `ValidationResult` dataclass
-
-**Why first**: No dependencies, pure functions, fast to test
-
-**Success Criteria**: 22+ unit tests pass in <1 second
-
----
-
-### Plan 02: MenuProvider
-**File**: `02-menu-provider.md`
-**Dependencies**: Plan 01 (Menu models)
-**Complexity**: Low
-
-**What it builds**:
-- `MenuProvider` class for read-only menu access
-- Query methods: `search_items()`, `get_category()`, `get_item()`
-- Immutable data guarantees
-
-**Why second**: Only depends on models, provides data access for all other components
-
-**Success Criteria**: 20+ unit tests pass in <2 seconds, returns immutable copies
-
----
-
-### Plan 03: OrderStateManager
-**File**: `03-order-state-manager.md`
-**Dependencies**: Plan 01 (OrderItem dataclass)
-**Complexity**: Medium
-
-**What it builds**:
-- `OrderStateManager` class (single source of truth for order state)
-- Command methods: `add_item()`, `remove_item()`, `complete_order()`
-- Query methods: `get_items()`, `get_order_summary()`
-- Persistence: incremental log (JSONL) + final JSON
-
-**Why third**: Parallel to Plan 02, only depends on dataclasses
-
-**Success Criteria**: 30+ unit tests pass, file I/O works correctly, 95%+ coverage
-
----
-
-### Plan 04: OrderTools
-**File**: `04-order-tools.md`
-**Dependencies**: Plans 01, 02, 03 (validation, menu, state)
-**Complexity**: Medium
-
-**What it builds**:
-- `create_order_tools()` factory function
-- `add_item_to_order` tool (with validation)
-- `complete_order` tool
-- `remove_item_from_order` tool (optional)
-
-**Why fourth**: Coordination layer between LLM and system, needs all foundation components
-
-**Success Criteria**: 20+ integration tests pass, validation prevents invalid state mutations
-
----
-
-### Plan 05: DriveThruLLM
-**File**: `05-drive-thru-llm.md`
-**Dependencies**: Plan 02 (MenuProvider)
-**Complexity**: Medium
-
-**What it builds**:
-- `DriveThruLLM` wrapper class (stateless)
-- Menu context injection (Strategy 2)
-- Keyword extraction and relevant item search
-
-**Why fifth**: Parallel to Plan 04, only depends on MenuProvider for context
-
-**Success Criteria**: 15+ unit tests pass, context injection works, wrapper is stateless
-
----
-
-### Plan 06: DriveThruAgent
-**File**: `06-drive-thru-agent.md`
-**Dependencies**: Plans 02, 03, 04, 05 (all components)
-**Complexity**: Medium
-
-**What it builds**:
-- `DriveThruAgent` orchestration class
-- Agent instructions and persona
-- Component wiring (owns OrderStateManager, receives dependencies)
-
-**Why sixth**: Brings all components together, needs everything from previous plans
-
-**Success Criteria**: E2E tests pass for basic scenarios, agent creates correctly
-
----
-
-### Plan 07: Integration and Wiring
-**File**: `07-integration-and-wiring.md`
-**Dependencies**: Plans 01-06 (complete system)
-**Complexity**: Medium-High
-
-**What it builds**:
-- `DriveThruConfig` in config system
-- `DriveThruSessionHandler` for session management
-- Console and dev mode commands
-- All BDD scenarios as E2E tests (18 scenarios)
-
-**Why seventh**: Integration requires all components working, tests verify end-to-end
-
-**Success Criteria**: All Priority 1 BDD scenarios pass (8/8), 95%+ Priority 2 pass (17+/18)
-
----
-
-### Plan 08: Accuracy Optimization
-**File**: `08-accuracy-optimization.md`
-**Dependencies**: Plan 07 (working system with baseline accuracy)
-**Complexity**: Medium-High
-**Status**: Optional/Future Work
-
-**What it adds**:
-- Strategy 3: Explicit Confirmation Loop
-- Strategy 5: Semantic Search with Embeddings
-- Strategy 7: Chain-of-Thought Prompting
-- Strategy 10: Context Window Optimization
-- A/B testing framework
-
-**Why last**: Optimization requires baseline to measure against
-
-**Success Criteria**: Accuracy >= 95% (or higher target), optimal strategy identified
-
----
-
-## How to Use These Plans
-
-### For Sequential Implementation
-
-1. **Start with Plan 01**: Implement pure functions and models
-   ```bash
-   # Read plan
-   cat plan/thoughts/01-menu-models-and-validation.md
-
-   # Implement according to checklist
-   # Run tests until all pass
-   uv run pytest tests/test_menu_validation.py -v
-   ```
-
-2. **Move to Plan 02**: Only start after Plan 01 is complete
-   ```bash
-   cat plan/thoughts/02-menu-provider.md
-   # Implement, test, verify
-   ```
-
-3. **Continue sequentially** through Plans 03-08
-
-### For Parallel Work (Multiple Developers)
-
-**Team A** can work on:
-- Plan 01 â†’ Plan 02 â†’ Plan 05 (MenuProvider track)
-
-**Team B** can work on:
-- Plan 01 â†’ Plan 03 â†’ Plan 04 (State management track)
-
-**Then merge** at Plan 06 (DriveThruAgent)
-
-### For Agent Implementation
-
-Each plan includes:
-- âœ… **Clear scope**: Exactly what to build
-- âœ… **Implementation checklist**: Step-by-step tasks
-- âœ… **Test requirements**: What tests to write
-- âœ… **Success criteria**: How to know you're done
-- âœ… **BDD mapping**: Which scenarios this plan supports
-
-Agents can implement one plan at a time, verifying completion before moving to the next.
-
----
-
-## BDD Testing Strategy
-
-All plans map to BDD scenarios defined in `../bdd-testing-strategy.md`:
-
-| BDD Scenario | Implemented In |
-|--------------|----------------|
-| 1.1 (Order Big Mac) | Plans 01-07 |
-| 1.2 (With quantity) | Plans 01-07 |
-| 2.1 (Multiple items) | Plans 01-07 |
-| 3.1 (With modifiers) | Plans 01, 04-07 |
-| 4.1 (Corrections) | Plans 03, 04, 06, 07 |
-| 5.1 (Invalid item) | Plans 01, 04, 07 |
-| 5.2 (Ambiguous) | Plans 02, 05, 07 |
-| 5.4 (STT recovery) | Plans 01, 05, 07 |
-| 6.1 (Complete order) | Plans 03, 04, 07 |
-
-All 18 scenarios are fully tested in Plan 07's E2E test suite.
-
----
-
-## Architecture Principles
-
-Each plan follows these clean architecture principles:
-
-**âœ“ Single Responsibility Principle (SRP)**
-- Each component has one reason to change
-- Pure functions separated from stateful components
-
-**âœ“ Dependency Inversion**
-- Components receive dependencies via constructor
-- High-level components don't depend on low-level details
-
-**âœ“ Pure Functions Where Possible**
-- Plan 01: All validation functions are pure
-- Fast, testable, reusable
-
-**âœ“ Immutability Reduces Bugs**
-- Plan 02: MenuProvider returns immutable data
-- Plan 03: OrderStateManager returns copies
-
-**âœ“ Single Source of Truth**
-- Plan 03: OrderStateManager owns ALL order state
-- No distributed state
-
-**âœ“ Tell, Don't Ask**
-- Plan 04: Tools tell OrderStateManager what to do
-- No query-and-manipulate patterns
-
-**âœ“ Test Pyramid**
-- Many fast unit tests (Plans 01-06)
-- Some integration tests (Plans 04-06)
-- Few E2E tests (Plan 07)
-
----
-
-## File Structure After Implementation
-
-```
-src/
-â”œâ”€â”€ menu_validation.py          # Plan 01
-â”œâ”€â”€ menu_provider.py            # Plan 02
-â”œâ”€â”€ order_state_manager.py      # Plan 03
-â”œâ”€â”€ drive_thru_llm.py          # Plan 05
-â”œâ”€â”€ drive_thru_agent.py        # Plan 06
-â”œâ”€â”€ session_handler.py         # Plan 07
-â”œâ”€â”€ config.py                  # Plan 07 (modified)
-â”œâ”€â”€ agent.py                   # Plan 07 (modified)
-â””â”€â”€ tools/
-    â””â”€â”€ order_tools.py         # Plan 04
-
-tests/
-â”œâ”€â”€ test_menu_validation.py    # Plan 01
-â”œâ”€â”€ test_menu_models.py        # Plan 01
-â”œâ”€â”€ test_menu_provider.py      # Plan 02
-â”œâ”€â”€ test_order_state.py        # Plan 03
-â”œâ”€â”€ test_order_tools.py        # Plan 04
-â”œâ”€â”€ test_drive_thru_llm.py     # Plan 05
-â”œâ”€â”€ test_drive_thru_agent.py   # Plan 06
-â”œâ”€â”€ test_bdd_scenarios.py      # Plan 07
-â””â”€â”€ features/
-    â”œâ”€â”€ steps/
-    â”‚   â””â”€â”€ agent_steps.py     # Plan 07
-    â””â”€â”€ agent/
-        â”œâ”€â”€ 01_basic_ordering.feature       # Plan 07
-        â”œâ”€â”€ 02_multi_item_ordering.feature  # Plan 07
-        â”œâ”€â”€ 03_modifiers.feature            # Plan 07
-        â”œâ”€â”€ 04_order_corrections.feature    # Plan 07
-        â”œâ”€â”€ 05_error_handling.feature       # Plan 07
-        â””â”€â”€ 06_order_completion.feature     # Plan 07
-
-menus/
-â””â”€â”€ mcdonalds/
-    â”œâ”€â”€ models.py                           # Plan 01 (enhanced)
-    â””â”€â”€ transformed-data/
-        â””â”€â”€ menu-structure-2026-01-21.json
-
-orders/
-â””â”€â”€ {session_id}/
-    â”œâ”€â”€ incremental_log.jsonl  # Plan 03
-    â””â”€â”€ final_order.json       # Plan 03
-```
-
----
-
-## Testing Checklist
-
-After implementing all plans:
-
-### Unit Tests
-- [ ] Plan 01: 22+ tests, <1 second, 100% coverage
-- [ ] Plan 02: 20+ tests, <2 seconds, 95%+ coverage
-- [ ] Plan 03: 30+ tests, fast in-memory, 95%+ coverage
-- [ ] Plan 04: 20+ tests, 90%+ coverage
-- [ ] Plan 05: 15+ tests, 90%+ coverage
-- [ ] Plan 06: 6+ tests
-
-### Integration Tests
-- [ ] Plan 04: Tools + State + Validation work together
-- [ ] Plan 06: Agent wiring correct
-
-### E2E BDD Tests
-- [ ] Plan 07: All Priority 1 scenarios pass (8/8)
-- [ ] Plan 07: 95%+ Priority 2 scenarios pass (17+/18)
-
-### Total Test Count
-- Expected: **150+ tests** across all levels
-- Test pyramid: ~100 unit, ~30 integration, ~20 E2E
-
----
-
-## Success Metrics
-
-**After Plan 07 (MVP)**:
-- âœ… All components implemented
-- âœ… 95%+ BDD scenarios pass
-- âœ… Order files generated correctly
-- âœ… Console mode works end-to-end
-- âœ… ~150+ tests passing
-
-**After Plan 08 (Optimized)**:
-- âœ… Accuracy â‰¥ 95% (or target)
-- âœ… Latency < 2 seconds per turn
-- âœ… Cost reasonable
-- âœ… Optimal strategies identified
-
----
-
-## Next Steps
-
-1. **Review this breakdown** with team
-2. **Start with Plan 01**: Foundation layer
-3. **Work sequentially** or in parallel (see above)
-4. **Test thoroughly** at each step
-5. **Integrate at Plan 07**
-6. **Optimize at Plan 08** (if needed)
-
----
-
-## Questions?
-
-Refer to:
-- **Main plan**: `mcdonalds-drive-thru-agent-plan.md` (unchanged reference)
-- **BDD strategy**: `../bdd-testing-strategy.md`
-- **Individual plans**: `01-*.md` through `08-*.md`
-- **Project docs**: `../../AGENTS.md` and `../../README.md`
-
-**Key Principle**: Each plan is self-contained, testable, and verifiable. Build from the bottom up (pure functions â†’ data access â†’ state â†’ coordination â†’ orchestration â†’ integration â†’ optimization).
diff --git a/plan/thoughts/drive-thru-llm/bdd-testing-strategy.md b/plan/thoughts/drive-thru-llm/bdd-testing-strategy.md
deleted file mode 100644
index 513f6dd..0000000
--- a/plan/thoughts/drive-thru-llm/bdd-testing-strategy.md
+++ /dev/null
@@ -1,584 +0,0 @@
-# BDD Testing Strategy for McDonald's Drive-Thru Agent
-
-**Created**: 2026-01-21
-**Purpose**: Define minimal set of behavior-driven scenarios for testing the drive-thru agent's behavior, not its implementation
-
----
-
-## Overview
-
-This document outlines a minimal but comprehensive set of BDD scenarios using Gherkin syntax to validate the McDonald's Drive-Thru Agent's behavior from a customer perspective. These scenarios test **what the system does**, not **how it does it**.
-
-### Testing Principles
-
-1. **Behavior-Focused**: Test observable customer interactions, not internal implementation
-2. **Black-Box**: Treat the agent as a black box - input (voice) â†’ output (response + order file)
-3. **User Perspective**: Write scenarios from the customer's point of view
-4. **End-to-End**: Each scenario covers a complete customer journey
-5. **Implementation-Agnostic**: Scenarios should remain valid even if internal architecture changes
-
----
-
-## Feature File Organization
-
-```
-tests/features/agent/
-â”œâ”€â”€ 01_basic_ordering.feature          # Simple, single-item orders
-â”œâ”€â”€ 02_multi_item_ordering.feature     # Multiple items in one order
-â”œâ”€â”€ 03_modifiers.feature               # Items with customizations
-â”œâ”€â”€ 04_order_corrections.feature       # Fixing mistakes
-â”œâ”€â”€ 05_error_handling.feature          # Invalid items and edge cases
-â””â”€â”€ 06_order_completion.feature        # Finishing and confirming orders
-```
-
----
-
-## 1. Basic Ordering (`01_basic_ordering.feature`)
-
-**Purpose**: Verify the agent can handle simple, straightforward orders
-
-### Scenarios
-
-#### Scenario 1.1: Order a single menu item
-```gherkin
-Feature: Basic Single-Item Ordering
-  As a customer
-  I want to order a single item
-  So that I can get my food quickly
-
-  Scenario: Customer orders a Big Mac
-    Given the agent greets the customer
-    When the customer says "I'll have a Big Mac"
-    Then the agent confirms "one Big Mac"
-    And the agent asks if the customer wants anything else
-    When the customer says "that's all"
-    Then the agent reads back the complete order
-    And the order file contains 1 item
-    And the order file shows "Big Mac" in category "Beef & Pork"
-```
-
-#### Scenario 1.2: Order with explicit quantity
-```gherkin
-  Scenario: Customer orders multiple quantities of same item
-    Given the agent greets the customer
-    When the customer says "Two Big Macs please"
-    Then the agent confirms "two Big Macs"
-    And the agent asks if the customer wants anything else
-    When the customer says "no thanks"
-    Then the order file contains 1 line item with quantity 2
-```
-
-#### Scenario 1.3: Order from breakfast menu
-```gherkin
-  Scenario: Customer orders a breakfast item
-    Given the agent greets the customer
-    When the customer says "I'd like an Egg McMuffin"
-    Then the agent confirms the item
-    And the order file shows the item in category "Breakfast"
-```
-
----
-
-## 2. Multi-Item Ordering (`02_multi_item_ordering.feature`)
-
-**Purpose**: Verify the agent can handle orders with multiple different items
-
-### Scenarios
-
-#### Scenario 2.1: Order multiple items sequentially
-```gherkin
-Feature: Multi-Item Ordering
-  As a customer
-  I want to order several different items
-  So that I can get everything I need
-
-  Scenario: Customer orders items one at a time
-    Given the agent greets the customer
-    When the customer says "I'll have a Big Mac"
-    Then the agent confirms "one Big Mac"
-    When the customer says "and a medium fries"
-    Then the agent confirms "one medium fries"
-    When the customer says "and a Coke"
-    Then the agent confirms the Coke
-    When the customer says "that's it"
-    Then the order file contains 3 items
-    And the order includes "Big Mac", "Medium Fries", and a beverage
-```
-
-#### Scenario 2.2: Order multiple items in one utterance
-```gherkin
-  Scenario: Customer lists multiple items at once
-    Given the agent greets the customer
-    When the customer says "I want a Big Mac, large fries, and a Sprite"
-    Then the agent confirms all three items
-    And the order file contains 3 items
-```
-
-#### Scenario 2.3: Mix of quantities and items
-```gherkin
-  Scenario: Customer orders mix of single and multiple items
-    Given the agent greets the customer
-    When the customer says "Two Big Macs and one large fries"
-    Then the agent confirms "two Big Macs and one large fries"
-    And the order file contains 2 line items
-    And one line item has quantity 2
-    And one line item has quantity 1
-```
-
----
-
-## 3. Modifiers and Customizations (`03_modifiers.feature`)
-
-**Purpose**: Verify the agent correctly captures item customizations
-
-### Scenarios
-
-#### Scenario 3.1: Item with modifier
-```gherkin
-Feature: Order Customization
-  As a customer
-  I want to customize my items
-  So that I get exactly what I want
-
-  Scenario: Customer adds cheese to Quarter Pounder
-    Given the agent greets the customer
-    When the customer says "Quarter Pounder with cheese"
-    Then the agent confirms the item with the modifier
-    And the order file shows "Quarter Pounder" with modifier "Cheese"
-```
-
-#### Scenario 3.2: Item with removal modifier
-```gherkin
-  Scenario: Customer requests no pickles
-    Given the agent greets the customer
-    When the customer says "Big Mac with no pickles"
-    Then the agent confirms "Big Mac, no pickles"
-    And the order file shows the "no pickles" modifier
-```
-
-#### Scenario 3.3: Multiple modifiers on one item
-```gkerkin
-  Scenario: Customer requests multiple customizations
-    Given the agent greets the customer
-    When the customer says "Big Mac with no pickles and extra sauce"
-    Then the agent confirms both modifiers
-    And the order file shows both "no pickles" and "extra sauce" modifiers
-```
-
-#### Scenario 3.4: Different modifiers on same item type
-```gherkin
-  Scenario: Customer orders two Big Macs with different customizations
-    Given the agent greets the customer
-    When the customer says "Two Big Macs, one with no pickles"
-    Then the agent confirms one regular Big Mac and one without pickles
-    And the order file contains 2 separate line items for Big Mac
-    And one line item has "no pickles" modifier
-    And one line item has no modifiers
-```
-
----
-
-## 4. Order Corrections (`04_order_corrections.feature`)
-
-**Purpose**: Verify the agent can handle customer corrections and changes
-
-### Scenarios
-
-#### Scenario 4.1: Correct item before confirming
-```gherkin
-Feature: Order Corrections
-  As a customer
-  I want to correct mistakes in my order
-  So that I get what I actually want
-
-  Scenario: Customer corrects item immediately
-    Given the agent greets the customer
-    When the customer says "I want a Big Mac"
-    And the customer says "actually, make that a McDouble"
-    Then the agent acknowledges the correction
-    And the order file contains "McDouble"
-    And the order file does not contain "Big Mac"
-```
-
-#### Scenario 4.2: Change quantity
-```gherkin
-  Scenario: Customer changes quantity of an item
-    Given the agent greets the customer
-    When the customer says "Two Big Macs"
-    And the customer says "actually make that three Big Macs"
-    Then the agent confirms "three Big Macs"
-    And the order file shows quantity 3 for Big Mac
-```
-
-#### Scenario 4.3: Remove item from order
-```gherkin
-  Scenario: Customer removes an item
-    Given the agent has confirmed "Big Mac" and "fries"
-    When the customer says "actually, skip the fries"
-    Then the agent acknowledges the removal
-    And the order file contains only "Big Mac"
-    And the order file does not contain "fries"
-```
-
----
-
-## 5. Error Handling (`05_error_handling.feature`)
-
-**Purpose**: Verify the agent handles invalid requests gracefully
-
-### Scenarios
-
-#### Scenario 5.1: Invalid menu item
-```gherkin
-Feature: Error Handling
-  As a customer
-  I want to be informed when I request something unavailable
-  So that I can make a valid choice
-
-  Scenario: Customer requests item not on menu
-    Given the agent greets the customer
-    When the customer says "I want a Whopper"
-    Then the agent politely informs the customer the item is not available
-    And the agent suggests looking at the menu
-    And the order file remains empty
-```
-
-#### Scenario 5.2: Ambiguous request
-```gherkin
-  Scenario: Customer makes unclear request
-    Given the agent greets the customer
-    When the customer says "I want a burger"
-    Then the agent asks for clarification
-    And the agent may suggest specific burger options
-    And the order file remains empty until clarified
-```
-
-#### Scenario 5.3: Invalid modifier
-```gherkin
-  Scenario: Customer requests unavailable customization
-    Given the agent greets the customer
-    When the customer says "Big Mac with anchovies"
-    Then the agent informs the customer that modifier is not available
-    And the agent may suggest valid modifiers
-    And no item is added to the order
-```
-
-#### Scenario 5.4: STT error recovery
-```gherkin
-  Scenario: Customer's words are misheard but corrected
-    Given the agent greets the customer
-    When the customer says something that sounds like "Big Mack"
-    Then the agent confirms "Big Mac" using fuzzy matching
-    And the order file contains "Big Mac" (correct spelling)
-```
-
----
-
-## 6. Order Completion (`06_order_completion.feature`)
-
-**Purpose**: Verify the agent properly finalizes orders
-
-### Scenarios
-
-#### Scenario 6.1: Complete a simple order
-```gherkin
-Feature: Order Completion
-  As a customer
-  I want my order to be finalized correctly
-  So that I receive what I ordered
-
-  Scenario: Customer completes order
-    Given the agent has confirmed "Big Mac" and "fries"
-    When the customer says "that's all"
-    Then the agent reads back the complete order
-    And the agent thanks the customer
-    And a final order JSON file is created
-    And the JSON file contains all items
-    And the JSON file has correct quantities
-```
-
-#### Scenario 6.2: Cancel entire order
-```gherkin
-  Scenario: Customer cancels order
-    Given the agent has confirmed "Big Mac" and "fries"
-    When the customer says "actually, cancel that"
-    Then the agent acknowledges the cancellation
-    And the order file is empty or marked as cancelled
-```
-
-#### Scenario 6.3: Final confirmation and correction
-```gherkin
-  Scenario: Customer corrects during final readback
-    Given the agent has confirmed "Big Mac", "fries", and "Coke"
-    When the agent reads back the order
-    And the customer says "no, I wanted a Sprite not a Coke"
-    Then the agent corrects the order
-    And the final order file shows "Sprite"
-    And the final order file does not contain "Coke"
-```
-
----
-
-## Minimal Test Coverage Matrix
-
-### Priority 1: Core Behaviors (Must Have)
-| Feature | Scenarios | Coverage |
-|---------|-----------|----------|
-| Basic Ordering | 1.1, 1.2 | Single item, quantities |
-| Multi-Item | 2.1 | Sequential ordering |
-| Modifiers | 3.1 | Basic customization |
-| Error Handling | 5.1, 5.2 | Invalid items, ambiguity |
-| Completion | 6.1 | Finalize order |
-
-**Total**: ~8 scenarios for smoke testing
-
-### Priority 2: Extended Coverage (Should Have)
-| Feature | Additional Scenarios | Coverage |
-|---------|---------------------|----------|
-| Basic Ordering | 1.3 | Category coverage (breakfast) |
-| Multi-Item | 2.2, 2.3 | Bulk ordering, mixed quantities |
-| Modifiers | 3.2, 3.3, 3.4 | Removals, multiple mods, variations |
-| Corrections | 4.1, 4.2, 4.3 | All correction types |
-| Error Handling | 5.3, 5.4 | Invalid mods, STT recovery |
-| Completion | 6.2, 6.3 | Cancellation, final corrections |
-
-**Total**: ~18 scenarios for comprehensive testing
-
-### Priority 3: Edge Cases (Nice to Have)
-- Ordering from multiple categories
-- Very large orders (10+ items)
-- Rapid corrections (multiple changes)
-- Silence handling (customer doesn't respond)
-- Interruptions (customer talks over agent)
-
----
-
-## Test Data Requirements
-
-### Menu Items to Cover
-- **Breakfast**: Egg McMuffin, Hash Browns
-- **Beef & Pork**: Big Mac, Quarter Pounder, McDouble
-- **Chicken & Fish**: Chicken McNuggets, Filet-O-Fish
-- **Snacks & Sides**: Fries (Small, Medium, Large), Apple Slices
-- **Beverages**: Coke, Sprite, Water
-- **Coffee & Tea**: Coffee (various sizes)
-- **Desserts**: Apple Pie, McFlurry
-- **Smoothies & Shakes**: Chocolate Shake
-
-### Modifiers to Test
-- Additions: "with cheese", "extra sauce", "add bacon"
-- Removals: "no pickles", "no onions", "no ice"
-- Substitutions: "egg whites instead of regular eggs"
-
-### Invalid Items (for error testing)
-- Whopper (Burger King)
-- Baconator (Wendy's)
-- "Pizza" (not on menu)
-
----
-
-## Implementation Guidelines
-
-### Given/When/Then Structure
-
-**Given**: Set up the initial state
-- Agent state (greeted, mid-order, etc.)
-- Existing order contents
-- Session context
-
-**When**: The action/input
-- Customer utterance (what they say)
-- Should be realistic voice input
-
-**Then**: Expected outcomes
-- Agent response (tone, content)
-- Order state (what's in the order file)
-- File system state (what files exist)
-
-### Assertion Types
-
-#### Agent Response Assertions (Behavioral)
-```gherkin
-Then the agent confirms "one Big Mac"
-Then the agent asks if the customer wants anything else
-Then the agent politely informs the customer
-Then the agent reads back the complete order
-```
-
-#### Order State Assertions (Observable)
-```gherkin
-Then the order file contains 3 items
-Then the order file shows "Big Mac" in category "Beef & Pork"
-Then one line item has quantity 2
-Then the order file does not contain "fries"
-```
-
-#### Avoid Implementation Assertions (Internal)
-```gherkin
-# âŒ Don't do this (implementation detail)
-Then the OrderStateManager.add_item was called
-Then the fuzzy_match_item function returned 0.95
-Then the DriveThruLLM injected menu context
-
-# âœ“ Do this instead (observable behavior)
-Then the order file contains "Big Mac"
-Then the agent confirms the item
-Then the order is recorded correctly
-```
-
----
-
-## BDD Test Execution
-
-### Step Definition Categories
-
-1. **Setup Steps** (Given)
-   - `Given the agent greets the customer`
-   - `Given the agent has confirmed "Big Mac" and "fries"`
-   - `Given the customer is mid-order`
-
-2. **Action Steps** (When)
-   - `When the customer says "{utterance}"`
-   - `When the customer says "that's all"`
-   - `When the agent reads back the order`
-
-3. **Verification Steps** (Then)
-   - `Then the agent confirms "{item}"`
-   - `Then the order file contains {n} items`
-   - `Then the order file shows "{item}" in category "{category}"`
-   - `Then the JSON file has correct quantities`
-
-### Judge-Based Assertions
-
-For natural language responses, use LLM judge:
-
-```python
-@then('the agent confirms "one Big Mac"')
-def verify_agent_confirmation(context):
-    # Use judge to verify intent, not exact wording
-    await result.expect.next_event().is_message(role="assistant").judge(
-        judge_llm,
-        intent="Confirms that one Big Mac was added and asks if customer wants more"
-    )
-```
-
-### File System Assertions
-
-For order files, use direct JSON comparison:
-
-```python
-@then('the order file contains {n:d} items')
-def verify_order_count(context, n):
-    order = load_order_json(context.session_id)
-    assert len(order['items']) == n
-```
-
----
-
-## Continuous Testing Strategy
-
-### Test Pyramid for BDD Scenarios
-
-```
-        /\
-       /  \      E2E BDD Scenarios (~18 scenarios)
-      /____\     Full voice pipeline, judge-based
-     /      \
-    /        \   Integration Tests (~30 tests)
-   /__________\  Component interactions, mocked LLM
-  /            \
- /              \ Unit Tests (~100+ tests)
-/________________\ Pure functions, data models
-```
-
-### When to Run
-
-- **On every commit**: Priority 1 scenarios (smoke tests)
-- **On PR**: Priority 1 + Priority 2 scenarios
-- **Nightly**: Full suite including edge cases
-- **Before release**: Full suite + manual exploratory testing
-
-### Success Criteria
-
-- **All Priority 1 scenarios pass**: Required for merge
-- **95%+ Priority 2 pass rate**: Required for release
-- **Zero regressions**: New features don't break existing scenarios
-
----
-
-## Example: Complete Feature File
-
-Here's what a complete feature file would look like:
-
-```gherkin
-# tests/features/agent/01_basic_ordering.feature
-
-@voice-agent @order-taking @priority-1
-Feature: Basic Single-Item Ordering
-  As a McDonald's customer
-  I want to order a single menu item
-  So that I can quickly get my food
-
-  Background:
-    Given the McDonald's menu is loaded
-    And the agent is ready to take orders
-
-  @smoke
-  Scenario: Order a Big Mac
-    Given the agent greets the customer
-    When the customer says "I'll have a Big Mac"
-    Then the agent confirms "one Big Mac"
-    And the agent asks if the customer wants anything else
-    When the customer says "that's all"
-    Then the agent reads back the complete order
-    And a final order JSON file is created
-    And the order file contains 1 item
-    And the order file shows "Big Mac" in category "Beef & Pork"
-    And the item has quantity 1
-    And the item has no modifiers
-
-  @quantities
-  Scenario: Order multiple Big Macs
-    Given the agent greets the customer
-    When the customer says "Two Big Macs please"
-    Then the agent confirms "two Big Macs"
-    And the agent asks if the customer wants anything else
-    When the customer says "no thanks"
-    Then the order file contains 1 line item
-    And the line item has quantity 2
-
-  @breakfast
-  Scenario: Order breakfast item
-    Given the agent greets the customer
-    When the customer says "I'd like an Egg McMuffin"
-    Then the agent confirms "one Egg McMuffin"
-    When the customer says "that's it"
-    Then the order file shows "Egg McMuffin" in category "Breakfast"
-```
-
----
-
-## Key Takeaways
-
-1. **Test Behavior, Not Implementation**: Focus on what customers experience
-2. **Minimal but Comprehensive**: 18 scenarios cover all critical paths
-3. **Priority-Based**: Start with 8 smoke tests, expand to 18 for full coverage
-4. **Implementation-Agnostic**: Tests survive architecture refactoring
-5. **Realistic**: Use natural customer language, not technical terms
-6. **Observable**: Assert on files, responses, and end-user visible state
-7. **Maintainable**: Clear structure, reusable steps, good organization
-
----
-
-## Next Steps
-
-1. **Review this strategy** with the team
-2. **Write actual feature files** following the examples above
-3. **Implement step definitions** for Given/When/Then steps
-4. **Set up test data** (menu JSON, invalid items)
-5. **Configure test runner** (pytest-bdd or behave)
-6. **Run Priority 1** scenarios to validate approach
-7. **Iterate** based on real test results
-8. **Expand** to Priority 2 and Priority 3 as needed
-
-This BDD testing strategy ensures the McDonald's Drive-Thru Agent behaves correctly from a customer perspective, regardless of internal implementation details.
diff --git a/plan/thoughts/drive-thru-llm/mcdonalds-drive-thru-agent-plan.md b/plan/thoughts/drive-thru-llm/mcdonalds-drive-thru-agent-plan.md
deleted file mode 100644
index cbd66c9..0000000
--- a/plan/thoughts/drive-thru-llm/mcdonalds-drive-thru-agent-plan.md
+++ /dev/null
@@ -1,1619 +0,0 @@
-# McDonald's Drive-Thru Order Taker Agent - Implementation Plan
-
-**Created**: 2026-01-21
-**Status**: Planning Phase
-**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders
-
----
-
-## Executive Summary
-
-This plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.
-
----
-
-## 0. Clean Architecture Principles (Kent Beck + Dave Farley)
-
-This implementation follows clean architecture principles for maintainability, testability, and continuous delivery.
-
-### Core Principles Checklist
-
-**âœ“ Single Responsibility Principle (SRP)**
-- Each component has one reason to change
-- DriveThruLLM: Context injection only (no state)
-- OrderStateManager: State + persistence only
-- MenuProvider: Read-only data access only
-- menu_validation.py: Pure validation functions only
-
-**âœ“ Dependency Inversion**
-- Components receive dependencies via constructor (DI)
-- High-level components don't depend on low-level details
-- Easy to mock, easy to test, easy to swap
-
-**âœ“ Pure Functions Where Possible**
-- menu_validation.py: 100% pure functions
-- No I/O, no side effects, fully deterministic
-- Fast, testable, reusable
-
-**âœ“ Immutability Reduces Bugs**
-- MenuProvider returns immutable data
-- Menu cannot be accidentally corrupted
-- Thread-safe by design
-
-**âœ“ Single Source of Truth**
-- OrderStateManager is ONLY owner of order state
-- All mutations flow through one place
-- Easy to debug, easy to audit, easy to test
-
-**âœ“ Tell, Don't Ask**
-- Tools tell OrderStateManager what to do
-- Don't query state, mutate it, then write back
-- Reduces coupling, increases cohesion
-
-**âœ“ Test Pyramid**
-- Many fast unit tests (milliseconds)
-- Some integration tests (seconds)
-- Few E2E tests (minutes)
-- Fast feedback loops enable TDD
-
-**âœ“ Make Invalid States Unrepresentable**
-- Use type system + schemas to prevent errors
-- Function calling enforces structure
-- Validation happens before state mutation
-
-### Boundary Rules
-
-| Component | Can Access | Cannot Access |
-|-----------|-----------|---------------|
-| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |
-| `MenuProvider` | Menu JSON file | Order state, LLM |
-| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |
-| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |
-| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |
-| `DriveThruAgent` | Everything (orchestrator) | N/A |
-
-**Dependency Flow** (always downward, never circular):
-```
-DriveThruAgent
-    â”œâ”€> OrderStateManager
-    â”œâ”€> MenuProvider
-    â”œâ”€> OrderTools
-    â”‚       â”œâ”€> menu_validation.py
-    â”‚       â”œâ”€> OrderStateManager
-    â”‚       â””â”€> MenuProvider
-    â””â”€> DriveThruLLM
-            â””â”€> MenuProvider
-```
-
-### Testing Strategy
-
-**Unit Tests** (Fast, isolated, many)
-- `test_menu_validation.py`: Pure functions, no mocks needed
-- `test_menu_provider.py`: Test with fixture JSON
-- `test_order_state.py`: In-memory state, temp file I/O
-- `test_drive_thru_llm.py`: Mock wrapped LLM
-
-**Integration Tests** (Medium speed, some mocks)
-- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager
-
-**E2E Tests** (Slow, real components, few)
-- `test_drive_thru_agent.py`: Full agent with judge-based evaluation
-- `test_accuracy.py`: Accuracy benchmarks
-
-**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.
-
----
-
-## 1. System Architecture
-
-### 1.1 Core Components & Data Flow
-
-```
-Customer Voice Input
-    â†“
-[STT] â†’ AssemblyAI Universal Streaming
-    â†“
-[AgentSession with DriveThruLLM wrapper]
-    â”‚
-    â”œâ”€> DriveThruLLM.chat()
-    â”‚   â”œâ”€ Queries MenuProvider for context
-    â”‚   â”œâ”€ Injects menu context into chat_ctx
-    â”‚   â””â”€ Delegates to Base LLM (OpenAI GPT-4.1)
-    â”‚
-    â”œâ”€> Base LLM outputs function call â†’ add_item_to_order(...)
-    â”‚
-    â”œâ”€> OrderTools.add_item_to_order()
-    â”‚   â”œâ”€ Calls menu_validation.validate_item() [pure function]
-    â”‚   â”œâ”€ If valid: OrderStateManager.add_item() [state mutation]
-    â”‚   â”‚   â””â”€ OrderStateManager appends to incremental log
-    â”‚   â””â”€ Returns result to LLM
-    â”‚
-    â””â”€> LLM generates response text
-    â†“
-[TTS] â†’ Inworld/Cartesia
-    â†“
-Agent Voice Response
-
-
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚ Dependency Diagram (Composition, not inheritance)  â”‚
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-
-VoiceAgentApp
-    â”‚
-    â”œâ”€> Creates: DriveThruAgent (owns conversation)
-    â”‚        â”‚
-    â”‚        â”œâ”€> Owns: OrderStateManager (mutable state)
-    â”‚        â”‚
-    â”‚        â”œâ”€> Receives: MenuProvider (read-only data)
-    â”‚        â”‚
-    â”‚        â””â”€> Registers: OrderTools (coordination layer)
-    â”‚                  â”‚
-    â”‚                  â”œâ”€> Uses: menu_validation.py (pure functions)
-    â”‚                  â”‚
-    â”‚                  â”œâ”€> Calls: OrderStateManager (state mutations)
-    â”‚                  â”‚
-    â”‚                  â””â”€> Queries: MenuProvider (data access)
-    â”‚
-    â”œâ”€> Creates: DriveThruLLM (wraps base LLM)
-    â”‚        â”‚
-    â”‚        â””â”€> Queries: MenuProvider (for context injection)
-    â”‚
-    â””â”€> Loads: MenuProvider (singleton, immutable)
-
-
-Key Principles:
-- MenuProvider: Read-only, queried by many
-- OrderStateManager: Write-heavy, single owner (DriveThruAgent)
-- menu_validation.py: Pure functions, no dependencies
-- DriveThruLLM: Stateless wrapper, delegates to base LLM
-- OrderTools: Thin coordination layer, receives dependencies
-```
-
-### 1.2 New Components to Build
-
-Each component has a single, well-defined responsibility following the Single Responsibility Principle.
-
-#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)
-**Responsibility**: Pure LLM wrapper - context injection only
-**Does**:
-- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)
-- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`
-- Delegates to wrapped LLM
-- Returns LLM stream
-
-**Does NOT**:
-- Manage order state (that's `OrderStateManager`)
-- Store any state (stateless wrapper)
-- Validate menu items (that's `menu_validation.py`)
-- Perform searches (that's `MenuProvider`)
-
-**Why**: Separation of concerns - LLM wrapping is orthogonal to state management
-
----
-
-#### 2. **MenuProvider** (`src/menu_provider.py`)
-**Responsibility**: Read-only menu data access
-**Does**:
-- Loads menu data from JSON using existing Pydantic models
-- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`
-- Returns menu data structures (immutable)
-
-**Does NOT**:
-- Modify menu data (read-only)
-- Validate orders (that's `menu_validation.py`)
-- Manage order state (that's `OrderStateManager`)
-- Fuzzy match (that's `menu_validation.py`)
-
-**Why**: Single source of truth for menu data, but purely a data provider
-
----
-
-#### 3. **OrderStateManager** (`src/order_state_manager.py`)
-**Responsibility**: Single source of truth for order state and persistence
-**Does**:
-- Owns ALL order state (items, quantities, session info)
-- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`
-- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`
-- Handles persistence: incremental log (append after each operation), final JSON (on complete)
-- Manages session lifecycle
-
-**Does NOT**:
-- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)
-- Search menu (that's `MenuProvider`)
-- Make decisions (it's told what to do)
-
-**Why**: All state changes go through one place - testable, debuggable, single source of truth
-
----
-
-#### 4. **menu_validation.py** (`src/menu_validation.py`)
-**Responsibility**: Pure validation and matching functions
-**Does**:
-- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`
-- Fuzzy string matching using `rapidfuzz`
-- Returns validation results (success/failure with details)
-
-**Does NOT**:
-- Store state (pure functions only)
-- Load menu data (receives menu data as parameter)
-- Modify orders (just validates, doesn't change state)
-
-**Why**: Pure functions are maximally testable and reusable
-
----
-
-#### 5. **OrderTools** (`src/tools/order_tools.py`)
-**Responsibility**: LiveKit Tool definitions for LLM function calling
-**Does**:
-- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)
-- Defines `complete_order` tool
-- Thin wrappers that orchestrate: validate â†’ add to order state â†’ return result
-- Receives `OrderStateManager` and `MenuProvider` as dependencies
-
-**Does NOT**:
-- Own state (receives OrderStateManager)
-- Implement validation logic (calls menu_validation.py)
-
-**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic
-
----
-
-#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)
-**Responsibility**: Agent orchestration and configuration
-**Does**:
-- Defines agent instructions/persona (system prompt)
-- Owns `OrderStateManager` instance (via composition)
-- Registers tools with agent (passing OrderStateManager as dependency)
-- Coordinates conversation flow
-
-**Does NOT**:
-- Manage state directly (delegates to OrderStateManager)
-- Validate items (delegates to validation layer via tools)
-- Load menu (receives MenuProvider as dependency)
-
-**Why**: Agent is the conductor - it orchestrates but delegates actual work
-
----
-
-## 1.3 Component Contracts (Interfaces)
-
-Following the Interface Segregation Principle, here are the explicit contracts for each component.
-
-### MenuProvider Interface
-```python
-class MenuProvider:
-    """Read-only menu data provider."""
-
-    def __init__(self, menu_file_path: str) -> None:
-        """Load menu from JSON file."""
-
-    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:
-        """Search for items by keyword, optionally filtered by category."""
-
-    def get_category(self, category_name: str) -> list[Item]:
-        """Get all items in a category."""
-
-    def get_item(self, category_name: str, item_name: str) -> Item | None:
-        """Get a specific item by category and name."""
-
-    def get_all_categories(self) -> list[str]:
-        """Get list of all category names."""
-
-    def get_menu(self) -> Menu:
-        """Get the complete menu (immutable)."""
-```
-
-### OrderStateManager Interface
-```python
-@dataclass
-class OrderItem:
-    """A single item in an order."""
-    item_name: str
-    category: str
-    modifiers: list[str]
-    quantity: int
-    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))
-    timestamp: datetime = field(default_factory=datetime.now)
-
-
-class OrderStateManager:
-    """Single source of truth for order state and persistence."""
-
-    def __init__(self, session_id: str, output_dir: str) -> None:
-        """Initialize order state for a session."""
-
-    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:
-        """Add item to order. Returns the created OrderItem. Appends to incremental log."""
-
-    def remove_item(self, item_id: str) -> bool:
-        """Remove item by ID. Returns True if found and removed."""
-
-    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:
-        """Update quantity for an item. Returns True if found and updated."""
-
-    def get_items(self) -> list[OrderItem]:
-        """Get all items in current order (read-only copy)."""
-
-    def get_total_count(self) -> int:
-        """Get total number of items (accounting for quantities)."""
-
-    def get_order_summary(self) -> str:
-        """Get human-readable order summary."""
-
-    def complete_order(self) -> dict:
-        """Mark order complete and generate final JSON. Returns final order dict."""
-
-    def clear_order(self) -> None:
-        """Clear all items (for cancellation/restart)."""
-```
-
-### menu_validation Module (Pure Functions)
-```python
-@dataclass
-class ValidationResult:
-    """Result of a validation operation."""
-    is_valid: bool
-    matched_item: Item | None = None
-    confidence_score: float = 0.0
-    error_message: str | None = None
-
-
-def fuzzy_match_item(
-    item_name: str,
-    menu_items: list[Item],
-    threshold: int = 85
-) -> ValidationResult:
-    """Fuzzy match an item name against menu items. Returns best match if above threshold."""
-
-
-def validate_item_exists(
-    item_name: str,
-    category: str,
-    menu_provider: MenuProvider
-) -> ValidationResult:
-    """Validate that an item exists in the specified category."""
-
-
-def validate_modifiers(
-    item: Item,
-    requested_modifiers: list[str],
-    fuzzy_threshold: int = 85
-) -> ValidationResult:
-    """Validate that all requested modifiers are available for the item."""
-
-
-def validate_order_item(
-    item_name: str,
-    category: str,
-    modifiers: list[str],
-    menu_provider: MenuProvider,
-    fuzzy_threshold: int = 85
-) -> ValidationResult:
-    """Complete validation: item exists + modifiers valid. Convenience function."""
-```
-
-### OrderTools (LiveKit Tool Definitions)
-```python
-def create_order_tools(
-    order_state: OrderStateManager,
-    menu_provider: MenuProvider,
-    config: DriveThruConfig
-) -> list[Tool]:
-    """Create LiveKit Tool instances with dependencies injected.
-
-    Returns:
-        List of Tool objects that can be registered with an Agent
-    """
-
-    # Tool 1: add_item_to_order
-    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}
-    # Behavior: validate â†’ add to state â†’ return confirmation
-
-    # Tool 2: complete_order
-    # Schema: {}
-    # Behavior: complete order â†’ return summary
-```
-
-### DriveThruLLM Interface
-```python
-class DriveThruLLM(LLM):
-    """Stateless LLM wrapper that injects menu context."""
-
-    def __init__(
-        self,
-        wrapped_llm: LLM,
-        menu_provider: MenuProvider,
-        config: DriveThruConfig
-    ) -> None:
-        """Initialize wrapper with dependencies."""
-
-    def chat(
-        self,
-        *,
-        chat_ctx: ChatContext,
-        tools: list[Tool] | None = None,
-        **kwargs
-    ) -> LLMStream:
-        """Intercept chat to inject menu context, then delegate to wrapped LLM."""
-        # 1. Extract keywords from latest user message
-        # 2. Query MenuProvider for relevant items
-        # 3. Inject into chat_ctx as system message or augment existing prompt
-        # 4. Delegate to wrapped_llm.chat()
-```
-
-### DriveThruAgent
-```python
-class DriveThruAgent(Agent):
-    """Drive-thru order taking agent."""
-
-    def __init__(
-        self,
-        order_state: OrderStateManager,
-        menu_provider: MenuProvider,
-        config: DriveThruConfig
-    ) -> None:
-        """Initialize agent with dependencies.
-
-        - Sets instructions/persona
-        - Registers order tools
-        - Owns OrderStateManager
-        """
-```
-
-**Design Principles Applied**:
-1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them
-2. **Interface Segregation**: Each interface is minimal and focused
-3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator
-4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable
-5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate
-6. **Single Source of Truth**: All order state lives in OrderStateManager
-
----
-
-## 2. Accuracy-Boosting Strategies
-
-### Priority 1: Core Strategies (Implement First)
-
-#### Strategy 1: LLM Function Calling / Structured Output
-**Approach**: Define tools/functions that the LLM can call to add items to the order.
-
-**Implementation**:
-- Create `add_item_to_order` function with parameters:
-  - `category` (enum from menu categories)
-  - `item_name` (string)
-  - `modifiers` (list of strings)
-  - `quantity` (int, default 1)
-- LLM must use this function instead of free-form text
-- Validates parameters against menu before accepting
-
-**Pros**:
-- Structured, parseable output
-- Forces LLM to think in terms of menu structure
-- Easy to validate
-
-**Cons**:
-- Requires LLM with good function calling support
-- May feel less natural for complex orders
-
-**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors
-
----
-
-#### Strategy 2: Menu Context Injection
-**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.
-
-**Implementation**:
-- When customer speaks, extract keywords (e.g., "burger", "breakfast", "coffee")
-- Fetch relevant menu items from Menu model
-- Include in system prompt: "Available items: [filtered list]"
-- Reduces hallucination by showing exact menu item names
-
-**Example**:
-```
-Customer: "I'd like a Big Mac"
-â†’ Inject into context: "Beef & Pork items: Big Mac, McDouble, Quarter Pounder..."
-```
-
-**Pros**:
-- Reduces hallucination
-- Helps with exact item name matching
-- Context-aware
-
-**Cons**:
-- Increases token usage
-- May miss items if keyword matching fails
-
-**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu
-
----
-
-#### Strategy 3: Explicit Confirmation Loop
-**Approach**: After each item is understood, explicitly confirm with customer.
-
-**Implementation**:
-- After LLM extracts an item, respond: "Got it, one Big Mac. Anything else?"
-- Customer can correct if wrong
-- Only write to order file after confirmation
-
-**Example Flow**:
-```
-Customer: "Big Mac please"
-Agent: "One Big Mac - is that correct?"
-Customer: "Yes"
-Agent: "Great! Anything else?"
-[Write to order file]
-```
-
-**Pros**:
-- Allows error correction
-- Builds customer confidence
-- Simple to implement
-
-**Cons**:
-- Slower ordering process
-- May annoy customers with simple orders
-
-**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation
-
----
-
-#### Strategy 4: Fuzzy String Matching
-**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.
-
-**Implementation**:
-- Use `rapidfuzz` or `fuzzywuzzy` library
-- When LLM outputs an item name, fuzzy match against menu
-- Accept if confidence > 85%
-- Handle common variations:
-  - "Big Mac" vs "big mac" vs "bigmac" vs "Big Mack"
-  - "McNuggets" vs "chicken nuggets" vs "nuggets"
-
-**Example**:
-```python
-from rapidfuzz import process, fuzz
-
-def find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:
-    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)
-    return result[0], result[1]  # item, confidence_score
-```
-
-**Pros**:
-- Handles STT errors
-- Tolerates variations
-- Fast and deterministic
-
-**Cons**:
-- Can match wrong items if names are similar
-- Requires confidence threshold tuning
-
-**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors
-
----
-
-### Priority 2: Advanced Strategies (Implement Later for Optimization)
-
-#### Strategy 5: Semantic Search with Embeddings
-**Approach**: Use embeddings to find semantically similar menu items.
-
-**Implementation**:
-- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)
-- Store in vector DB or in-memory
-- When customer speaks, embed their utterance
-- Find nearest neighbors in embedding space
-- Use as candidates for LLM to choose from
-
-**Pros**:
-- Handles synonyms ("cheeseburger" â†’ "Quarter Pounder with Cheese")
-- Semantic understanding
-- Robust to paraphrasing
-
-**Cons**:
-- More complex implementation
-- Requires embedding API calls
-- May introduce latency
-
-**Accuracy Impact**: HIGH (8/10) - Semantic understanding
-
----
-
-#### Strategy 6: Two-Stage Parsing
-**Approach**: Separate intent extraction from menu item selection.
-
-**Implementation**:
-1. **Stage 1**: Extract customer intent
-   - "I want a burger with cheese"
-   - Intent: {type: burger, modifiers: [cheese]}
-2. **Stage 2**: Match intent to menu items
-   - Search menu for burgers with cheese modifier
-   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]
-3. **Stage 3**: LLM selects best match or asks clarifying question
-
-**Pros**:
-- Cleaner separation of concerns
-- Can optimize each stage separately
-- Better debuggability
-
-**Cons**:
-- More complex
-- Additional latency from multiple stages
-
-**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach
-
----
-
-#### Strategy 7: Chain-of-Thought Prompting
-**Approach**: Ask LLM to explain its reasoning before outputting.
-
-**Implementation**:
-```
-System: When a customer orders, think step-by-step:
-1. What type of item are they requesting? (burger, drink, breakfast, etc.)
-2. Which specific item from our menu matches best?
-3. Did they mention any modifiers?
-4. What quantity?
-Then output the structured order.
-```
-
-**Pros**:
-- Improves LLM reasoning
-- More interpretable
-- Can catch logic errors
-
-**Cons**:
-- Increases token usage
-- May add latency
-- Reasoning not always visible to customer
-
-**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly
-
----
-
-#### Strategy 8: Constrained Decoding
-**Approach**: Use grammar-based constrained generation (if LLM supports it).
-
-**Implementation**:
-- Define grammar for valid responses
-- LLM can only output strings that match the grammar
-- Grammar includes exact menu item names
-
-**Example Grammar**:
-```
-ORDER := <ITEM> | <ITEM> "and" <ORDER>
-ITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>
-MENU_ITEM := "Big Mac" | "Quarter Pounder" | ...
-```
-
-**Pros**:
-- Guarantees valid output
-- No hallucination possible
-- Perfect accuracy for item names
-
-**Cons**:
-- Very few LLMs support this
-- Complex to implement
-- May be too rigid
-
-**Accuracy Impact**: VERY HIGH (9/10) - If available
-
----
-
-#### Strategy 9: Post-Processing Validation Layer
-**Approach**: Validate every LLM output against menu before mutating order state.
-
-**Implementation**: Pure function in `menu_validation.py`
-```python
-def validate_order_item(
-    item_name: str,
-    category: str,
-    modifiers: list[str],
-    menu_provider: MenuProvider,
-    fuzzy_threshold: int = 85
-) -> ValidationResult:
-    """Pure function: check item exists + modifiers valid."""
-    # Check item exists in menu
-    # Check modifiers are valid for that item
-    # Return ValidationResult with matched item or error
-```
-
-**Component Ownership**: `menu_validation.py` (pure functions)
-
-**Pros**:
-- Last line of defense
-- Can auto-correct minor errors
-- Prevents invalid orders
-
-**Cons**:
-- Reactive, not proactive
-- May reject valid variations
-
-**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net
-
----
-
-#### Strategy 10: Context Window Optimization
-**Approach**: Only include relevant portions of menu in context.
-
-**Implementation**:
-- Detect if customer is ordering breakfast, lunch, drinks, etc.
-- Only inject that category's items into prompt
-- Reduces noise and token count
-- Improves focus
-
-**Example**:
-```
-Customer: "I want breakfast"
-â†’ Only include Breakfast category items in context
-```
-
-**Pros**:
-- Reduces token usage
-- Reduces hallucination
-- Faster inference
-
-**Cons**:
-- May miss cross-category orders
-- Requires intent detection
-
-**Accuracy Impact**: MEDIUM (6/10) - Helps focus
-
----
-
-### Recommended Strategy Combination & Component Ownership
-
-Each strategy is owned by a specific component, following SRP.
-
-**Phase 1 (MVP)**:
-1. **Function Calling** (Strategy 1)
-   - Owner: `OrderTools` (defines tool schemas)
-   - Core structure for order taking
-
-2. **Menu Context Injection** (Strategy 2)
-   - Owner: `DriveThruLLM` (injects context in chat())
-   - Grounding LLM in actual menu
-
-3. **Fuzzy String Matching** (Strategy 4)
-   - Owner: `menu_validation.py` (pure function)
-   - STT error handling
-
-4. **Post-Processing Validation** (Strategy 9)
-   - Owner: `OrderTools` (validates before state mutation)
-   - Safety net - validate before add_item()
-
-**Phase 2 (Optimization)**:
-5. **Explicit Confirmation Loop** (Strategy 3)
-   - Owner: `DriveThruAgent` (instructions/conversation flow)
-   - User validation
-
-6. **Semantic Search** (Strategy 5)
-   - Owner: `MenuProvider` (add embedding-based search method)
-   - Better matching via semantics
-
-**Phase 3 (Advanced)**:
-7. **Two-Stage Parsing** (Strategy 6)
-   - Owner: `OrderTools` (modify tool implementation)
-   - If needed for complex orders
-
-8. **Chain-of-Thought** (Strategy 7)
-   - Owner: `DriveThruAgent` (modify instructions)
-   - If needed for better reasoning
-
-**Key Insight**: Each strategy lives in exactly one component. This:
-- Makes it easy to A/B test strategies (change one component)
-- Enables independent testing of strategies
-- Prevents strategy logic from leaking across boundaries
-
----
-
-## 3. Order State Management
-
-### 3.1 Order State Model
-
-```python
-@dataclass
-class OrderItem:
-    item_name: str
-    category: str
-    modifiers: list[str]
-    quantity: int
-    timestamp: datetime
-    confirmed: bool = False
-
-@dataclass
-class OrderSession:
-    session_id: str
-    start_time: datetime
-    items: list[OrderItem]
-    status: Literal["in_progress", "completed", "cancelled"]
-```
-
-### 3.2 Incremental Logging
-
-After each customer turn where an item is added:
-- Append to `orders/{session_id}/incremental_log.jsonl`
-- Each line is a JSON object with:
-  - `timestamp`
-  - `customer_utterance`
-  - `item_parsed`
-  - `agent_response`
-
-### 3.3 Final Output
-
-When customer says "done" or "that's all":
-- Generate `orders/{session_id}/final_order.json`:
-
-```json
-{
-  "session_id": "uuid-here",
-  "timestamp": "2026-01-21T14:30:00Z",
-  "items": [
-    {
-      "item_name": "Big Mac",
-      "category": "Beef & Pork",
-      "modifiers": [],
-      "quantity": 1
-    },
-    {
-      "item_name": "Medium Fries",
-      "category": "Snacks & Sides",
-      "modifiers": [],
-      "quantity": 1
-    }
-  ],
-  "total_items": 2,
-  "order_summary": "1 Big Mac, 1 Medium Fries"
-}
-```
-
-### 3.4 Menu Model Enhancements
-
-To support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:
-
-#### 3.4.1 New Fields
-
-1. **quantity field** (`int`, default=1)
-   - Tracks how many of this item are in the order
-   - Default value is 1 for single items
-   - Used for aggregating duplicate items
-
-2. **item_id field** (`str`)
-   - Unique identifier for each item instance
-   - Auto-generated UUID to distinguish between item instances
-   - Allows tracking individual items even with same name and modifiers
-
-#### 3.4.2 Item Addition (`__add__` method)
-
-Implements addition operator for combining items. Two items can be added if and only if:
-
-**Conditions**:
-- `item1.item_name == item2.item_name` (exact name match)
-- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)
-
-**Behavior**:
-- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`
-- If conditions are not met: Raise `ValueError` with descriptive message
-
-**Example Usage**:
-```python
-# Create two identical Big Macs
-item1 = Item(
-    category_name="Beef & Pork",
-    item_name="Big Mac",
-    available_as_base=True,
-    quantity=1
-)
-
-item2 = Item(
-    category_name="Beef & Pork",
-    item_name="Big Mac",
-    available_as_base=True,
-    quantity=2
-)
-
-# Add them together
-combined = item1 + item2  # quantity=3
-
-# Items with different modifiers cannot be added
-item3 = Item(
-    category_name="Beef & Pork",
-    item_name="Big Mac",
-    available_as_base=True,
-    quantity=1
-)
-item3.add_modifier("No Pickles")
-
-# This will raise ValueError
-combined = item1 + item3  # Error! Different modifiers
-```
-
-**Implementation Notes**:
-- Modifier comparison uses set equality, so order doesn't matter
-- The new combined item gets a new `item_id`
-- Original items remain unchanged
-- This enables order consolidation: "Two Big Macs" + "One Big Mac" = "Three Big Macs"
-
----
-
-## 4. Agent Instructions & Persona
-
-### 4.1 System Prompt
-
-```
-You are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:
-
-1. Greet the customer warmly
-2. Listen carefully to their order
-3. Use the add_item_to_order function to record each item
-4. Confirm each item with the customer
-5. When they're done, read back their complete order
-6. Thank them and tell them the total
-
-Guidelines:
-- Be concise and natural in your responses
-- If you're unsure about an item, ask for clarification
-- Always confirm items before adding to the order
-- Use the exact menu item names when confirming
-- If a customer mentions an item not on the menu, politely inform them
-
-Menu Structure:
-- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes
-- 212 total items
-- Some items have modifiers (e.g., "Quarter Pounder" with "Cheese")
-```
-
-### 4.2 Conversation Flow
-
-```
-Agent: "Welcome to McDonald's! What can I get for you today?"
-
-Customer: "I'll have a Big Mac"
-
-Agent: [Calls add_item_to_order(category="Beef & Pork", item_name="Big Mac", quantity=1)]
-      "Got it, one Big Mac. Anything else?"
-
-Customer: "And a medium fries"
-
-Agent: [Calls add_item_to_order(category="Snacks & Sides", item_name="Medium Fries", quantity=1)]
-      "One medium fries. Anything else?"
-
-Customer: "No, that's all"
-
-Agent: "Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].
-       Please pull around to the first window."
-       [Writes final order JSON]
-```
-
----
-
-## 5. Testing Strategy
-
-### 5.1 Test Categories
-
-1. **Single Item Orders**
-   - Simple: "I want a Big Mac"
-   - With quantity: "Two cheeseburgers"
-   - With modifiers: "Quarter Pounder with cheese"
-
-2. **Multi-Item Orders**
-   - "Big Mac, large fries, and a Coke"
-   - "Two Big Macs, one with no pickles"
-
-3. **Complex Orders**
-   - "I want a number 1 with a Coke" (if meal combos are supported)
-   - Orders with substitutions
-   - Orders with special requests
-
-4. **Error Handling**
-   - Invalid items: "I want a Whopper" (Burger King item)
-   - Unclear requests: "I want a burger"
-   - Corrections: "Actually, make that a McDouble"
-
-5. **Accuracy Tests**
-   - STT variations: "Big Mack" â†’ "Big Mac"
-   - Synonym handling: "chicken nuggets" â†’ "Chicken McNuggets"
-   - Modifier accuracy: Did modifiers get applied correctly?
-
-### 5.2 Test Implementation
-
-```python
-@pytest.mark.asyncio
-async def test_single_item_order_accuracy() -> None:
-    """Test that a simple single-item order is captured accurately."""
-    async with (
-        _llm() as judge_llm,
-        AgentSession(llm=drive_thru_llm) as session,
-    ):
-        await session.start(DriveThruAgent())
-
-        # Customer orders a Big Mac
-        result = await session.run(user_input="I'll have a Big Mac")
-
-        # Verify the agent called the add_item_to_order function
-        result.expect.next_event().is_function_call(
-            function_name="add_item_to_order",
-            arguments={
-                "category": "Beef & Pork",
-                "item_name": "Big Mac",
-                "quantity": 1,
-                "modifiers": []
-            }
-        )
-
-        # Verify the agent confirmed the item
-        await (
-            result.expect.next_event()
-            .is_message(role="assistant")
-            .judge(
-                judge_llm,
-                intent="Confirms that one Big Mac was added to the order and asks if the customer wants anything else"
-            )
-        )
-
-        # End the order
-        result = await session.run(user_input="That's all")
-
-        # Verify final order JSON was created correctly
-        assert order_manager.get_final_order() == {
-            "items": [
-                {"item_name": "Big Mac", "category": "Beef & Pork", "modifiers": [], "quantity": 1}
-            ]
-        }
-```
-
-### 5.3 Accuracy Metrics
-
-Track the following metrics:
-- **Item Name Accuracy**: % of items correctly identified
-- **Modifier Accuracy**: % of modifiers correctly applied
-- **Quantity Accuracy**: % of quantities correctly captured
-- **Order Completeness**: % of orders with all items captured
-- **False Positives**: Items added that weren't ordered
-- **False Negatives**: Items ordered but not added
-
-Target: 95%+ accuracy on all metrics
-
----
-
-## 6. Implementation Phases
-
-### Phase 1: Core Infrastructure (Build from bottom up, test-first)
-
-**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.
-
-#### Step 1.1: Menu Models & Validation (No dependencies)
-- [ ] Enhance `Item` class with `quantity` field (default=1)
-- [ ] Enhance `Item` class with `item_id` field (UUID)
-- [ ] Implement `__add__` method for `Item` class
-- [ ] Write unit tests for `Item` enhancements
-  - Test addition with same modifiers
-  - Test addition failure with different modifiers
-  - Test quantity field defaults
-
-#### Step 1.2: Pure Functions (No dependencies)
-- [ ] Implement `menu_validation.py` with pure functions
-  - `fuzzy_match_item()`
-  - `validate_item_exists()`
-  - `validate_modifiers()`
-  - `validate_order_item()`
-- [ ] Write comprehensive unit tests for validation functions
-  - Fast, deterministic, no I/O
-  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches
-
-#### Step 1.3: Read-Only Data Provider (Depends on: Item models)
-- [ ] Implement `MenuProvider` class
-  - Constructor loads JSON
-  - `search_items()`, `get_category()`, `get_item()`
-  - All methods return immutable data
-- [ ] Write unit tests for MenuProvider
-  - Use fixture JSON file
-  - Test search, category queries, item lookups
-  - Verify immutability (mutations don't affect provider)
-
-#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)
-- [ ] Define `OrderItem` dataclass
-- [ ] Implement `OrderStateManager` class
-  - `add_item()`, `remove_item()`, `update_item_quantity()`
-  - `get_items()`, `get_total_count()`, `get_order_summary()`
-  - `complete_order()`, `clear_order()`
-  - Incremental logging (append to JSONL after each mutation)
-  - Final JSON generation
-- [ ] Write unit tests for OrderStateManager
-  - Test in-memory state operations (fast)
-  - Test file I/O separately (use temp directory)
-  - Verify incremental log appends correctly
-  - Verify final JSON structure
-
-#### Step 1.5: Verify Boundaries
-- [ ] Ensure MenuProvider has no mutable state
-- [ ] Ensure OrderStateManager is single source of truth
-- [ ] Ensure validation functions are pure (no I/O, no side effects)
-- [ ] Run all unit tests - should be fast (<1 second total)
-
-### Phase 2: Coordination Layer (Build tools and wrappers)
-
-**Principle**: Now that we have testable components, build the coordination layer that wires them together.
-
-#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)
-- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`
-  - Define `add_item_to_order` tool schema
-    - Parameters: category, item_name, modifiers, quantity
-    - Description optimized for LLM understanding
-  - Implement tool function:
-    ```python
-    # 1. Validate using menu_validation.validate_order_item()
-    # 2. If valid: order_state.add_item()
-    # 3. Return structured confirmation
-    ```
-  - Define `complete_order` tool schema
-  - Implement tool function: calls order_state.complete_order()
-- [ ] Write integration tests for order_tools
-  - Mock OrderStateManager, real MenuProvider
-  - Verify validation is called before state mutation
-  - Verify tool returns proper schema
-  - Test invalid inputs (should not mutate state)
-
-#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)
-- [ ] Implement `DriveThruLLM` wrapper
-  - Constructor: receives wrapped_llm, menu_provider, config
-  - `chat()` method:
-    ```python
-    # 1. Extract keywords from latest user message
-    # 2. Query menu_provider.search_items(keyword)
-    # 3. Inject relevant items into chat_ctx (augment system message)
-    # 4. Delegate to wrapped_llm.chat()
-    ```
-  - Keep wrapper STATELESS
-- [ ] Write unit tests for DriveThruLLM
-  - Mock wrapped LLM
-  - Verify menu context is injected into chat_ctx
-  - Verify delegation to wrapped LLM
-  - No state stored in wrapper
-
-#### Step 2.3: Accuracy Strategies (Implement within existing components)
-- [ ] Strategy 1: Function Calling - Already implemented in OrderTools âœ“
-- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM
-- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py
-- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)
-- [ ] Verify all strategies are in place
-- [ ] Document which component owns which strategy
-
-### Phase 3: Agent Integration (Wire everything together)
-
-**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.
-
-#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)
-- [ ] Implement `DriveThruAgent` class
-  - Constructor receives: order_state, menu_provider, config
-  - Sets drive-thru specific instructions (system prompt)
-  - Registers tools: `create_order_tools(order_state, menu_provider, config)`
-  - Agent OWNS OrderStateManager (composition)
-  - Agent RECEIVES MenuProvider (dependency injection)
-- [ ] Define agent instructions/persona
-  - Concise, friendly, efficient
-  - Clear about when to use tools
-  - Handles confirmation flow
-
-#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)
-- [ ] Add `DriveThruConfig` to `src/config.py`
-  - menu_file_path, orders_output_dir
-  - fuzzy_match_threshold, max_context_items
-  - enable_confirmation_loop, enable_semantic_search
-- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)
-  - Instantiate MenuProvider (singleton, loaded once)
-  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)
-  - Create OrderStateManager for each session (session_handler)
-  - Create DriveThruAgent (injecting order_state and menu_provider)
-  - Wire to SessionHandler
-- [ ] Verify dependency flow:
-  ```
-  App creates MenuProvider (singleton)
-     â”œâ”€> Injects into DriveThruLLM wrapper
-     â”œâ”€> Injects into DriveThruAgent
-     â””â”€> Injects into OrderTools
-
-  App creates OrderStateManager per session
-     â”œâ”€> Owned by DriveThruAgent
-     â””â”€> Passed to OrderTools
-  ```
-
-#### Step 3.3: Integration Testing
-- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider
-  - No mocked components, real coordination
-  - Verify end-to-end flow: validate â†’ add â†’ log
-- [ ] Test console mode end-to-end
-  - Use mock LLM or real LLM with simple prompts
-  - Verify order state is persisted correctly
-  - Verify incremental logs and final JSON
-
-### Phase 4: Testing & Refinement (2-3 days)
-- [ ] Write comprehensive test suite (20+ tests)
-- [ ] Test with real voice input (console mode)
-- [ ] Measure accuracy metrics
-- [ ] Identify failure modes
-- [ ] Iterate on prompts and validation logic
-
-### Phase 5: Advanced Strategies (Optional, 2-3 days)
-- [ ] Implement Strategy 3: Explicit Confirmation Loop
-- [ ] Implement Strategy 5: Semantic Search with Embeddings
-- [ ] A/B test different strategy combinations
-- [ ] Optimize for latency and cost
-
----
-
-## 7. File Structure
-
-```
-src/
-â”œâ”€â”€ drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)
-â”œâ”€â”€ drive_thru_llm.py            # LLM wrapper (stateless context injection)
-â”œâ”€â”€ menu_provider.py             # Menu data provider (read-only)
-â”œâ”€â”€ order_state_manager.py       # Order state + persistence (single source of truth)
-â”œâ”€â”€ menu_validation.py           # Pure validation functions
-â””â”€â”€ tools/
-    â”œâ”€â”€ __init__.py
-    â””â”€â”€ order_tools.py           # LiveKit Tool definitions (coordination layer)
-
-tests/
-â”œâ”€â”€ test_menu_validation.py      # Unit tests for pure functions (fast)
-â”œâ”€â”€ test_menu_provider.py        # Unit tests for menu queries (fast)
-â”œâ”€â”€ test_order_state.py          # Unit tests for state management (fast)
-â”œâ”€â”€ test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)
-â”œâ”€â”€ test_order_tools.py          # Integration tests for tools (medium)
-â”œâ”€â”€ test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)
-â””â”€â”€ test_accuracy.py             # Accuracy benchmarks (slow)
-
-orders/
-â”œâ”€â”€ {session_id}/
-â”‚   â”œâ”€â”€ incremental_log.jsonl    # Per-turn logging
-â”‚   â””â”€â”€ final_order.json         # Final order output
-
-menus/
-â””â”€â”€ mcdonalds/
-    â”œâ”€â”€ models.py                # Pydantic models (Item, Modifier, Menu)
-    â””â”€â”€ transformed-data/
-        â””â”€â”€ menu-structure-2026-01-21.json
-
-plan/
-â””â”€â”€ mcdonalds-drive-thru-agent-plan.md  # This document
-
-
-Test Pyramid (following best practices):
-â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
-â”‚  E2E Tests  â”‚  â† Few, slow, test full agent behavior
-â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-â”‚ Integration â”‚  â† Some, medium, test component interactions
-â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
-â”‚ Unit Tests  â”‚  â† Many, fast, test isolated components
-â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
-
-Unit tests should be:
-- Fast (no I/O, no real LLM calls)
-- Isolated (test one component at a time)
-- Deterministic (no randomness, no flakiness)
-
-Integration tests should:
-- Use real components but mock expensive dependencies (e.g., mock LLM)
-- Test interactions between 2-3 components
-
-E2E tests should:
-- Use judge-based evaluation for natural language
-- Cover critical user paths
-- Be fewer in number (expensive to run)
-```
-
----
-
-## 8. Configuration
-
-Add to `src/config.py`:
-
-```python
-class DriveThruConfig(BaseModel):
-    """Configuration for drive-thru agent."""
-
-    menu_file_path: str = Field(
-        default="menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json",
-        description="Path to menu JSON file"
-    )
-
-    orders_output_dir: str = Field(
-        default="orders",
-        description="Directory to save order files"
-    )
-
-    fuzzy_match_threshold: int = Field(
-        default=85,
-        description="Minimum fuzzy match score (0-100)"
-    )
-
-    enable_confirmation_loop: bool = Field(
-        default=True,
-        description="Require confirmation before adding items"
-    )
-
-    enable_semantic_search: bool = Field(
-        default=False,
-        description="Use embeddings for semantic item search"
-    )
-
-    max_context_items: int = Field(
-        default=50,
-        description="Maximum number of menu items to inject into context"
-    )
-```
-
----
-
-## 9. Risks & Mitigations
-
-### Risk 1: STT Errors
-**Impact**: Customer says "Big Mac" but STT hears "Big Mack" or "big man"
-**Mitigation**:
-- Fuzzy string matching (Strategy 4)
-- Semantic search (Strategy 5)
-- Confirmation loop (Strategy 3)
-
-### Risk 2: LLM Hallucination
-**Impact**: LLM adds items not on the menu
-**Mitigation**:
-- Function calling with strict validation
-- Menu context injection (Strategy 2)
-- Post-processing validation (Strategy 9)
-
-### Risk 3: Modifier Errors
-**Impact**: Customer wants "no pickles" but modifier not captured
-**Mitigation**:
-- Structured modifier field in function calling
-- Validation against available modifiers per item
-- Explicit confirmation
-
-### Risk 4: Latency
-**Impact**: Slow response times frustrate customers
-**Mitigation**:
-- Use faster LLM (GPT-4.1-nano or similar)
-- Optimize context injection (Strategy 10)
-- Precompute embeddings if using Strategy 5
-- Enable preemptive generation
-
-### Risk 5: Multi-Item Order Complexity
-**Impact**: Customer orders 5 items in one utterance, agent misses some
-**Mitigation**:
-- Ask customer to order one item at a time
-- Use two-stage parsing (Strategy 6) if needed
-- Read back full order at end for correction
-
----
-
-## 10. Success Criteria
-
-The implementation will be considered successful when:
-
-1. **Accuracy**: â‰¥95% item name accuracy on test suite
-2. **Modifier Accuracy**: â‰¥90% modifier accuracy
-3. **Completeness**: â‰¥95% of orders captured completely
-4. **Latency**: <2 seconds per turn (STT â†’ TTS)
-5. **Robustness**: Handles invalid items gracefully (100% of test cases)
-6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders
-7. **User Experience**: Judge-based tests confirm natural, friendly interaction
-
----
-
-## 11. Future Enhancements
-
-After initial implementation, consider:
-
-1. **Meal Combos**: Support "Number 1" style ordering
-2. **Upselling**: "Would you like to make that a meal?"
-3. **Menu Recommendations**: Based on time of day, weather, etc.
-4. **Price Calculation**: Calculate total cost
-5. **Multi-Language Support**: Spanish, etc.
-6. **Voice Biometrics**: Remember repeat customers
-7. **Order History**: "Same as last time"
-8. **Integration**: Connect to POS system for real orders
-
----
-
-## 12. Key Design Decisions
-
-### Why Separate DriveThruLLM from OrderStateManager?
-**Principle**: Single Responsibility Principle (SRP)
-
-LLM wrapping (context injection) is orthogonal to state management. By separating:
-- DriveThruLLM can be tested with mock LLM (fast unit tests)
-- OrderStateManager can be tested without LLM (fast unit tests)
-- Each component has one reason to change
-- Components can be swapped independently (e.g., try different context injection strategies)
-
-### Why Pure Functions for Validation?
-**Principle**: Functional Core, Imperative Shell
-
-Pure functions are maximally testable:
-- No I/O, no side effects
-- Deterministic outputs for same inputs
-- Fast to execute (no database, no API calls)
-- Easy to reason about
-- Can be reused anywhere
-
-This enables Test-Driven Development: write test first, implement function, iterate quickly.
-
-### Why MenuProvider Returns Immutable Data?
-**Principle**: Immutability Reduces Bugs
-
-If MenuProvider returned mutable references:
-- Callers could accidentally modify menu data
-- Hard to track down where menu was corrupted
-- Thread safety issues in concurrent sessions
-
-By returning immutable copies:
-- Menu data is protected from accidental mutation
-- Single source of truth guaranteed
-- Easier to reason about data flow
-
-### Why OrderStateManager is the Only State Owner?
-**Principle**: Single Source of Truth (SSOT)
-
-All order mutations flow through one place:
-- Easy to add logging/auditing
-- Persistence logic centralized
-- Impossible to have inconsistent state
-- Debugging is straightforward: check one component
-- Testing is simple: verify state before/after
-
-Contrast with diffused state (anti-pattern):
-- State scattered across DriveThruLLM, tools, agent
-- Hard to debug: "Where did this item come from?"
-- Hard to test: need to set up multiple components
-- Brittle: changes ripple across multiple components
-
-### Why Tools are Thin Coordination Layer?
-**Principle**: Tell, Don't Ask
-
-Tools coordinate but don't implement logic:
-```python
-# Good (coordination)
-def add_item_to_order_tool(...):
-    result = validate_order_item(...)  # Ask validation layer
-    if result.is_valid:
-        order_state.add_item(...)      # Tell state manager
-    return confirmation
-
-# Bad (implementation leaking into tool)
-def add_item_to_order_tool(...):
-    # Fuzzy matching logic here
-    # Modifier validation logic here
-    # File I/O logic here
-    # Now tool is hard to test and has multiple responsibilities
-```
-
-### Why Function Calling?
-**Principle**: Make Invalid States Unrepresentable
-
-Function calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.
-
-Schema enforcement means: "If it parses, it's valid" (or close to it).
-
-### Why Multiple Strategies?
-**Principle**: Defense in Depth
-
-No single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.
-
-### Why Confirmation Loop?
-**Principle**: Human-in-the-Loop
-
-Voice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.
-
-### Why Incremental Logging?
-**Principle**: Observability & Debuggability
-
-Provides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.
-
-Enables data-driven improvement: analyze logs to find common error patterns.
-
-### Why Focus on Accuracy Over Speed?
-**Principle**: Correctness First, Optimization Second
-
-Wrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.
-
-Premature optimization is the root of all evil. Get it working, get it right, then make it fast.
-
-### Why Test Pyramid (Many Unit, Few E2E)?
-**Principle**: Fast Feedback Loops (Continuous Delivery)
-
-Unit tests:
-- Run in milliseconds
-- Give instant feedback
-- Pinpoint exact failure
-- Enable rapid iteration
-
-E2E tests:
-- Run in seconds/minutes
-- Slow feedback
-- Hard to debug failures
-- Necessary but expensive
-
-Build on solid foundation of fast unit tests, use E2E tests for critical paths only.
-
-### Why Dependency Injection?
-**Principle**: Inversion of Control (IoC)
-
-Components receive dependencies rather than creating them:
-- Easy to substitute mocks for testing
-- Easy to swap implementations (e.g., different LLM, different storage)
-- Explicit dependencies (no hidden coupling)
-- Testable in isolation
-
-```python
-# Good (DI)
-class DriveThruAgent:
-    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):
-        self.order_state = order_state  # Injected
-        self.menu = menu                # Injected
-
-# Bad (hidden dependencies)
-class DriveThruAgent:
-    def __init__(self):
-        self.order_state = OrderStateManager()  # Hard-coded
-        self.menu = MenuProvider()              # Hard-coded
-        # Now can't test with mocks, can't swap implementations
-```
-
----
-
-## 13. Experimentation Framework
-
-To determine which strategies work best, implement an experimentation framework:
-
-```python
-class AccuracyExperiment:
-    """Framework for testing accuracy strategies."""
-
-    def __init__(self, test_cases: list[OrderTestCase]):
-        self.test_cases = test_cases
-
-    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:
-        """Run all test cases with a given strategy configuration."""
-        results = []
-        for test_case in self.test_cases:
-            result = await self.run_single_test(test_case, strategy_config)
-            results.append(result)
-        return ExperimentResults(results)
-
-    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:
-        """A/B test two strategy configurations."""
-        results_a = await self.run_experiment(strategy_a)
-        results_b = await self.run_experiment(strategy_b)
-        return Comparison(results_a, results_b)
-```
-
-Use this to answer questions like:
-- Does semantic search improve accuracy over fuzzy matching?
-- What's the optimal fuzzy match threshold?
-- Does chain-of-thought reduce hallucination?
-- What's the latency vs accuracy tradeoff?
-
----
-
-## 14. Monitoring & Observability
-
-In production, track:
-- **Per-turn metrics**: Item extraction accuracy, latency
-- **Per-order metrics**: Order completeness, correction rate
-- **LLM metrics**: Token usage, cost per order
-- **Error rates**: Invalid items, failed validations
-- **User satisfaction**: Explicit feedback, order completion rate
-
-Use LiveKit's built-in metrics framework + custom application metrics.
-
----
-
-## Conclusion
-
-This plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.
-
-The phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.
-
-**Next Steps**:
-1. Review and approve this plan
-2. Begin Phase 1 implementation
-3. Set up testing infrastructure
-4. Iterate based on real-world results