{"type":"file-history-snapshot","messageId":"0ed0bf77-7fb4-4199-9b07-12c3e0640285","snapshot":{"messageId":"0ed0bf77-7fb4-4199-9b07-12c3e0640285","trackedFileBackups":{},"timestamp":"2026-01-21T23:43:04.191Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"},"isMeta":true,"uuid":"4eebc6c9-b785-4d86-9e9c-18400ce721ec","timestamp":"2026-01-21T23:43:04.191Z"}
{"parentUuid":"4eebc6c9-b785-4d86-9e9c-18400ce721ec","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"0ed0bf77-7fb4-4199-9b07-12c3e0640285","timestamp":"2026-01-21T23:43:04.114Z"}
{"parentUuid":"0ed0bf77-7fb4-4199-9b07-12c3e0640285","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"b794df92-4447-487e-af9b-f81dd5bac87f","timestamp":"2026-01-21T23:43:04.191Z"}
{"type":"file-history-snapshot","messageId":"48e41a28-8b07-4866-8f09-491a51cfde0b","snapshot":{"messageId":"48e41a28-8b07-4866-8f09-491a51cfde0b","trackedFileBackups":{},"timestamp":"2026-01-21T23:57:00.493Z"},"isSnapshotUpdate":false}
{"parentUuid":"b794df92-4447-487e-af9b-f81dd5bac87f","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"here is a python library that I like https://returns.readthedocs.io/en/latest/index.html\n\nPlease plan out content and examples, and then create, several markdown documents as an introduction to how to use this library with code examples that covers these parts of the library in detail, in order given, with TOC and section links in the markdown to the app. \n\nDocument # 1 Maybe, Result, Success, Failure, IO,Future, Safe, future_safe, Context, Pipelines. These are all very important so should have several examples for each\n\nDocument #2 Methods, RequiresContext,  Converters, Helper Functions, Primitive Types IOResult, FutureResult, RequiresContextResult, RequiresContextIOResult and RequiresContextFutureResult"},"uuid":"48e41a28-8b07-4866-8f09-491a51cfde0b","timestamp":"2026-01-21T23:57:00.489Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]}}
{"parentUuid":"48e41a28-8b07-4866-8f09-491a51cfde0b","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015HQdjnohLT6JugjrdNEs5J","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to create markdown documentation for the `returns` library (https://returns.readthedocs.io/en/latest/index.html). They want:\n\n1. Document #1 covering: Maybe, Result, Success, Failure, IO, Future, Safe, future_safe, Context, Pipelines\n2. Document #2 covering: Methods, RequiresContext, Converters, Helper Functions, Primitive Types (IOResult, FutureResult, RequiresContextResult, RequiresContextIOResult, RequiresContextFutureResult)\n\nThey want:\n- Multiple examples for each topic\n- TOC and section links\n- Detailed coverage\n- Code examples\n\nI should first fetch the documentation to understand the library better, then create comprehensive markdown documents with examples.\n\nLet me start by fetching the main documentation page to understand the library structure and API.","signature":"ErYHCkYICxgCKkDQCLZwZAG4QthL6B3DvdDFifDiNTJofAaDwQqU0nV71Zb40p4qeYEFgJ3D0xj+VIv2Q2cuTsAE7KAktQKQBMLpEgy+m1KGbD4y/Zzp7bsaDCfUAzWHd2bLGbynfSIwlRSxu+zLt5ja5MK6fUofGcEPcg65QpDpIsGQ2CNwfzxzUGj5K1akg45r2X3aK2vlKp0GMfBVVrcyMDRrV0DU1kJhfNKWlMvch1Q4HqNN2IfqnF55Yuq9Ws38WeAkW8X9UyF4kd66OjNK9/D28PqeFqyg3s0zFCv2YhxsY4wRvoc97zQ83uq3WsPltAUpY8fGhqL6yXrYRTvJA1ZCxFSRwxaW3N54nqDlle8x9nhiZJSaz8wYAmVWC0eo/0ahNbi8pa4KsZAV13Hob3FQnE15q+n9+JCk5GCP+eRUuqqNh0PklbjTYm8+RLKlKIgxycwGZKl7nS1mRjXDV4oxZNwVYrSnI+LdOA8RSAGXuCFIe6WzYy4R8GXezlsDqmeg5EpIPEdnCQelKntFMNnYY9kgeYHrWdRPjNLXu6oWF/Kv+3CzP45TvecWdAasxNdSc+tPw+ivyulmhoVW2WeBRFbwh+Vh1uL8Ng9biPRw6Z+/vwiLhqym+J+VUKxpr7LaIWzzHEwkbPEEVc0B7SZnhka7DRRWvHuY2GW/X982m+7Uvl68/XC6RxHsGQNGTLlVndday5YShYYA8wVYAmM+aJNSYzyH9rt9UMto2uSbTGXTmc+49Vg+2yqf2S1vK8KuTqHQyy8LKQtGCES7ifqVnNPk9ToVbihP2CzkxU3GBFCzHetzK3sH1KxssBEDjj9TJeCIaDoByYzbqk1/cs4ApN1EodUenw/Wwtk4sGa0SNGiRv+l5/quYs+xajmEaO9ZVqLh1sELLvAyrcslV6ECACYqa5rEQPQrIv0RT/VVQR3eLpCLLWrq6fX9vzgOZJM+/xUZxdLGHQiePm3tmML8npl44ARm98CFlG6CY7st7zkV/9foW4jWpHFABHGnqrkA0Wr5lrP5OKH+ivFa+YXbI7QKIWr0904D+ohFhjGcMsTi9DMSlD8cYKVSY1Fxbkr1OitsPApzvAhPo0dmDZUZsoYRCW8iWGe4fzUCavcZbO2ZOAwoxdJjcGYWm7Dl5NQfzg7RJZQ9dhx5ZX8oWXatmlCtFU87eZUlnnjzu/8+Js8ZwiUYSTu99uNvfhotqHI4kb3OArUV7yARuyW4f7TPBUvaouMXXUjPdb/Q3dAsrJMNeP0YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25787,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMRpA2WpqgrJi6evZCuS","type":"assistant","uuid":"637fb73e-c1ab-4cb9-919d-58dbd924e290","timestamp":"2026-01-21T23:57:03.654Z"}
{"parentUuid":"637fb73e-c1ab-4cb9-919d-58dbd924e290","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015HQdjnohLT6JugjrdNEs5J","type":"message","role":"assistant","content":[{"type":"text","text":"I'll help you create comprehensive markdown documentation for the `returns` library. Let me first fetch the documentation to understand the library's API and patterns, then create detailed guides with examples."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25787,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMRpA2WpqgrJi6evZCuS","type":"assistant","uuid":"bdadac35-3739-4de9-91e6-e962056d5df1","timestamp":"2026-01-21T23:57:04.191Z"}
{"parentUuid":"bdadac35-3739-4de9-91e6-e962056d5df1","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015HQdjnohLT6JugjrdNEs5J","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JRZmBVL25u8PVeC7u2RTrA","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/index.html","prompt":"Get an overview of the returns library, its main concepts, and the structure of its documentation. Include information about Maybe, Result, IO, Future, Context, and Pipeline types."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25787,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMRpA2WpqgrJi6evZCuS","type":"assistant","uuid":"2126ca40-e79a-4267-9d26-23da8a48c972","timestamp":"2026-01-21T23:57:05.160Z"}
{"parentUuid":"2126ca40-e79a-4267-9d26-23da8a48c972","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015HQdjnohLT6JugjrdNEs5J","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YYZYv7Umoy3PtV1EqB19WT","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/result.html","prompt":"Get detailed information about Result, Success, and Failure types including their API, usage patterns, and code examples."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25787,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMRpA2WpqgrJi6evZCuS","type":"assistant","uuid":"ac794805-4540-48c6-9eb3-a9c8c6543d8a","timestamp":"2026-01-21T23:57:05.814Z"}
{"parentUuid":"ac794805-4540-48c6-9eb3-a9c8c6543d8a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015HQdjnohLT6JugjrdNEs5J","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BjAmLfLY7yZLAfed8QghtE","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/maybe.html","prompt":"Get detailed information about Maybe type including its API, usage patterns, and code examples."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25787,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMRpA2WpqgrJi6evZCuS","type":"assistant","uuid":"d801c396-c543-4b69-86d7-ff39b03b7287","timestamp":"2026-01-21T23:57:06.284Z"}
{"parentUuid":"d801c396-c543-4b69-86d7-ff39b03b7287","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015HQdjnohLT6JugjrdNEs5J","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013N2RvXp9SbEYqGQ4Y76uqe","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/io.html","prompt":"Get detailed information about IO type including its API, usage patterns, and code examples."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25787,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25787,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMRpA2WpqgrJi6evZCuS","type":"assistant","uuid":"4a2f2924-785a-4826-ad83-49e784e93a44","timestamp":"2026-01-21T23:57:06.672Z"}
{"parentUuid":"d801c396-c543-4b69-86d7-ff39b03b7287","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BjAmLfLY7yZLAfed8QghtE","type":"tool_result","content":"# Maybe Container Documentation Summary\n\n## Overview\nThe `Maybe` container handles computations that might return `None` at any point, providing a cleaner alternative to constant null checks or exception handling.\n\n## Core Types\n`Maybe` consists of two variants:\n- **`Some`**: Represents a successful computation with a value\n- **`Nothing`**: Represents absence of a value\n\n## Key Methods\n\n**Creation:**\n- `Maybe.from_optional(value)` - Converts `None` to `Nothing`, other values to `Some`\n- `Maybe.from_value(value)` - Wraps any value, including `None`, in `Some`\n\n**Composition:**\n- `map()` - Applies a pure function to the contained value\n- `bind()` - Chains operations returning `Maybe` containers\n- `bind_optional()` - Binds functions returning `Optional` types\n\n**Extraction:**\n- `value_or(default)` - Returns the value or a default\n- `unwrap()` - Extracts the value or raises an exception\n- `or_else_call(function)` - Lazily evaluates a fallback function\n\n## Practical Example\nThe documentation illustrates accessing nested optional fields:\n\n> \"Complex operations like...chaining `.bind_optional()` calls across nested `Optional` fields\" to safely extract deeply nested values without repetitive null checks.\n\n## Pattern Matching\nPython 3.10+ supports structural pattern matching with `Maybe`:\n```python\nmatch result:\n    case Some(value): ...\n    case Maybe.empty: ...\n```\n\n## Decorator\nThe `@maybe` decorator converts functions returning `Optional` into functions returning `Maybe` containers automatically."}]},"uuid":"eb7b47a1-7f90-4f9e-afcf-8ca48ab2afb9","timestamp":"2026-01-21T23:57:16.232Z","toolUseResult":{"bytes":136957,"code":200,"codeText":"OK","result":"# Maybe Container Documentation Summary\n\n## Overview\nThe `Maybe` container handles computations that might return `None` at any point, providing a cleaner alternative to constant null checks or exception handling.\n\n## Core Types\n`Maybe` consists of two variants:\n- **`Some`**: Represents a successful computation with a value\n- **`Nothing`**: Represents absence of a value\n\n## Key Methods\n\n**Creation:**\n- `Maybe.from_optional(value)` - Converts `None` to `Nothing`, other values to `Some`\n- `Maybe.from_value(value)` - Wraps any value, including `None`, in `Some`\n\n**Composition:**\n- `map()` - Applies a pure function to the contained value\n- `bind()` - Chains operations returning `Maybe` containers\n- `bind_optional()` - Binds functions returning `Optional` types\n\n**Extraction:**\n- `value_or(default)` - Returns the value or a default\n- `unwrap()` - Extracts the value or raises an exception\n- `or_else_call(function)` - Lazily evaluates a fallback function\n\n## Practical Example\nThe documentation illustrates accessing nested optional fields:\n\n> \"Complex operations like...chaining `.bind_optional()` calls across nested `Optional` fields\" to safely extract deeply nested values without repetitive null checks.\n\n## Pattern Matching\nPython 3.10+ supports structural pattern matching with `Maybe`:\n```python\nmatch result:\n    case Some(value): ...\n    case Maybe.empty: ...\n```\n\n## Decorator\nThe `@maybe` decorator converts functions returning `Optional` into functions returning `Maybe` containers automatically.","durationMs":5819,"url":"https://returns.readthedocs.io/en/latest/pages/maybe.html"},"sourceToolAssistantUUID":"d801c396-c543-4b69-86d7-ff39b03b7287"}
{"parentUuid":"ac794805-4540-48c6-9eb3-a9c8c6543d8a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YYZYv7Umoy3PtV1EqB19WT","type":"tool_result","content":"# Result Type Documentation Summary\n\n## Overview\n\nThe `Result` type represents the outcome of computations that may succeed or fail. It consists of two variants:\n\n- **`Success`**: Contains a successful operation's result value\n- **`Failure`**: Contains error information\n\nAs the documentation states: \"When you do not want to use exceptions to break your execution scope. Or when you do not want to use `None` to represent empty values.\"\n\n## Key Methods\n\n**Transformation operations:**\n- `map()` - applies pure functions to successful values\n- `bind()` - chains operations returning Result containers\n- `alt()` - transforms error values\n- `lash()` - chains error handling operations\n\n**Value extraction:**\n- `unwrap()` - retrieves the value or raises an exception\n- `failure()` - retrieves the error or raises an exception\n- `value_or()` - returns value or default fallback\n\n**Utility operations:**\n- `swap()` - exchanges value and error positions\n- `equals()` - typesafe equality comparison\n\n## Decorators\n\n**`@safe`**: Converts exception-throwing functions into Result-returning functions. Supports filtering specific exception types.\n\n**`@attempt`**: Similar to `@safe`, but wraps the argument that caused the exception rather than the exception itself. Works only with single-argument functions.\n\n## Pattern Matching\n\nPython 3.10+ supports structural pattern matching with Result:\n\n```python\nmatch div(1, 0):\n    case Success(value):\n        print(f'Result is \"{value}\"')\n    case Failure(_):\n        print('Operation failed')\n```\n\n## Aliases\n\n`ResultE` is a convenient alias for `Result[..., Exception]` when working with exception-based error types."}]},"uuid":"9abb0976-a676-40f3-ae6a-6fca864d1a83","timestamp":"2026-01-21T23:57:16.639Z","toolUseResult":{"bytes":162602,"code":200,"codeText":"OK","result":"# Result Type Documentation Summary\n\n## Overview\n\nThe `Result` type represents the outcome of computations that may succeed or fail. It consists of two variants:\n\n- **`Success`**: Contains a successful operation's result value\n- **`Failure`**: Contains error information\n\nAs the documentation states: \"When you do not want to use exceptions to break your execution scope. Or when you do not want to use `None` to represent empty values.\"\n\n## Key Methods\n\n**Transformation operations:**\n- `map()` - applies pure functions to successful values\n- `bind()` - chains operations returning Result containers\n- `alt()` - transforms error values\n- `lash()` - chains error handling operations\n\n**Value extraction:**\n- `unwrap()` - retrieves the value or raises an exception\n- `failure()` - retrieves the error or raises an exception\n- `value_or()` - returns value or default fallback\n\n**Utility operations:**\n- `swap()` - exchanges value and error positions\n- `equals()` - typesafe equality comparison\n\n## Decorators\n\n**`@safe`**: Converts exception-throwing functions into Result-returning functions. Supports filtering specific exception types.\n\n**`@attempt`**: Similar to `@safe`, but wraps the argument that caused the exception rather than the exception itself. Works only with single-argument functions.\n\n## Pattern Matching\n\nPython 3.10+ supports structural pattern matching with Result:\n\n```python\nmatch div(1, 0):\n    case Success(value):\n        print(f'Result is \"{value}\"')\n    case Failure(_):\n        print('Operation failed')\n```\n\n## Aliases\n\n`ResultE` is a convenient alias for `Result[..., Exception]` when working with exception-based error types.","durationMs":6227,"url":"https://returns.readthedocs.io/en/latest/pages/result.html"},"sourceToolAssistantUUID":"ac794805-4540-48c6-9eb3-a9c8c6543d8a"}
{"parentUuid":"2126ca40-e79a-4267-9d26-23da8a48c972","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JRZmBVL25u8PVeC7u2RTrA","type":"tool_result","content":"# Returns Library Overview\n\n**Returns** is a Python functional programming library (v0.26.0) that enables developers to write safer, more type-safe code by providing container types for handling errors, side effects, and asynchronous operations.\n\n## Core Concepts\n\nThe library introduces several key container types:\n\n**Maybe Container**: Eliminates `None`-related bugs by replacing nullable types with `Some` and `Nothing` variants. Rather than nested `if` statements, you chain operations with `.bind_optional()`.\n\n**Result Container**: Replaces exception-throwing code with explicit error handling. Functions decorated with `@safe` return `Success` or `Failure` wrapped values, making error paths visible and testable.\n\n**IO Container**: Marks impure functions explicitly, distinguishing side effects from pure logic. This separation improves testability and code reusability.\n\n**IOResult**: Combines `IO` and `Result` for impure operations that can fail (like HTTP requests).\n\n**Future & FutureResult**: Enable composing async code without excessive `await` statements while maintaining exception safety in event loops.\n\n**RequiresContext**: Implements typed functional dependency injection, allowing configuration to flow through call stacks without explicit parameter passing.\n\n## Key Features\n\n- Full type-safety with mypy integration\n- Higher Kinded Types support\n- Railway-oriented programming patterns\n- Seamless sync/async composition\n- Framework-agnostic design\n- Comprehensive documentation and testing tools\n\nThe library emphasizes separating pure business logic from impure operations while providing composable, declarative APIs for complex workflows."}]},"uuid":"0dab511e-26e3-426d-9f58-e9345e3e7f71","timestamp":"2026-01-21T23:57:16.743Z","toolUseResult":{"bytes":105285,"code":200,"codeText":"OK","result":"# Returns Library Overview\n\n**Returns** is a Python functional programming library (v0.26.0) that enables developers to write safer, more type-safe code by providing container types for handling errors, side effects, and asynchronous operations.\n\n## Core Concepts\n\nThe library introduces several key container types:\n\n**Maybe Container**: Eliminates `None`-related bugs by replacing nullable types with `Some` and `Nothing` variants. Rather than nested `if` statements, you chain operations with `.bind_optional()`.\n\n**Result Container**: Replaces exception-throwing code with explicit error handling. Functions decorated with `@safe` return `Success` or `Failure` wrapped values, making error paths visible and testable.\n\n**IO Container**: Marks impure functions explicitly, distinguishing side effects from pure logic. This separation improves testability and code reusability.\n\n**IOResult**: Combines `IO` and `Result` for impure operations that can fail (like HTTP requests).\n\n**Future & FutureResult**: Enable composing async code without excessive `await` statements while maintaining exception safety in event loops.\n\n**RequiresContext**: Implements typed functional dependency injection, allowing configuration to flow through call stacks without explicit parameter passing.\n\n## Key Features\n\n- Full type-safety with mypy integration\n- Higher Kinded Types support\n- Railway-oriented programming patterns\n- Seamless sync/async composition\n- Framework-agnostic design\n- Comprehensive documentation and testing tools\n\nThe library emphasizes separating pure business logic from impure operations while providing composable, declarative APIs for complex workflows.","durationMs":6351,"url":"https://returns.readthedocs.io/en/latest/index.html"},"sourceToolAssistantUUID":"2126ca40-e79a-4267-9d26-23da8a48c972"}
{"parentUuid":"4a2f2924-785a-4826-ad83-49e784e93a44","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013N2RvXp9SbEYqGQ4Y76uqe","type":"tool_result","content":"# IO Container in returns Library\n\n## Overview\n\nThe `IO` container marks impure operations in your codebase. According to the documentation, \"Once it is marked as `IO` it will never return to the pure state,\" making side effects explicit and traceable.\n\n## Key Concepts\n\n**IO vs IOResult:**\n- `IO[T]` handles side effects that never fail (reading current time, random numbers)\n- `IOResult[T, E]` manages operations that might fail (database access, network requests)\n\n## Main API Methods\n\n| Method | Purpose |\n|--------|---------|\n| `map()` | Apply pure function to wrapped value |\n| `bind()` | Chain functions returning IO containers |\n| `apply()` | Apply wrapped function to wrapped value |\n| `from_value()` | Construct IO from raw value |\n| `from_ioresult()` | Convert IOResult to IO[Result] |\n\n## Decorators\n\n**@impure** - Wraps functions returning IO:\n```python\n@impure\ndef get_random() -> 'int':\n    return random.randint(1, 10)\n```\n\n**@impure_safe** - Transforms to IOResult, catching exceptions:\n```python\n@impure_safe\ndef http_get(path: str) -> 'Response':\n    return requests.get(path)\n```\n\n## Important Pattern\n\nThe documentation emphasizes: \"functional core, imperative shell.\" Keep pure logic separate from IO operations, allowing easier testing and composition. Use `unsafe_perform_io()` sparingly as an escape hatch for framework compatibility at application boundaries."}]},"uuid":"36e17328-45f0-495d-be88-1f0fa6bda1ff","timestamp":"2026-01-21T23:57:16.915Z","toolUseResult":{"bytes":245983,"code":200,"codeText":"OK","result":"# IO Container in returns Library\n\n## Overview\n\nThe `IO` container marks impure operations in your codebase. According to the documentation, \"Once it is marked as `IO` it will never return to the pure state,\" making side effects explicit and traceable.\n\n## Key Concepts\n\n**IO vs IOResult:**\n- `IO[T]` handles side effects that never fail (reading current time, random numbers)\n- `IOResult[T, E]` manages operations that might fail (database access, network requests)\n\n## Main API Methods\n\n| Method | Purpose |\n|--------|---------|\n| `map()` | Apply pure function to wrapped value |\n| `bind()` | Chain functions returning IO containers |\n| `apply()` | Apply wrapped function to wrapped value |\n| `from_value()` | Construct IO from raw value |\n| `from_ioresult()` | Convert IOResult to IO[Result] |\n\n## Decorators\n\n**@impure** - Wraps functions returning IO:\n```python\n@impure\ndef get_random() -> 'int':\n    return random.randint(1, 10)\n```\n\n**@impure_safe** - Transforms to IOResult, catching exceptions:\n```python\n@impure_safe\ndef http_get(path: str) -> 'Response':\n    return requests.get(path)\n```\n\n## Important Pattern\n\nThe documentation emphasizes: \"functional core, imperative shell.\" Keep pure logic separate from IO operations, allowing easier testing and composition. Use `unsafe_perform_io()` sparingly as an escape hatch for framework compatibility at application boundaries.","durationMs":6503,"url":"https://returns.readthedocs.io/en/latest/pages/io.html"},"sourceToolAssistantUUID":"4a2f2924-785a-4826-ad83-49e784e93a44"}
{"parentUuid":"36e17328-45f0-495d-be88-1f0fa6bda1ff","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MU7KjS5BKf5egoUmzqpGsT","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good start. Now I need to fetch more information about Future, Context, Pipelines, and the primitive types for document #2.","signature":"EqQCCkYICxgCKkAui5894FOS7FMpY/xbafjVr+VkkgsfklWlMVwN85kgTc/ddO8mfDHAc9YopwSs9HKrIojwFr4Tat8TE2BmPt84EgwVi82k5k29/CELssEaDA6JkSVRQYHm4oYzvSIwOVLSxIThc6i2/AGJK48a+B03IG5+iZmL3/tR5sWhW8zZI8ePf2D/Wb0C17yulYwrKosBsJHaB3FU4sp5G1S3PlaMnLpuXICxPJgOQf1YG5dH90aSeaL8EgMks5AF1EdJBchEuQH2Ruhb68hhPs3v8VI06cBFoz9mkMLRzH9mK/WvltF172sWAxW6fmANQPVA41mlK1duae+AYrrA0T0SXMz/xiIq49FCIqO8kIe40CTI6xUztTYknxccueOR9hgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":2220,"cache_read_input_tokens":25787,"cache_creation":{"ephemeral_5m_input_tokens":2220,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRqMwQGb8tbaQpbUzw9","type":"assistant","uuid":"50321e2e-d566-4c3d-bfce-dada89580265","timestamp":"2026-01-21T23:57:18.704Z"}
{"parentUuid":"50321e2e-d566-4c3d-bfce-dada89580265","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MU7KjS5BKf5egoUmzqpGsT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W7HgRDzawrLSBEFL9wmNvD","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/future.html","prompt":"Get detailed information about Future and FutureResult types including their API, usage patterns, decorators like @future_safe, and code examples."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":2220,"cache_read_input_tokens":25787,"cache_creation":{"ephemeral_5m_input_tokens":2220,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRqMwQGb8tbaQpbUzw9","type":"assistant","uuid":"89c55d26-f5f2-4062-af09-d47f1f65e887","timestamp":"2026-01-21T23:57:19.804Z"}
{"parentUuid":"89c55d26-f5f2-4062-af09-d47f1f65e887","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MU7KjS5BKf5egoUmzqpGsT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XMvWKoGsi8fuugT1heVTs8","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/context.html","prompt":"Get detailed information about Context, RequiresContext, and related types including RequiresContextResult, RequiresContextIOResult, RequiresContextFutureResult with API and usage examples."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":2220,"cache_read_input_tokens":25787,"cache_creation":{"ephemeral_5m_input_tokens":2220,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRqMwQGb8tbaQpbUzw9","type":"assistant","uuid":"b1801c9f-7963-4273-ba8a-9409ce07e154","timestamp":"2026-01-21T23:57:20.654Z"}
{"parentUuid":"b1801c9f-7963-4273-ba8a-9409ce07e154","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MU7KjS5BKf5egoUmzqpGsT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013vKyLHbRAtLjB7aL4oncU6","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/pipeline.html","prompt":"Get detailed information about Pipeline and flow composition patterns including usage examples and patterns."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":2220,"cache_read_input_tokens":25787,"cache_creation":{"ephemeral_5m_input_tokens":2220,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRqMwQGb8tbaQpbUzw9","type":"assistant","uuid":"bd3f2fc5-198b-4750-8beb-73cc96238df3","timestamp":"2026-01-21T23:57:21.237Z"}
{"parentUuid":"bd3f2fc5-198b-4750-8beb-73cc96238df3","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01MU7KjS5BKf5egoUmzqpGsT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ga1jQmfLtuQmr4G1V3Dx8Q","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/methods.html","prompt":"Get detailed information about common methods available on container types including map, bind, alt, lash, and other transformation methods."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":2220,"cache_read_input_tokens":25787,"cache_creation":{"ephemeral_5m_input_tokens":2220,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRqMwQGb8tbaQpbUzw9","type":"assistant","uuid":"83a4496b-9f2c-4a9e-8d36-1f95c06598cc","timestamp":"2026-01-21T23:57:21.802Z"}
{"parentUuid":"83a4496b-9f2c-4a9e-8d36-1f95c06598cc","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ga1jQmfLtuQmr4G1V3Dx8Q","type":"tool_result","content":"# Methods in Returns 0.26.0\n\nThe Methods module provides utilities for working with container types in the returns library. Here are the key functions:\n\n## `cond()`\n\nThis function reduces boilerplate when handling conditional logic with failable types. Rather than writing traditional if/else statements, `cond` offers a \"functional if alternative for successful or failed types.\"\n\n**Example use case:** Converting a conditional check into a container-based result:\n```python\nmethods.cond(Result, string.isnumeric(), 'It is a number', 'It is not a number')\n```\n\nThis approach integrates seamlessly with pipeline compositions.\n\n## `unwrap_or_failure()`\n\nThis extracts values from container types, retrieving either the success or failure value wrapped inside. It's particularly useful after error handling operations like `bimap()`.\n\n## `partition()`\n\nThis utility converts a list of container instances (Result, IOResult, Maybe, etc.) into a tuple of two lists: one containing successful values and one containing failed values.\n\n**Example:**\n```python\npartition([Success(1), Failure(2), Success(3)])\n# Returns: ([1, 3], [2])\n```\n\n**Note:** The documentation recommends importing the `methods` module directly rather than individual functions to avoid naming conflicts with other modules like `pointfree`."}]},"uuid":"59608a4e-b621-426d-8db1-8159102469fd","timestamp":"2026-01-21T23:57:26.338Z","toolUseResult":{"bytes":36300,"code":200,"codeText":"OK","result":"# Methods in Returns 0.26.0\n\nThe Methods module provides utilities for working with container types in the returns library. Here are the key functions:\n\n## `cond()`\n\nThis function reduces boilerplate when handling conditional logic with failable types. Rather than writing traditional if/else statements, `cond` offers a \"functional if alternative for successful or failed types.\"\n\n**Example use case:** Converting a conditional check into a container-based result:\n```python\nmethods.cond(Result, string.isnumeric(), 'It is a number', 'It is not a number')\n```\n\nThis approach integrates seamlessly with pipeline compositions.\n\n## `unwrap_or_failure()`\n\nThis extracts values from container types, retrieving either the success or failure value wrapped inside. It's particularly useful after error handling operations like `bimap()`.\n\n## `partition()`\n\nThis utility converts a list of container instances (Result, IOResult, Maybe, etc.) into a tuple of two lists: one containing successful values and one containing failed values.\n\n**Example:**\n```python\npartition([Success(1), Failure(2), Success(3)])\n# Returns: ([1, 3], [2])\n```\n\n**Note:** The documentation recommends importing the `methods` module directly rather than individual functions to avoid naming conflicts with other modules like `pointfree`.","durationMs":4510,"url":"https://returns.readthedocs.io/en/latest/pages/methods.html"},"sourceToolAssistantUUID":"83a4496b-9f2c-4a9e-8d36-1f95c06598cc"}
{"parentUuid":"bd3f2fc5-198b-4750-8beb-73cc96238df3","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013vKyLHbRAtLjB7aL4oncU6","type":"tool_result","content":"# Pipelines in Returns 0.26.0\n\nThe documentation describes three primary composition tools for functional programming:\n\n## **flow()**\nComposes an existing value with multiple functions sequentially. As stated: \"Allows to compose a value and up to multiple functions that use this value.\" It's recommended for most use cases and has superior type inference through the mypy plugin. Limited to 21 steps maximum.\n\nExample usage:\n```python\nflow('1', int, float, str)  # => '1.0'\n```\n\n## **pipe()**\nCreates a reusable pipeline without an initial value, applying functions when called later. Similar to `flow()` but useful when you don't yet have data to process. The documentation notes it relates to `compose()` but accepts unlimited arguments rather than strictly two.\n\nExample:\n```python\npipeline = pipe(int, float, str)\npipeline('1')  # => '1.0'\n```\n\n## **managed()**\nHandles resource lifecycle management through three phases: acquire, use, and release. Particularly useful for file operations and database connections, ensuring resources are properly cleaned up even if errors occur.\n\n## **is_successful()**\nA utility function determining whether containers represent success states (like `Success`, `IOSuccess`, or `Some`).\n\nThe documentation emphasizes combining these tools with pointfree functions for clean, declarative code patterns."}]},"uuid":"f240c453-1b9e-4861-b303-c34538f48196","timestamp":"2026-01-21T23:57:26.394Z","toolUseResult":{"bytes":74809,"code":200,"codeText":"OK","result":"# Pipelines in Returns 0.26.0\n\nThe documentation describes three primary composition tools for functional programming:\n\n## **flow()**\nComposes an existing value with multiple functions sequentially. As stated: \"Allows to compose a value and up to multiple functions that use this value.\" It's recommended for most use cases and has superior type inference through the mypy plugin. Limited to 21 steps maximum.\n\nExample usage:\n```python\nflow('1', int, float, str)  # => '1.0'\n```\n\n## **pipe()**\nCreates a reusable pipeline without an initial value, applying functions when called later. Similar to `flow()` but useful when you don't yet have data to process. The documentation notes it relates to `compose()` but accepts unlimited arguments rather than strictly two.\n\nExample:\n```python\npipeline = pipe(int, float, str)\npipeline('1')  # => '1.0'\n```\n\n## **managed()**\nHandles resource lifecycle management through three phases: acquire, use, and release. Particularly useful for file operations and database connections, ensuring resources are properly cleaned up even if errors occur.\n\n## **is_successful()**\nA utility function determining whether containers represent success states (like `Success`, `IOSuccess`, or `Some`).\n\nThe documentation emphasizes combining these tools with pointfree functions for clean, declarative code patterns.","durationMs":4567,"url":"https://returns.readthedocs.io/en/latest/pages/pipeline.html"},"sourceToolAssistantUUID":"bd3f2fc5-198b-4750-8beb-73cc96238df3"}
{"parentUuid":"89c55d26-f5f2-4062-af09-d47f1f65e887","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W7HgRDzawrLSBEFL9wmNvD","type":"tool_result","content":"# Future and FutureResult Documentation Summary\n\n## Overview\nThe `Future` container is designed to compose async functions within a sync context, solving three key problems:\n\n1. **Sync/Async Incompatibility**: \"You cannot call async function from a sync one\"\n2. **Exception Safety**: Unexpectedly thrown exceptions can compromise event loops\n3. **Composition Complexity**: Reduces the need for excessive `await` statements\n\n## Key Differences\n\n**Future[a]** represents a computation that never fails, returning `IO[a]` when awaited.\n\n**FutureResult[a, b]** handles operations that might fail, returning `IOResult[a, b]`. It's essentially a wrapper around `Future[Result[a, b]]`.\n\n## Core Decorators\n\n**@future**: Transforms async functions into `Future` containers for exception-free operations.\n\n**@future_safe**: Converts exception-prone async functions into `FutureResult` containers, catching `Exception` subclasses automatically.\n\n**@asyncify**: Makes sync functions appear async for composition purposes (note: doesn't actually make them run asynchronously).\n\n## Essential Methods\n\nBoth containers support:\n- `map()` - Apply sync functions to values\n- `bind()` / `bind_awaitable()` - Compose with async functions\n- `awaitable()` - Convert to executable coroutines\n- Multiple `from_*` factory methods for creating instances\n\n## Practical Example\n\nThe documentation includes a real-world example fetching posts asynchronously while maintaining sync function signatures, demonstrating how easily async and sync code compose together."}]},"uuid":"5c1f3029-2c2e-4925-b3a3-73bd29dd6d17","timestamp":"2026-01-21T23:57:26.608Z","toolUseResult":{"bytes":308483,"code":200,"codeText":"OK","result":"# Future and FutureResult Documentation Summary\n\n## Overview\nThe `Future` container is designed to compose async functions within a sync context, solving three key problems:\n\n1. **Sync/Async Incompatibility**: \"You cannot call async function from a sync one\"\n2. **Exception Safety**: Unexpectedly thrown exceptions can compromise event loops\n3. **Composition Complexity**: Reduces the need for excessive `await` statements\n\n## Key Differences\n\n**Future[a]** represents a computation that never fails, returning `IO[a]` when awaited.\n\n**FutureResult[a, b]** handles operations that might fail, returning `IOResult[a, b]`. It's essentially a wrapper around `Future[Result[a, b]]`.\n\n## Core Decorators\n\n**@future**: Transforms async functions into `Future` containers for exception-free operations.\n\n**@future_safe**: Converts exception-prone async functions into `FutureResult` containers, catching `Exception` subclasses automatically.\n\n**@asyncify**: Makes sync functions appear async for composition purposes (note: doesn't actually make them run asynchronously).\n\n## Essential Methods\n\nBoth containers support:\n- `map()` - Apply sync functions to values\n- `bind()` / `bind_awaitable()` - Compose with async functions\n- `awaitable()` - Convert to executable coroutines\n- Multiple `from_*` factory methods for creating instances\n\n## Practical Example\n\nThe documentation includes a real-world example fetching posts asynchronously while maintaining sync function signatures, demonstrating how easily async and sync code compose together.","durationMs":4782,"url":"https://returns.readthedocs.io/en/latest/pages/future.html"},"sourceToolAssistantUUID":"89c55d26-f5f2-4062-af09-d47f1f65e887"}
{"parentUuid":"b1801c9f-7963-4273-ba8a-9409ce07e154","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XMvWKoGsi8fuugT1heVTs8","type":"tool_result","content":"# Context Container Overview\n\nThe `Context` module in returns 0.26.0 provides dependency injection through several container types for managing dependencies in functional Python code.\n\n## Core Containers\n\n**RequiresContext** wraps functions of type `Callable[[EnvType], ReturnType]`, enabling lazy evaluation and typed dependency injection. As the documentation states, it \"represents a context-dependent pure operation\" that composes without executing until dependencies are provided.\n\n**RequiresContextResult** combines `RequiresContext[Result[a, b], env]`, representing \"a context-dependent pure operation that might fail.\" It offers cleaner composition than manually nesting Result within RequiresContext.\n\n**RequiresContextIOResult** wraps `RequiresContext[IOResult[a, b], env]` for \"impure context-related functions that might fail,\" making it suitable for real-world applications involving I/O operations.\n\n**RequiresContextFutureResult** handles `RequiresContext[FutureResult[a, b], env]` for \"impure async function that might fail,\" enabling asynchronous operations with dependency injection.\n\n## Key Methods\n\nAll containers support `.ask()` to access current dependencies within the call stack, `.map()` for composing with pure functions, and various `.bind_*()` methods for chaining operations. The `.modify_env()` method allows transforming environment types.\n\n## Usage Pattern\n\nDependencies are injected at the final moment of execution, preserving purity throughout the composition chain. This approach makes \"code relies on context and which is free from it\" explicit through typing rather than relying on implicit magic."}]},"uuid":"41b68c81-0902-4a16-8a96-30c1b621a876","timestamp":"2026-01-21T23:57:26.875Z","toolUseResult":{"bytes":704240,"code":200,"codeText":"OK","result":"# Context Container Overview\n\nThe `Context` module in returns 0.26.0 provides dependency injection through several container types for managing dependencies in functional Python code.\n\n## Core Containers\n\n**RequiresContext** wraps functions of type `Callable[[EnvType], ReturnType]`, enabling lazy evaluation and typed dependency injection. As the documentation states, it \"represents a context-dependent pure operation\" that composes without executing until dependencies are provided.\n\n**RequiresContextResult** combines `RequiresContext[Result[a, b], env]`, representing \"a context-dependent pure operation that might fail.\" It offers cleaner composition than manually nesting Result within RequiresContext.\n\n**RequiresContextIOResult** wraps `RequiresContext[IOResult[a, b], env]` for \"impure context-related functions that might fail,\" making it suitable for real-world applications involving I/O operations.\n\n**RequiresContextFutureResult** handles `RequiresContext[FutureResult[a, b], env]` for \"impure async function that might fail,\" enabling asynchronous operations with dependency injection.\n\n## Key Methods\n\nAll containers support `.ask()` to access current dependencies within the call stack, `.map()` for composing with pure functions, and various `.bind_*()` methods for chaining operations. The `.modify_env()` method allows transforming environment types.\n\n## Usage Pattern\n\nDependencies are injected at the final moment of execution, preserving purity throughout the composition chain. This approach makes \"code relies on context and which is free from it\" explicit through typing rather than relying on implicit magic.","durationMs":5048,"url":"https://returns.readthedocs.io/en/latest/pages/context.html"},"sourceToolAssistantUUID":"b1801c9f-7963-4273-ba8a-9409ce07e154"}
{"parentUuid":"41b68c81-0902-4a16-8a96-30c1b621a876","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_011zTnDMjKhRB1dAwYYD7uo7","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good. Now I need to get more information about converters and helper functions to complete document #2.","signature":"Eo8CCkYICxgCKkAfX7n8pzTigZDy2e1CVpO3+dFVeRtcYXEEjXfWp6L2G/hOYY3Aw8Va/SfpUTUr5KxwCjwzF519ZddXziBlyhR2EgwkM3QmlfNGsBdPfIoaDEFrIjYlNpr/DkeQAiIwY1KyYvnYSM4juelJGebg1VzWnxTun2v/y2mkhCNql+YTWgAZ9jw6UhqwkGKPqrU2Kncd00vuOuKc0JUoeUuy1chPhjWPb5tEQ9f+s/PcmvoDhlWjyN+dcvNBcJTiNZ/ncJ+EHxguxCbvh7S5r0cSDZMTmnwEKXbskKIxgBWT5euXGxl1ASgrpvJ0hdVQYZgyV7qE3l5LxwAO8WZ57KZbNKLaqc2d/VnrHhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":668,"cache_creation_input_tokens":1232,"cache_read_input_tokens":28007,"cache_creation":{"ephemeral_5m_input_tokens":1232,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRr6QnJMTXAKKG8JL7J","type":"assistant","uuid":"f7d06305-3064-4a22-84ee-118fd7c57986","timestamp":"2026-01-21T23:57:28.655Z"}
{"parentUuid":"f7d06305-3064-4a22-84ee-118fd7c57986","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_011zTnDMjKhRB1dAwYYD7uo7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017vEuzTbfrjriqdTYVQcyZ9","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/converters.html","prompt":"Get detailed information about converter functions for transforming between different container types, including examples of converting between Result, IO, Future, Context, and other types."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":668,"cache_creation_input_tokens":1232,"cache_read_input_tokens":28007,"cache_creation":{"ephemeral_5m_input_tokens":1232,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRr6QnJMTXAKKG8JL7J","type":"assistant","uuid":"a1eba6cd-0b72-49e6-9d8f-fcd95bdbf797","timestamp":"2026-01-21T23:57:29.721Z"}
{"parentUuid":"a1eba6cd-0b72-49e6-9d8f-fcd95bdbf797","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_011zTnDMjKhRB1dAwYYD7uo7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RhZanKhXVQCnKjGDev1W4J","name":"WebFetch","input":{"url":"https://returns.readthedocs.io/en/latest/pages/pointfree.html","prompt":"Get information about pointfree style functions and helper functions in the returns library."}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":668,"cache_creation_input_tokens":1232,"cache_read_input_tokens":28007,"cache_creation":{"ephemeral_5m_input_tokens":1232,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRr6QnJMTXAKKG8JL7J","type":"assistant","uuid":"dee52d88-8e2b-445b-be6d-395d97a180db","timestamp":"2026-01-21T23:57:30.250Z"}
{"parentUuid":"a1eba6cd-0b72-49e6-9d8f-fcd95bdbf797","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017vEuzTbfrjriqdTYVQcyZ9","type":"tool_result","content":"# Converters in Returns Library\n\nThe `returns` library provides utilities for transforming between different container types. Here's what's available:\n\n## Main Converter Functions\n\n**Result  Maybe Conversions:**\n- `result_to_maybe()` transforms a Result container into a Maybe container, discarding error information\n- `maybe_to_result()` converts a Maybe into a Result, with an optional parameter to specify what error value to use for Nothing cases\n\n**Flattening Nested Containers:**\nThe `flatten()` function \"joins two nested containers together,\" merging structures like `IO(IO(1))` into `IO(1)`. This works across different container types including Result, Maybe, and IO.\n\n## Key Behaviors\n\nWhen converting Result to Maybe, both `Success` and `Failure` states are preserved in terms of the wrapped value`Failure` cases simply become `Nothing`. \n\nFor the reverse operation, you can optionally provide a `default_error` parameter. If none is specified, `Nothing` converts to `Failure(None)`.\n\nAn important note: `Success(None)` will convert to `Nothing` in the Maybe representation, so the conversion isn't purely symmetrical when None values are involved.\n\nThese converters enable flexible composition across the library's container ecosystem while maintaining type safety through Python's type hints."}]},"uuid":"41229e9b-a70b-44a0-b4eb-01915ee1a487","timestamp":"2026-01-21T23:57:34.174Z","toolUseResult":{"bytes":42112,"code":200,"codeText":"OK","result":"# Converters in Returns Library\n\nThe `returns` library provides utilities for transforming between different container types. Here's what's available:\n\n## Main Converter Functions\n\n**Result  Maybe Conversions:**\n- `result_to_maybe()` transforms a Result container into a Maybe container, discarding error information\n- `maybe_to_result()` converts a Maybe into a Result, with an optional parameter to specify what error value to use for Nothing cases\n\n**Flattening Nested Containers:**\nThe `flatten()` function \"joins two nested containers together,\" merging structures like `IO(IO(1))` into `IO(1)`. This works across different container types including Result, Maybe, and IO.\n\n## Key Behaviors\n\nWhen converting Result to Maybe, both `Success` and `Failure` states are preserved in terms of the wrapped value`Failure` cases simply become `Nothing`. \n\nFor the reverse operation, you can optionally provide a `default_error` parameter. If none is specified, `Nothing` converts to `Failure(None)`.\n\nAn important note: `Success(None)` will convert to `Nothing` in the Maybe representation, so the conversion isn't purely symmetrical when None values are involved.\n\nThese converters enable flexible composition across the library's container ecosystem while maintaining type safety through Python's type hints.","durationMs":3896,"url":"https://returns.readthedocs.io/en/latest/pages/converters.html"},"sourceToolAssistantUUID":"a1eba6cd-0b72-49e6-9d8f-fcd95bdbf797"}
{"parentUuid":"dee52d88-8e2b-445b-be6d-395d97a180db","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RhZanKhXVQCnKjGDev1W4J","type":"tool_result","content":"# Pointfree Style in the Returns Library\n\nThe Returns library provides pointfree functions to facilitate functional composition with containers. Here's what you need to know:\n\n## Core Concept\n\nPointfree style reverses typical method call semantics. Instead of `x.f(y)`, you write `f(x)(y)`. This enables better function composition in pipelines.\n\n## Key Functions\n\n**map_()** - Lifts regular functions to work with containers, transforming `a -> b` into `Container[a] -> Container[b]`.\n\n**bind()** - Handles functions returning containers, converting `a -> Container[b]` to `Container[a] -> Container[b]`.\n\n**alt()** - Operates on error states: \"it modifies the function's signature from: `a -> b` to: `Container[_, a] -> Container[_, b]`\"\n\n**lash()** - Like bind but for failed containers, enabling recovery operations.\n\n**apply()** - Enables using container-wrapped functions as callables.\n\n## Why Use Pointfree?\n\nContainer methods don't compose easily with other functions. Pointfree alternatives provide \"reverse semantics\" that work naturally in pipeline syntax, making code more readable and maintainable.\n\nThe library offers specialized variants (bind_io, bind_result, bind_future, etc.) for different container types, plus async support through bind_async and bind_awaitable."}]},"uuid":"0c738b0e-470e-4149-a52c-53052ee776b3","timestamp":"2026-01-21T23:57:34.988Z","toolUseResult":{"bytes":273879,"code":200,"codeText":"OK","result":"# Pointfree Style in the Returns Library\n\nThe Returns library provides pointfree functions to facilitate functional composition with containers. Here's what you need to know:\n\n## Core Concept\n\nPointfree style reverses typical method call semantics. Instead of `x.f(y)`, you write `f(x)(y)`. This enables better function composition in pipelines.\n\n## Key Functions\n\n**map_()** - Lifts regular functions to work with containers, transforming `a -> b` into `Container[a] -> Container[b]`.\n\n**bind()** - Handles functions returning containers, converting `a -> Container[b]` to `Container[a] -> Container[b]`.\n\n**alt()** - Operates on error states: \"it modifies the function's signature from: `a -> b` to: `Container[_, a] -> Container[_, b]`\"\n\n**lash()** - Like bind but for failed containers, enabling recovery operations.\n\n**apply()** - Enables using container-wrapped functions as callables.\n\n## Why Use Pointfree?\n\nContainer methods don't compose easily with other functions. Pointfree alternatives provide \"reverse semantics\" that work naturally in pipeline syntax, making code more readable and maintainable.\n\nThe library offers specialized variants (bind_io, bind_result, bind_future, etc.) for different container types, plus async support through bind_async and bind_awaitable.","durationMs":4709,"url":"https://returns.readthedocs.io/en/latest/pages/pointfree.html"},"sourceToolAssistantUUID":"dee52d88-8e2b-445b-be6d-395d97a180db"}
{"parentUuid":"0c738b0e-470e-4149-a52c-53052ee776b3","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FRALKhF1sqna5Fe5pv2dYT","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Great! Now I have enough information to create comprehensive markdown documents. Let me plan this out:\n\nDocument #1 should cover:\n- Maybe (Some, Nothing)\n- Result (Success, Failure)\n- IO\n- Future\n- Safe decorator\n- future_safe decorator\n- Context (RequiresContext basics)\n- Pipelines (flow, pipe, managed)\n\nDocument #2 should cover:\n- Methods (cond, unwrap_or_failure, partition)\n- RequiresContext (deeper dive)\n- Converters (result_to_maybe, maybe_to_result, flatten)\n- Helper Functions (pointfree style functions)\n- Primitive Types:\n  - IOResult\n  - FutureResult\n  - RequiresContextResult\n  - RequiresContextIOResult\n  - RequiresContextFutureResult\n\nLet me create these documents with detailed examples, TOC, and section links.","signature":"EvUGCkYICxgCKkBVdX6VWNBNc6ZvMOY9RaDLW8OfO0rptIfBbbln2q/nS4TzcHjn6b/76vEg3X2AXlrEfzi8GZUuvt0WENIrMnmiEgw+DTTCK7N6pZePkQsaDGvScXgPaktSdiZnFCIwBP+/ZCuWnV46ZDWu6i4ek6R4Xd6adCxKwFC1gIGannjlMijT89QoT3QzYcNivG8sKtwFsVrhEGeYzU+ThLNRPbKODGKdgQ1K2Bm1ZWy3PM5EBC34cU3Czfq/sJFbx2oZUwhhC8l/kfKnQBGZF8pZdzQJZu4PKwIJ15bcF+vGPMleXaiLdd9JVVeZFu2KrljKMcS7gptEreBWiP7ujNm6rvxZ+vlOXPmmb0tn7hP22iO1mWmlFVl8qfkoIAPnq5gTTkiWUat4iChgytqWjpKlwNd1GMCckeOiXAXvqfaDBTphXsDbE0GzdeLIxuzmCuZ6fokGmEnqg2ayedMeXFlguX814Dc+JTU1zhu+pfVe1FCU1N1UDrbIMhvLqxi0yFbiYD8qX4ljpXB58urSGHrwmgn0nZWWq61L+cs5QweeWaPesVHJ4o7IEceiiOFXGikeKyjaAYP/5PNITLV5U4IBtMCDyopZqWB3XfbekzGTSprlat/VcpXpiuXE89XqIrmYBF44rORlv5FIiZR3dJ1s9DyxDAGcvCJ3V4lSXvXgLqnKesN5J4Ef4r19Qj47bEs7c20u4+9PRsBx31GzRN4zLbXFBiK51O1YU2Z9hERSIRtHhkHCzD9iBP/oz6y5d0gTKk5ovjRcife6BcqFzkL1BEuTJnpIKtO2kQj4q3XlZlAdZ2iNrpAQxR1nc35A1AL7G1OMHK1gHyBwekbN4AxqwZPNMQeEYNagJv+0tV7TGbo5lIR9ThcIwWkjus0zjnW9wkW9/tgZS6VVlZbFLfh/MD1AMmTnMDwtn1kEwvbXqIc337oPCmsDOqyFVspSev57Ivu06y+OPO7HjxM8gj7JWYbm80OD1caaUov0LK1B7XmQMFynisvAe2eap7as9gbZ5hkCxiwDBVkry4fqZzOXgXgD6S+xWHUyVR2jCoUueggbsWbe4e9gRJlLQ0uAVMUqFlSmol0sdQ5lQOrZU3pCdc6ngngWkPUuJQcd+Bdax5AtQHEd51ftPVN63qNJtRGtGIYIOofJU8ZCFXW16u9DGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":1675,"cache_read_input_tokens":29239,"cache_creation":{"ephemeral_5m_input_tokens":1675,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMRrh8LoPBWbawuQGgt5","type":"assistant","uuid":"10cb582b-e2c1-47aa-a0d2-52a6d7b18549","timestamp":"2026-01-21T23:57:39.059Z"}
{"parentUuid":"10cb582b-e2c1-47aa-a0d2-52a6d7b18549","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FRALKhF1sqna5Fe5pv2dYT","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll create comprehensive markdown documentation with detailed examples. Let me start by creating the directory structure and both documents."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":1675,"cache_read_input_tokens":29239,"cache_creation":{"ephemeral_5m_input_tokens":1675,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMRrh8LoPBWbawuQGgt5","type":"assistant","uuid":"34f0a27e-7c2e-4819-acd9-32bf711c3278","timestamp":"2026-01-21T23:57:39.559Z"}
{"parentUuid":"34f0a27e-7c2e-4819-acd9-32bf711c3278","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FRALKhF1sqna5Fe5pv2dYT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XsYGZvVQyzNDEaPekbmMiT","name":"Bash","input":{"command":"mkdir -p docs/python/references","description":"Create directory for returns library documentation"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":1675,"cache_read_input_tokens":29239,"cache_creation":{"ephemeral_5m_input_tokens":1675,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMRrh8LoPBWbawuQGgt5","type":"assistant","uuid":"a1b94c9d-3da9-438a-b7e3-19b4a85ea472","timestamp":"2026-01-21T23:57:40.082Z"}
{"parentUuid":"a1b94c9d-3da9-438a-b7e3-19b4a85ea472","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XsYGZvVQyzNDEaPekbmMiT","type":"tool_result","content":"","is_error":false}]},"uuid":"a573d908-627a-45c5-9571-1d949ae2a74c","timestamp":"2026-01-21T23:57:40.217Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"a1b94c9d-3da9-438a-b7e3-19b4a85ea472"}
{"parentUuid":"a573d908-627a-45c5-9571-1d949ae2a74c","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KiRytswa5oCAPbBTXuHMpF","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good. Now let me create the first document covering Maybe, Result, Success, Failure, IO, Future, Safe, future_safe, Context, and Pipelines.","signature":"ErQCCkYICxgCKkDzGMW8KgvR+WPmJfSUYK6djcW5DiVIe+8VORFwI2ykGOlXcwtoZyUk1k84LNAzCerYXiyuL439hCq9G1PdKvKNEgwGzO4YN12qMxaJuDIaDJUjsUbRfuMn8gv3UyIwhMr3NYBsXz+FwQ172Bsy8K079MWvU1mrOkADEXaNgMRRunLO06kDJakk/U58LPB5KpsBOoaJXwFPpG/3gWKdQO27VZYmzrUWxd2gyhTA0CIhHFYWQfnWI+mOPEL7dYq7E2Ilrf9Faj7/futddFIIRLHtrFhWFlftJYyWEBa6AoUJLWBgNrxD6OKk7TQr4oFdSNd8aH5SbCnllMbGnuOxanPP7+BbdxazcFZVSlSecthL0aDrIpupbRxX54vo2fICZg2AGvWwjn5WcilR3l4YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":346,"cache_read_input_tokens":30914,"cache_creation":{"ephemeral_5m_input_tokens":346,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRs5ahhUa3fWWiD2EyL","type":"assistant","uuid":"14b8015f-d52b-48ed-b0f4-5cee522eb902","timestamp":"2026-01-21T23:57:41.755Z"}
{"parentUuid":"14b8015f-d52b-48ed-b0f4-5cee522eb902","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KiRytswa5oCAPbBTXuHMpF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RRNXzk47gTQUPvNPBzHRK3","name":"Write","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/docs/python/references/returns-part1-core-types.md","content":"# Returns Library Guide - Part 1: Core Types and Containers\n\nA comprehensive guide to the fundamental types and containers in the `returns` library for functional programming in Python.\n\n## Table of Contents\n\n1. [Introduction](#introduction)\n2. [Maybe Container](#maybe-container)\n   - [Basic Usage](#maybe-basic-usage)\n   - [Creating Maybe Instances](#creating-maybe-instances)\n   - [Working with Maybe](#working-with-maybe)\n   - [Chaining Operations](#chaining-maybe-operations)\n   - [Pattern Matching](#maybe-pattern-matching)\n3. [Result Container](#result-container)\n   - [Success and Failure](#success-and-failure)\n   - [Creating Results](#creating-results)\n   - [Transforming Results](#transforming-results)\n   - [Error Handling](#result-error-handling)\n   - [Pattern Matching](#result-pattern-matching)\n4. [Safe Decorator](#safe-decorator)\n   - [Basic Safe Usage](#basic-safe-usage)\n   - [Filtering Exceptions](#filtering-exceptions)\n   - [Composing Safe Functions](#composing-safe-functions)\n5. [IO Container](#io-container)\n   - [Marking Impure Operations](#marking-impure-operations)\n   - [Creating IO Instances](#creating-io-instances)\n   - [Composing IO Operations](#composing-io-operations)\n   - [IO vs IOResult](#io-vs-ioresult)\n6. [Future Container](#future-container)\n   - [Basic Future Usage](#basic-future-usage)\n   - [FutureResult](#futureresult)\n   - [Composing Async Operations](#composing-async-operations)\n7. [future_safe Decorator](#future_safe-decorator)\n   - [Basic future_safe Usage](#basic-future_safe-usage)\n   - [Error Handling in Async Code](#error-handling-in-async-code)\n8. [Context Container](#context-container)\n   - [RequiresContext Basics](#requirescontext-basics)\n   - [Dependency Injection](#dependency-injection)\n   - [Composing with Context](#composing-with-context)\n9. [Pipelines](#pipelines)\n   - [flow() Function](#flow-function)\n   - [pipe() Function](#pipe-function)\n   - [managed() Function](#managed-function)\n\n---\n\n## Introduction\n\nThe `returns` library brings functional programming patterns to Python, providing container types that make error handling, side effects, and asynchronous operations more explicit and composable. This guide covers the core types and their usage patterns.\n\n**Installation:**\n```bash\npip install returns\n```\n\n**Import conventions:**\n```python\nfrom returns.maybe import Maybe, Some, Nothing\nfrom returns.result import Result, Success, Failure, safe\nfrom returns.io import IO, IOResult, impure, impure_safe\nfrom returns.future import Future, FutureResult, future_safe\nfrom returns.context import RequiresContext\nfrom returns.pipeline import flow, pipe, managed\n```\n\n---\n\n## Maybe Container\n\nThe `Maybe` container eliminates `None`-related bugs by providing explicit `Some` and `Nothing` variants.\n\n### Maybe Basic Usage\n\n**Problem:** Traditional nullable code requires constant None checks:\n```python\ndef get_user_email(user_id: int) -> str | None:\n    user = find_user(user_id)\n    if user is None:\n        return None\n    if user.profile is None:\n        return None\n    if user.profile.email is None:\n        return None\n    return user.profile.email.lower()\n```\n\n**Solution with Maybe:**\n```python\nfrom returns.maybe import Maybe, Some, Nothing\n\ndef get_user_email(user_id: int) -> Maybe[str]:\n    return (\n        find_user(user_id)\n        .bind_optional(lambda user: user.profile)\n        .bind_optional(lambda profile: profile.email)\n        .map(str.lower)\n    )\n```\n\n### Creating Maybe Instances\n\n**Example 1: From Optional Values**\n```python\nfrom returns.maybe import Maybe\n\n# Convert None to Nothing, values to Some\nresult1 = Maybe.from_optional(None)  # Nothing\nresult2 = Maybe.from_optional(42)    # Some(42)\nresult3 = Maybe.from_optional(\"hello\")  # Some(\"hello\")\n\nprint(result1)  # <Nothing>\nprint(result2)  # <Some: 42>\n```\n\n**Example 2: Explicit Construction**\n```python\nfrom returns.maybe import Some, Nothing\n\n# Direct construction\nsuccess = Some(100)\nfailure = Nothing\n\n# Even None can be wrapped if needed\nwrapped_none = Maybe.from_value(None)  # Some(None)\n```\n\n**Example 3: From Functions**\n```python\nfrom returns.maybe import maybe\n\n@maybe\ndef safe_divide(a: int, b: int) -> int | None:\n    if b == 0:\n        return None\n    return a // b\n\nresult1 = safe_divide(10, 2)  # Some(5)\nresult2 = safe_divide(10, 0)  # Nothing\n```\n\n### Working with Maybe\n\n**Example 1: Extracting Values**\n```python\nfrom returns.maybe import Some, Nothing\n\nvalue = Some(42)\nempty = Nothing\n\n# Get value or provide default\nprint(value.value_or(0))   # 42\nprint(empty.value_or(0))   # 0\n\n# Unwrap (raises if Nothing)\nprint(value.unwrap())      # 42\n# empty.unwrap()           # Raises UnwrapFailedError\n\n# Lazy default evaluation\nexpensive_default = lambda: expensive_computation()\nresult = empty.or_else_call(expensive_default)\n```\n\n**Example 2: Mapping Over Maybe**\n```python\nfrom returns.maybe import Some, Nothing\n\ndef double(x: int) -> int:\n    return x * 2\n\nresult1 = Some(5).map(double)    # Some(10)\nresult2 = Nothing.map(double)     # Nothing\n\n# Chain multiple maps\nresult3 = Some(3).map(double).map(lambda x: x + 1)  # Some(7)\n```\n\n**Example 3: Conditional Operations**\n```python\nfrom returns.maybe import Some, Nothing\n\ndef is_positive(x: int) -> bool:\n    return x > 0\n\n# Filter-like behavior\nvalue = Some(10)\nresult = value if is_positive(value.unwrap()) else Nothing\n# Better: use custom filter logic with bind\n```\n\n### Chaining Maybe Operations\n\n**Example 1: Sequential Binds**\n```python\nfrom returns.maybe import Maybe, Some\n\ndef safe_int(s: str) -> Maybe[int]:\n    try:\n        return Some(int(s))\n    except ValueError:\n        return Maybe.empty\n\ndef safe_reciprocal(x: int) -> Maybe[float]:\n    if x == 0:\n        return Maybe.empty\n    return Some(1.0 / x)\n\n# Chain operations\nresult1 = safe_int(\"10\").bind(safe_reciprocal)  # Some(0.1)\nresult2 = safe_int(\"0\").bind(safe_reciprocal)   # Nothing\nresult3 = safe_int(\"abc\").bind(safe_reciprocal) # Nothing\n```\n\n**Example 2: Working with Optionals**\n```python\nfrom returns.maybe import Maybe\n\nclass Address:\n    def __init__(self, city: str | None):\n        self.city = city\n\nclass User:\n    def __init__(self, address: Address | None):\n        self.address = address\n\ndef get_city(user: User | None) -> Maybe[str]:\n    return (\n        Maybe.from_optional(user)\n        .bind_optional(lambda u: u.address)\n        .bind_optional(lambda a: a.city)\n    )\n\nuser1 = User(Address(\"New York\"))\nuser2 = User(Address(None))\nuser3 = User(None)\n\nprint(get_city(user1))  # Some(\"New York\")\nprint(get_city(user2))  # Nothing\nprint(get_city(user3))  # Nothing\n```\n\n**Example 3: Complex Composition**\n```python\nfrom returns.maybe import Maybe, Some\n\ndef parse_config(text: str) -> Maybe[dict]:\n    \"\"\"Parse configuration from text.\"\"\"\n    import json\n    try:\n        return Some(json.loads(text))\n    except json.JSONDecodeError:\n        return Maybe.empty\n\ndef get_database_url(config: dict) -> Maybe[str]:\n    \"\"\"Extract database URL from config.\"\"\"\n    return Maybe.from_optional(config.get('database', {}).get('url'))\n\ndef validate_url(url: str) -> Maybe[str]:\n    \"\"\"Validate URL format.\"\"\"\n    if url.startswith(('postgres://', 'mysql://')):\n        return Some(url)\n    return Maybe.empty\n\n# Complete pipeline\nconfig_text = '{\"database\": {\"url\": \"postgres://localhost/mydb\"}}'\nresult = (\n    parse_config(config_text)\n    .bind(get_database_url)\n    .bind(validate_url)\n)\nprint(result)  # Some(\"postgres://localhost/mydb\")\n```\n\n### Maybe Pattern Matching\n\n**Python 3.10+ Pattern Matching:**\n```python\nfrom returns.maybe import Maybe, Some\n\ndef describe_maybe(value: Maybe[int]) -> str:\n    match value:\n        case Some(n):\n            return f\"Got value: {n}\"\n        case Maybe.empty:\n            return \"Got nothing\"\n\nprint(describe_maybe(Some(42)))    # \"Got value: 42\"\nprint(describe_maybe(Maybe.empty)) # \"Got nothing\"\n\n# Match with guards\ndef classify_number(value: Maybe[int]) -> str:\n    match value:\n        case Some(n) if n > 0:\n            return \"Positive\"\n        case Some(n) if n < 0:\n            return \"Negative\"\n        case Some(0):\n            return \"Zero\"\n        case Maybe.empty:\n            return \"No value\"\n```\n\n---\n\n## Result Container\n\nThe `Result` container makes error handling explicit by returning either `Success` or `Failure` instead of raising exceptions.\n\n### Success and Failure\n\n**Example 1: Basic Usage**\n```python\nfrom returns.result import Success, Failure\n\n# Successful operation\ngood_result: Result[int, str] = Success(42)\n\n# Failed operation\nbad_result: Result[int, str] = Failure(\"Something went wrong\")\n\nprint(good_result)  # <Success: 42>\nprint(bad_result)   # <Failure: Something went wrong>\n```\n\n**Example 2: Type Safety**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef divide(a: int, b: int) -> Result[float, str]:\n    if b == 0:\n        return Failure(\"Division by zero\")\n    return Success(a / b)\n\nresult1 = divide(10, 2)   # Success(5.0)\nresult2 = divide(10, 0)   # Failure(\"Division by zero\")\n```\n\n**Example 3: Using ResultE Alias**\n```python\nfrom returns.result import ResultE, Success, Failure\n\n# ResultE is Result[T, Exception]\ndef parse_int(s: str) -> ResultE[int]:\n    try:\n        return Success(int(s))\n    except ValueError as e:\n        return Failure(e)\n\nresult = parse_int(\"42\")   # Success(42)\nerror = parse_int(\"abc\")   # Failure(ValueError(...))\n```\n\n### Creating Results\n\n**Example 1: From Try-Catch**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef read_file(path: str) -> Result[str, str]:\n    try:\n        with open(path, 'r') as f:\n            return Success(f.read())\n    except FileNotFoundError:\n        return Failure(f\"File not found: {path}\")\n    except PermissionError:\n        return Failure(f\"Permission denied: {path}\")\n    except Exception as e:\n        return Failure(f\"Unexpected error: {e}\")\n\ncontent = read_file(\"config.txt\")\n```\n\n**Example 2: Validation Functions**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef validate_email(email: str) -> Result[str, str]:\n    if '@' not in email:\n        return Failure(\"Email must contain @\")\n    if '.' not in email.split('@')[1]:\n        return Failure(\"Email domain must contain .\")\n    return Success(email)\n\ndef validate_age(age: int) -> Result[int, str]:\n    if age < 0:\n        return Failure(\"Age cannot be negative\")\n    if age > 150:\n        return Failure(\"Age too high\")\n    return Success(age)\n\nemail_result = validate_email(\"user@example.com\")  # Success\nage_result = validate_age(25)                      # Success\n```\n\n**Example 3: Converting from Other Types**\n```python\nfrom returns.result import Result, Success, Failure\nfrom returns.maybe import Maybe, Some, Nothing\n\ndef maybe_to_result(maybe_val: Maybe[int]) -> Result[int, str]:\n    match maybe_val:\n        case Some(value):\n            return Success(value)\n        case Maybe.empty:\n            return Failure(\"No value provided\")\n\nresult1 = maybe_to_result(Some(42))      # Success(42)\nresult2 = maybe_to_result(Maybe.empty)   # Failure(\"No value provided\")\n```\n\n### Transforming Results\n\n**Example 1: Mapping Success Values**\n```python\nfrom returns.result import Success, Failure\n\nresult = Success(5)\ndoubled = result.map(lambda x: x * 2)        # Success(10)\nstringified = doubled.map(str)                # Success(\"10\")\n\n# Failure is unchanged by map\nfailure = Failure(\"error\")\nmapped_failure = failure.map(lambda x: x * 2) # Failure(\"error\")\n```\n\n**Example 2: Transforming Errors with alt**\n```python\nfrom returns.result import Success, Failure\n\ndef make_error_user_friendly(error: str) -> str:\n    return f\"Oops! {error}\"\n\nresult1 = Success(42).alt(make_error_user_friendly)  # Success(42)\nresult2 = Failure(\"DB error\").alt(make_error_user_friendly)\n# Failure(\"Oops! DB error\")\n\n# Chain multiple transformations\nresult3 = (\n    Failure(\"connection timeout\")\n    .alt(str.upper)\n    .alt(lambda e: f\"ERROR: {e}\")\n)\n# Failure(\"ERROR: CONNECTION TIMEOUT\")\n```\n\n**Example 3: Binding Results**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef safe_sqrt(x: float) -> Result[float, str]:\n    if x < 0:\n        return Failure(\"Cannot take square root of negative number\")\n    return Success(x ** 0.5)\n\ndef safe_reciprocal(x: float) -> Result[float, str]:\n    if x == 0:\n        return Failure(\"Cannot divide by zero\")\n    return Success(1 / x)\n\n# Successful chain\nresult1 = Success(16.0).bind(safe_sqrt).bind(safe_reciprocal)\n# Success(0.25)\n\n# Fails at first step\nresult2 = Success(-4.0).bind(safe_sqrt).bind(safe_reciprocal)\n# Failure(\"Cannot take square root of negative number\")\n\n# Fails at second step\nresult3 = Success(0.0).bind(safe_sqrt).bind(safe_reciprocal)\n# Failure(\"Cannot divide by zero\")\n```\n\n### Result Error Handling\n\n**Example 1: Recovering from Errors with lash**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef fetch_from_cache(key: str) -> Result[str, str]:\n    return Failure(\"Cache miss\")\n\ndef fetch_from_database(error: str) -> Result[str, str]:\n    print(f\"Cache failed ({error}), trying database\")\n    return Success(\"data from database\")\n\ndef fetch_from_api(error: str) -> Result[str, str]:\n    print(f\"Database failed ({error}), trying API\")\n    return Success(\"data from API\")\n\n# Try cache, fallback to database\nresult = fetch_from_cache(\"user:123\").lash(fetch_from_database)\n# Prints: Cache failed (Cache miss), trying database\n# Success(\"data from database\")\n\n# Chain multiple fallbacks\nresult2 = (\n    fetch_from_cache(\"user:456\")\n    .lash(lambda _: Failure(\"DB down\"))\n    .lash(fetch_from_api)\n)\n# Prints: Database failed (DB down), trying API\n# Success(\"data from API\")\n```\n\n**Example 2: Value Extraction**\n```python\nfrom returns.result import Success, Failure\n\n# Get value or default\nresult1 = Success(42).value_or(0)       # 42\nresult2 = Failure(\"error\").value_or(0)  # 0\n\n# Unwrap (raises on Failure)\nvalue = Success(100).unwrap()           # 100\n# Failure(\"error\").unwrap()             # Raises UnwrapFailedError\n\n# Get failure value\nerror = Failure(\"oops\").failure()       # \"oops\"\n# Success(42).failure()                 # Raises UnwrapFailedError\n```\n\n**Example 3: Swapping Success and Failure**\n```python\nfrom returns.result import Success, Failure\n\n# Swap success and failure\nresult1 = Success(42).swap()        # Failure(42)\nresult2 = Failure(\"error\").swap()   # Success(\"error\")\n\n# Useful for inverting logic\ndef is_not_found(result: Result[str, str]) -> Result[str, str]:\n    \"\"\"Convert 'not found' errors into success.\"\"\"\n    return result.swap().map(lambda e: \"Item does not exist\")\n\noriginal = Failure(\"Not found\")\ninverted = is_not_found(original)  # Success(\"Item does not exist\")\n```\n\n### Result Pattern Matching\n\n**Python 3.10+ Pattern Matching:**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef handle_result(result: Result[int, str]) -> str:\n    match result:\n        case Success(value):\n            return f\"Success! Value is {value}\"\n        case Failure(error):\n            return f\"Failed with error: {error}\"\n\nprint(handle_result(Success(42)))        # \"Success! Value is 42\"\nprint(handle_result(Failure(\"oops\")))    # \"Failed with error: oops\"\n\n# With guards and nested matching\ndef classify_result(result: Result[int, Exception]) -> str:\n    match result:\n        case Success(n) if n > 0:\n            return \"Positive success\"\n        case Success(n) if n < 0:\n            return \"Negative success\"\n        case Success(0):\n            return \"Zero success\"\n        case Failure(ValueError()):\n            return \"Value error occurred\"\n        case Failure(error):\n            return f\"Other error: {type(error).__name__}\"\n```\n\n---\n\n## Safe Decorator\n\nThe `@safe` decorator automatically converts exception-throwing functions into functions that return `Result` containers.\n\n### Basic Safe Usage\n\n**Example 1: Simple Conversion**\n```python\nfrom returns.result import safe\n\n@safe\ndef divide(a: int, b: int) -> float:\n    return a / b\n\nresult1 = divide(10, 2)   # Success(5.0)\nresult2 = divide(10, 0)   # Failure(ZeroDivisionError(...))\n```\n\n**Example 2: Working with Files**\n```python\nfrom returns.result import safe, ResultE\nimport json\n\n@safe\ndef load_json(filename: str) -> dict:\n    with open(filename, 'r') as f:\n        return json.load(f)\n\nconfig = load_json(\"config.json\")\n# Success({...}) if file exists and is valid JSON\n# Failure(FileNotFoundError(...)) if file doesn't exist\n# Failure(JSONDecodeError(...)) if invalid JSON\n\n# Use the result\nmatch config:\n    case Success(data):\n        print(f\"Loaded {len(data)} config items\")\n    case Failure(error):\n        print(f\"Failed to load config: {error}\")\n```\n\n**Example 3: Database Operations**\n```python\nfrom returns.result import safe, ResultE\n\n@safe\ndef fetch_user(user_id: int) -> dict:\n    # Simulated database call that might raise\n    import sqlite3\n    conn = sqlite3.connect('users.db')\n    cursor = conn.execute('SELECT * FROM users WHERE id = ?', (user_id,))\n    row = cursor.fetchone()\n    if row is None:\n        raise ValueError(f\"User {user_id} not found\")\n    return dict(row)\n\nuser = fetch_user(123)\n# Success({...}) if user exists\n# Failure(ValueError(...)) if not found\n# Failure(sqlite3.Error(...)) for DB errors\n```\n\n### Filtering Exceptions\n\n**Example 1: Catching Specific Exceptions**\n```python\nfrom returns.result import safe\n\n@safe(exceptions=(ValueError,))\ndef parse_positive_int(s: str) -> int:\n    value = int(s)\n    if value <= 0:\n        raise ValueError(\"Must be positive\")\n    return value\n\nresult1 = parse_positive_int(\"42\")    # Success(42)\nresult2 = parse_positive_int(\"-5\")    # Failure(ValueError(...))\n# parse_positive_int(\"abc\")           # Raises TypeError (not caught)\n```\n\n**Example 2: Multiple Exception Types**\n```python\nfrom returns.result import safe\n\n@safe(exceptions=(FileNotFoundError, PermissionError, json.JSONDecodeError))\ndef load_config(path: str) -> dict:\n    import json\n    with open(path, 'r') as f:\n        return json.load(f)\n\nconfig = load_config(\"settings.json\")\n# Catches FileNotFoundError, PermissionError, JSONDecodeError\n# Other exceptions (like MemoryError) would propagate\n```\n\n**Example 3: Custom Exception Handling**\n```python\nfrom returns.result import safe\n\nclass ValidationError(Exception):\n    pass\n\nclass BusinessError(Exception):\n    pass\n\n@safe(exceptions=(ValidationError, BusinessError))\ndef process_payment(amount: float, account: str) -> str:\n    if amount <= 0:\n        raise ValidationError(\"Amount must be positive\")\n    if not account.startswith(\"ACC\"):\n        raise ValidationError(\"Invalid account format\")\n    if amount > 10000:\n        raise BusinessError(\"Amount exceeds limit\")\n    return f\"Payment of ${amount} to {account} processed\"\n\nresult1 = process_payment(100, \"ACC123\")     # Success(...)\nresult2 = process_payment(-50, \"ACC123\")     # Failure(ValidationError(...))\nresult3 = process_payment(20000, \"ACC123\")   # Failure(BusinessError(...))\n```\n\n### Composing Safe Functions\n\n**Example 1: Chaining Safe Operations**\n```python\nfrom returns.result import safe\n\n@safe\ndef fetch_user_id(email: str) -> int:\n    users = {\"alice@example.com\": 1, \"bob@example.com\": 2}\n    if email not in users:\n        raise KeyError(f\"User not found: {email}\")\n    return users[email]\n\n@safe\ndef fetch_user_data(user_id: int) -> dict:\n    data = {1: {\"name\": \"Alice\"}, 2: {\"name\": \"Bob\"}}\n    if user_id not in data:\n        raise ValueError(f\"No data for user {user_id}\")\n    return data[user_id]\n\ndef get_user(email: str) -> Result[dict, Exception]:\n    return fetch_user_id(email).bind(fetch_user_data)\n\nresult = get_user(\"alice@example.com\")\n# Success({\"name\": \"Alice\"})\n\nresult2 = get_user(\"unknown@example.com\")\n# Failure(KeyError(\"User not found: unknown@example.com\"))\n```\n\n**Example 2: Pipeline with Safe Functions**\n```python\nfrom returns.result import safe\nfrom returns.pipeline import flow\n\n@safe\ndef parse_int(s: str) -> int:\n    return int(s)\n\n@safe\ndef validate_positive(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Must be positive\")\n    return n\n\n@safe\ndef calculate_square(n: int) -> int:\n    return n * n\n\n# This won't work directly with flow because safe returns Result\n# Instead, use bind:\ndef process_number(s: str) -> Result[int, Exception]:\n    return (\n        parse_int(s)\n        .bind(validate_positive)\n        .bind(calculate_square)\n    )\n\nresult1 = process_number(\"5\")    # Success(25)\nresult2 = process_number(\"-3\")   # Failure(ValueError(...))\nresult3 = process_number(\"abc\")  # Failure(ValueError(...))\n```\n\n**Example 3: Combining Safe with Manual Result Creation**\n```python\nfrom returns.result import safe, Success, Failure, Result\n\n@safe\ndef fetch_from_api(url: str) -> dict:\n    import requests\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.json()\n\ndef validate_response(data: dict) -> Result[dict, str]:\n    if 'id' not in data:\n        return Failure(\"Response missing 'id' field\")\n    if 'name' not in data:\n        return Failure(\"Response missing 'name' field\")\n    return Success(data)\n\ndef fetch_and_validate(url: str) -> Result[dict, str]:\n    return (\n        fetch_from_api(url)\n        .alt(lambda e: f\"API error: {str(e)}\")  # Convert exception to string\n        .bind(validate_response)\n    )\n\nresult = fetch_and_validate(\"https://api.example.com/users/1\")\n# Success({...}) if API call succeeds and validation passes\n# Failure(\"API error: ...\") for network/HTTP errors\n# Failure(\"Response missing...\") for validation errors\n```\n\n---\n\n## IO Container\n\nThe `IO` container marks functions that perform side effects, making impure operations explicit in your type signatures.\n\n### Marking Impure Operations\n\n**Example 1: Pure vs Impure Functions**\n```python\n# Pure function - always returns same output for same input\ndef add(a: int, b: int) -> int:\n    return a + b\n\n# Impure function - output varies or has side effects\nfrom returns.io import IO, impure\nimport random\n\n@impure\ndef get_random_number() -> int:\n    return random.randint(1, 100)\n\n# Type signature shows it's impure\nresult: IO[int] = get_random_number()\n# Result is wrapped, must be unwrapped to use\n```\n\n**Example 2: Marking Side Effects**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef log_message(message: str) -> None:\n    print(f\"[LOG] {message}\")\n    with open('app.log', 'a') as f:\n        f.write(message + '\\n')\n\n@impure\ndef get_current_time() -> float:\n    import time\n    return time.time()\n\n# These return IO containers\nlog_io: IO[None] = log_message(\"Application started\")\ntime_io: IO[float] = get_current_time()\n```\n\n**Example 3: Database Operations**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef fetch_users() -> list[dict]:\n    import sqlite3\n    conn = sqlite3.connect('app.db')\n    cursor = conn.execute('SELECT * FROM users')\n    return [dict(row) for row in cursor.fetchall()]\n\n@impure\ndef save_user(user: dict) -> int:\n    import sqlite3\n    conn = sqlite3.connect('app.db')\n    cursor = conn.execute(\n        'INSERT INTO users (name, email) VALUES (?, ?)',\n        (user['name'], user['email'])\n    )\n    conn.commit()\n    return cursor.lastrowid\n\nusers_io: IO[list[dict]] = fetch_users()\nsave_io: IO[int] = save_user({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n```\n\n### Creating IO Instances\n\n**Example 1: Using @impure Decorator**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef read_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\n@impure\ndef write_file(path: str, content: str) -> None:\n    with open(path, 'w') as f:\n        f.write(content)\n\ncontent_io = read_file('data.txt')\nwrite_io = write_file('output.txt', 'Hello, World!')\n```\n\n**Example 2: Manual Construction with from_value**\n```python\nfrom returns.io import IO\nimport os\n\ndef get_environment() -> IO[dict]:\n    return IO.from_value(dict(os.environ))\n\ndef get_working_directory() -> IO[str]:\n    return IO.from_value(os.getcwd())\n\nenv_io = get_environment()\ncwd_io = get_working_directory()\n\n# Execute IO to get values\nenv = env_io.unwrap()\ncwd = cwd_io.unwrap()\n```\n\n**Example 3: Lifting Pure Functions**\n```python\nfrom returns.io import IO\n\n# Pure function\ndef calculate_total(items: list[float]) -> float:\n    return sum(items)\n\n# Lift to IO context (though this is unusual since it's pure)\ndef calculate_total_io(items: list[float]) -> IO[float]:\n    return IO(calculate_total(items))\n\nresult = calculate_total_io([1.0, 2.0, 3.0])  # IO[float]\n```\n\n### Composing IO Operations\n\n**Example 1: Mapping Pure Functions**\n```python\nfrom returns.io import IO, impure\nimport datetime\n\n@impure\ndef get_current_timestamp() -> float:\n    return datetime.datetime.now().timestamp()\n\n# Map pure functions over IO\nresult = (\n    get_current_timestamp()\n    .map(lambda ts: datetime.datetime.fromtimestamp(ts))\n    .map(lambda dt: dt.strftime('%Y-%m-%d %H:%M:%S'))\n)\n\nformatted_time = result.unwrap()  # \"2024-01-15 10:30:45\"\n```\n\n**Example 2: Binding IO Operations**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef read_config_file() -> dict:\n    import json\n    with open('config.json', 'r') as f:\n        return json.load(f)\n\n@impure\ndef setup_database(config: dict) -> str:\n    db_url = config.get('database_url', 'sqlite:///default.db')\n    print(f\"Setting up database: {db_url}\")\n    # Perform actual setup...\n    return db_url\n\n@impure\ndef run_migrations(db_url: str) -> int:\n    print(f\"Running migrations on {db_url}\")\n    # Run migrations...\n    return 5  # Number of migrations run\n\n# Compose IO operations\nresult = (\n    read_config_file()\n    .bind(setup_database)\n    .bind(run_migrations)\n)\n\nmigrations_count = result.unwrap()\n```\n\n**Example 3: Complex IO Pipeline**\n```python\nfrom returns.io import IO, impure\nfrom typing import List\n\n@impure\ndef list_files(directory: str) -> List[str]:\n    import os\n    return os.listdir(directory)\n\n@impure\ndef filter_text_files(files: List[str]) -> List[str]:\n    return [f for f in files if f.endswith('.txt')]\n\n@impure\ndef read_all_files(filenames: List[str]) -> str:\n    contents = []\n    for filename in filenames:\n        with open(filename, 'r') as f:\n            contents.append(f.read())\n    return '\\n---\\n'.join(contents)\n\n# Pipeline\nresult = (\n    list_files('./data')\n    .map(filter_text_files)\n    .bind(read_all_files)\n)\n\nall_content = result.unwrap()\n```\n\n### IO vs IOResult\n\n**Example 1: IO for Never-Failing Operations**\n```python\nfrom returns.io import IO, impure\nimport random\nimport datetime\n\n@impure\ndef get_random() -> int:\n    \"\"\"Never fails, just returns random number.\"\"\"\n    return random.randint(1, 100)\n\n@impure\ndef get_timestamp() -> float:\n    \"\"\"Never fails, just returns current time.\"\"\"\n    return datetime.datetime.now().timestamp()\n\n# These use IO because they can't fail\nrandom_io: IO[int] = get_random()\ntime_io: IO[float] = get_timestamp()\n```\n\n**Example 2: IOResult for Operations That Can Fail**\n```python\nfrom returns.io import IOResult, impure_safe\nfrom returns.result import Success, Failure\n\n@impure_safe\ndef read_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\n@impure_safe\ndef fetch_url(url: str) -> str:\n    import requests\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.text\n\n# These return IOResult because they can fail\nfile_content: IOResult[str, Exception] = read_file('data.txt')\n# Success(...) if file exists, Failure(FileNotFoundError(...)) otherwise\n\nweb_content: IOResult[str, Exception] = fetch_url('https://example.com')\n# Success(...) if request succeeds, Failure(...) for network errors\n```\n\n**Example 3: Converting Between IO and IOResult**\n```python\nfrom returns.io import IO, IOResult, impure, impure_safe\n\n@impure\ndef always_succeeds() -> int:\n    return 42\n\n@impure_safe\ndef might_fail() -> int:\n    import random\n    if random.random() < 0.5:\n        raise ValueError(\"Random failure\")\n    return 100\n\n# Convert IO to IOResult\nio_value = always_succeeds()\nio_result = IOResult.from_io(io_value)  # IOSuccess(42)\n\n# IOResult is already the right type\nio_result_value = might_fail()  # IOSuccess(100) or IOFailure(...)\n\n# Use both in a pipeline\nresult = (\n    io_result_value\n    .map(lambda x: x * 2)\n    .alt(lambda e: f\"Error occurred: {e}\")\n)\n```\n\n---\n\n## Future Container\n\nThe `Future` container enables composing async operations in a sync context while maintaining exception safety.\n\n### Basic Future Usage\n\n**Example 1: Creating Future from Async Function**\n```python\nfrom returns.future import Future, future\nimport asyncio\n\n@future\nasync def fetch_data() -> dict:\n    await asyncio.sleep(0.1)  # Simulate network delay\n    return {\"id\": 1, \"name\": \"Alice\"}\n\n@future\nasync def process_data(data: dict) -> str:\n    await asyncio.sleep(0.05)\n    return f\"Processed: {data['name']}\"\n\n# These return Future containers\ndata_future: Future[dict] = fetch_data()\n# Can compose without await\n```\n\n**Example 2: Running Futures**\n```python\nfrom returns.future import Future, future\nimport asyncio\n\n@future\nasync def get_user(user_id: int) -> dict:\n    await asyncio.sleep(0.1)\n    return {\"id\": user_id, \"name\": f\"User{user_id}\"}\n\n# Create future\nuser_future = get_user(123)\n\n# Execute it\nasync def main():\n    io_result = await user_future.awaitable()\n    user = io_result.unwrap()\n    print(user)  # {\"id\": 123, \"name\": \"User123\"}\n\nasyncio.run(main())\n```\n\n**Example 3: Mapping Over Futures**\n```python\nfrom returns.future import Future, future\n\n@future\nasync def fetch_number() -> int:\n    import asyncio\n    await asyncio.sleep(0.1)\n    return 42\n\n# Map sync functions over async values\nresult = (\n    fetch_number()\n    .map(lambda x: x * 2)\n    .map(lambda x: f\"Result: {x}\")\n)\n\n# Execute\nasync def main():\n    io_value = await result.awaitable()\n    print(io_value.unwrap())  # \"Result: 84\"\n\nimport asyncio\nasyncio.run(main())\n```\n\n### FutureResult\n\n**Example 1: Creating FutureResult**\n```python\nfrom returns.future import FutureResult, future_safe\n\n@future_safe\nasync def fetch_user(user_id: int) -> dict:\n    import asyncio\n    await asyncio.sleep(0.1)\n\n    users = {1: {\"name\": \"Alice\"}, 2: {\"name\": \"Bob\"}}\n    if user_id not in users:\n        raise ValueError(f\"User {user_id} not found\")\n    return users[user_id]\n\n# Returns FutureResult\nuser_future: FutureResult[dict, Exception] = fetch_user(1)\n# Success path\n\nerror_future: FutureResult[dict, Exception] = fetch_user(999)\n# Failure path\n```\n\n**Example 2: Handling Success and Failure**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def divide_async(a: int, b: int) -> float:\n    await asyncio.sleep(0.05)\n    if b == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    return a / b\n\nasync def main():\n    # Success case\n    result1 = await divide_async(10, 2).awaitable()\n    match result1.unwrap():\n        case Success(value):\n            print(f\"Success: {value}\")  # Success: 5.0\n        case Failure(error):\n            print(f\"Error: {error}\")\n\n    # Failure case\n    result2 = await divide_async(10, 0).awaitable()\n    match result2.unwrap():\n        case Success(value):\n            print(f\"Success: {value}\")\n        case Failure(error):\n            print(f\"Error: {error}\")  # Error: Cannot divide by zero\n\nasyncio.run(main())\n```\n\n**Example 3: Converting Future to FutureResult**\n```python\nfrom returns.future import Future, FutureResult, future\nfrom returns.result import Success\n\n@future\nasync def get_data() -> int:\n    import asyncio\n    await asyncio.sleep(0.1)\n    return 42\n\n# Future[int] -> FutureResult[int, Exception]\nfuture_result = get_data().map(Success)\n\n# Now it's a FutureResult\nasync def main():\n    io_result = await future_result.awaitable()\n    result = io_result.unwrap()  # Success(42)\n    print(result.unwrap())  # 42\n\nimport asyncio\nasyncio.run(main())\n```\n\n### Composing Async Operations\n\n**Example 1: Chaining Async Operations**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_user_id(email: str) -> int:\n    await asyncio.sleep(0.1)\n    users = {\"alice@example.com\": 1, \"bob@example.com\": 2}\n    if email not in users:\n        raise KeyError(f\"User not found: {email}\")\n    return users[email]\n\n@future_safe\nasync def fetch_user_profile(user_id: int) -> dict:\n    await asyncio.sleep(0.1)\n    profiles = {1: {\"name\": \"Alice\", \"age\": 30}, 2: {\"name\": \"Bob\", \"age\": 25}}\n    if user_id not in profiles:\n        raise ValueError(f\"Profile not found for user {user_id}\")\n    return profiles[user_id]\n\n@future_safe\nasync def format_profile(profile: dict) -> str:\n    await asyncio.sleep(0.05)\n    return f\"{profile['name']} ({profile['age']} years old)\"\n\n# Compose async operations\nasync def get_formatted_profile(email: str) -> IOResult[str, Exception]:\n    return await (\n        fetch_user_id(email)\n        .bind(fetch_user_profile)\n        .bind(format_profile)\n        .awaitable()\n    )\n\nasync def main():\n    result = await get_formatted_profile(\"alice@example.com\")\n    print(result.unwrap())  # \"Alice (30 years old)\"\n\nasyncio.run(main())\n```\n\n**Example 2: Parallel Future Execution**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_weather(city: str) -> dict:\n    await asyncio.sleep(0.2)\n    return {\"city\": city, \"temp\": 72, \"conditions\": \"Sunny\"}\n\n@future_safe\nasync def fetch_news(city: str) -> list:\n    await asyncio.sleep(0.15)\n    return [f\"News 1 for {city}\", f\"News 2 for {city}\"]\n\n@future_safe\nasync def fetch_events(city: str) -> list:\n    await asyncio.sleep(0.1)\n    return [f\"Event 1 in {city}\", f\"Event 2 in {city}\"]\n\nasync def fetch_city_data(city: str) -> dict:\n    # Launch all fetches in parallel\n    weather_future = fetch_weather(city).awaitable()\n    news_future = fetch_news(city).awaitable()\n    events_future = fetch_events(city).awaitable()\n\n    # Wait for all\n    weather, news, events = await asyncio.gather(\n        weather_future,\n        news_future,\n        events_future\n    )\n\n    return {\n        \"weather\": weather.unwrap().unwrap(),\n        \"news\": news.unwrap().unwrap(),\n        \"events\": events.unwrap().unwrap()\n    }\n\nasync def main():\n    data = await fetch_city_data(\"San Francisco\")\n    print(data)\n\nasyncio.run(main())\n```\n\n**Example 3: Mixing Sync and Async**\n```python\nfrom returns.future import FutureResult, future_safe, asyncify\nimport asyncio\n\n# Sync function\ndef validate_email(email: str) -> str:\n    if '@' not in email:\n        raise ValueError(\"Invalid email\")\n    return email\n\n# Async function\n@future_safe\nasync def send_email(email: str) -> str:\n    await asyncio.sleep(0.1)\n    return f\"Email sent to {email}\"\n\n# Compose sync and async\nasync def process_email(email: str) -> IOResult[str, Exception]:\n    # Need to lift sync validation into Future context\n    validated = FutureResult.from_result(\n        safe(validate_email)(email)\n    )\n\n    return await validated.bind(send_email).awaitable()\n\nasync def main():\n    result = await process_email(\"user@example.com\")\n    print(result.unwrap().unwrap())  # \"Email sent to user@example.com\"\n\nasyncio.run(main())\n```\n\n---\n\n## future_safe Decorator\n\nThe `@future_safe` decorator converts async exception-throwing functions into functions returning `FutureResult`.\n\n### Basic future_safe Usage\n\n**Example 1: Converting Async Functions**\n```python\nfrom returns.future import future_safe, FutureResult\nimport asyncio\n\n@future_safe\nasync def fetch_data(url: str) -> dict:\n    await asyncio.sleep(0.1)\n    if not url.startswith('https://'):\n        raise ValueError(\"URL must use HTTPS\")\n    return {\"url\": url, \"data\": \"...\"}\n\n# Returns FutureResult\nresult: FutureResult[dict, Exception] = fetch_data(\"https://example.com\")\nerror: FutureResult[dict, Exception] = fetch_data(\"http://example.com\")\n\nasync def main():\n    success = await result.awaitable()\n    print(success.unwrap())  # Success({\"url\": ..., \"data\": \"...\"})\n\n    failure = await error.awaitable()\n    print(failure.unwrap())  # Failure(ValueError(\"URL must use HTTPS\"))\n\nasyncio.run(main())\n```\n\n**Example 2: API Calls with Error Handling**\n```python\nfrom returns.future import future_safe\nimport asyncio\nimport aiohttp\n\n@future_safe\nasync def fetch_json(url: str) -> dict:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            response.raise_for_status()\n            return await response.json()\n\nasync def main():\n    # Success case\n    result1 = await fetch_json(\"https://api.github.com/users/github\").awaitable()\n    match result1.unwrap():\n        case Success(data):\n            print(f\"Got user: {data.get('login')}\")\n        case Failure(error):\n            print(f\"Error: {error}\")\n\n    # Failure case (404)\n    result2 = await fetch_json(\"https://api.github.com/users/nonexistent999\").awaitable()\n    match result2.unwrap():\n        case Success(data):\n            print(f\"Got user: {data.get('login')}\")\n        case Failure(error):\n            print(f\"Error: {error}\")\n\n# asyncio.run(main())  # Uncomment to run\n```\n\n**Example 3: Database Operations**\n```python\nfrom returns.future import future_safe, FutureResult\nimport asyncio\nimport asyncpg\n\n@future_safe\nasync def fetch_users(conn_string: str) -> list[dict]:\n    conn = await asyncpg.connect(conn_string)\n    try:\n        rows = await conn.fetch('SELECT * FROM users')\n        return [dict(row) for row in rows]\n    finally:\n        await conn.close()\n\n@future_safe\nasync def create_user(conn_string: str, name: str, email: str) -> int:\n    conn = await asyncpg.connect(conn_string)\n    try:\n        user_id = await conn.fetchval(\n            'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id',\n            name, email\n        )\n        return user_id\n    finally:\n        await conn.close()\n\n# Both return FutureResult and handle exceptions automatically\n```\n\n### Error Handling in Async Code\n\n**Example 1: Fallback Chains**\n```python\nfrom returns.future import future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_from_primary(key: str) -> str:\n    await asyncio.sleep(0.1)\n    raise ConnectionError(\"Primary server down\")\n\n@future_safe\nasync def fetch_from_secondary(key: str) -> str:\n    await asyncio.sleep(0.1)\n    raise ConnectionError(\"Secondary server down\")\n\n@future_safe\nasync def fetch_from_cache(key: str) -> str:\n    await asyncio.sleep(0.05)\n    return f\"Cached value for {key}\"\n\nasync def fetch_with_fallback(key: str):\n    return await (\n        fetch_from_primary(key)\n        .lash(lambda _: fetch_from_secondary(key))\n        .lash(lambda _: fetch_from_cache(key))\n        .awaitable()\n    )\n\nasync def main():\n    result = await fetch_with_fallback(\"user:123\")\n    print(result.unwrap())  # Success(\"Cached value for user:123\")\n\nasyncio.run(main())\n```\n\n**Example 2: Error Transformation**\n```python\nfrom returns.future import future_safe\nimport asyncio\n\nclass APIError(Exception):\n    pass\n\n@future_safe\nasync def call_external_api(endpoint: str) -> dict:\n    await asyncio.sleep(0.1)\n    raise ConnectionError(\"Network error\")\n\nasync def call_api_with_friendly_errors(endpoint: str):\n    return await (\n        call_external_api(endpoint)\n        .alt(lambda e: APIError(f\"Failed to call {endpoint}: {str(e)}\"))\n        .awaitable()\n    )\n\nasync def main():\n    result = await call_api_with_friendly_errors(\"/users\")\n    match result.unwrap():\n        case Failure(APIError() as error):\n            print(f\"API Error: {error}\")\n        case Failure(error):\n            print(f\"Other error: {error}\")\n        case Success(data):\n            print(f\"Success: {data}\")\n\nasyncio.run(main())\n```\n\n**Example 3: Retry Logic**\n```python\nfrom returns.future import future_safe, FutureResult\nfrom returns.result import Success, Failure\nimport asyncio\n\n@future_safe\nasync def unreliable_operation() -> str:\n    import random\n    await asyncio.sleep(0.1)\n    if random.random() < 0.7:  # 70% failure rate\n        raise Exception(\"Random failure\")\n    return \"Success!\"\n\nasync def retry_operation(max_retries: int = 3) -> IOResult[str, Exception]:\n    for attempt in range(max_retries):\n        result = await unreliable_operation().awaitable()\n        inner_result = result.unwrap()\n\n        match inner_result:\n            case Success(value):\n                return result\n            case Failure(error):\n                if attempt < max_retries - 1:\n                    print(f\"Attempt {attempt + 1} failed, retrying...\")\n                    await asyncio.sleep(0.5)\n                else:\n                    print(f\"All {max_retries} attempts failed\")\n                    return result\n\nasync def main():\n    result = await retry_operation(max_retries=3)\n    print(result.unwrap())\n\nasyncio.run(main())\n```\n\n---\n\n## Context Container\n\nThe `Context` module provides dependency injection through `RequiresContext` and related containers.\n\n### RequiresContext Basics\n\n**Example 1: Simple Context Usage**\n```python\nfrom returns.context import RequiresContext\n\n# Function that requires config\ndef get_database_url() -> RequiresContext[str, dict]:\n    return RequiresContext(lambda config: config['database_url'])\n\ndef get_api_key() -> RequiresContext[str, dict]:\n    return RequiresContext(lambda config: config['api_key'])\n\n# Provide context\nconfig = {\n    'database_url': 'postgres://localhost/mydb',\n    'api_key': 'secret123'\n}\n\ndb_url = get_database_url()(config)  # \"postgres://localhost/mydb\"\napi_key = get_api_key()(config)      # \"secret123\"\n```\n\n**Example 2: Using .ask() Method**\n```python\nfrom returns.context import RequiresContext\n\ndef create_connection_string() -> RequiresContext[str, dict]:\n    # Access context with .ask()\n    return RequiresContext.ask().map(\n        lambda config: f\"{config['db_type']}://{config['db_host']}/{config['db_name']}\"\n    )\n\nconfig = {\n    'db_type': 'postgresql',\n    'db_host': 'localhost',\n    'db_name': 'app_db'\n}\n\nconn_string = create_connection_string()(config)\n# \"postgresql://localhost/app_db\"\n```\n\n**Example 3: Nested Context Access**\n```python\nfrom returns.context import RequiresContext\n\nclass AppConfig:\n    def __init__(self, db_host: str, db_port: int, debug: bool):\n        self.db_host = db_host\n        self.db_port = db_port\n        self.debug = debug\n\ndef get_db_connection() -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(\n        lambda config: f\"{config.db_host}:{config.db_port}\"\n    )\n\ndef should_log_queries() -> RequiresContext[bool, AppConfig]:\n    return RequiresContext.ask().map(lambda config: config.debug)\n\n# Provide context\napp_config = AppConfig(db_host=\"localhost\", db_port=5432, debug=True)\n\ndb_conn = get_db_connection()(app_config)      # \"localhost:5432\"\nshould_log = should_log_queries()(app_config)  # True\n```\n\n### Dependency Injection\n\n**Example 1: Service Layer with DI**\n```python\nfrom returns.context import RequiresContext\nfrom dataclasses import dataclass\n\n@dataclass\nclass ServiceConfig:\n    cache_enabled: bool\n    timeout: int\n    api_url: str\n\nclass UserService:\n    @staticmethod\n    def fetch_user(user_id: int) -> RequiresContext[dict, ServiceConfig]:\n        def _fetch(config: ServiceConfig) -> dict:\n            # Use config values\n            print(f\"Fetching from {config.api_url} with timeout {config.timeout}\")\n            return {\"id\": user_id, \"name\": f\"User{user_id}\"}\n        return RequiresContext(_fetch)\n\n    @staticmethod\n    def should_cache() -> RequiresContext[bool, ServiceConfig]:\n        return RequiresContext.ask().map(lambda config: config.cache_enabled)\n\n# Usage\nconfig = ServiceConfig(cache_enabled=True, timeout=30, api_url=\"https://api.example.com\")\n\nuser = UserService.fetch_user(123)(config)\ncache_enabled = UserService.should_cache()(config)\n```\n\n**Example 2: Multi-Layer Application**\n```python\nfrom returns.context import RequiresContext\nfrom typing import Protocol\n\nclass Database(Protocol):\n    def query(self, sql: str) -> list[dict]: ...\n\nclass Logger(Protocol):\n    def log(self, message: str) -> None: ...\n\n@dataclass\nclass Dependencies:\n    db: Database\n    logger: Logger\n    max_retries: int\n\ndef fetch_users() -> RequiresContext[list[dict], Dependencies]:\n    def _fetch(deps: Dependencies) -> list[dict]:\n        deps.logger.log(\"Fetching users\")\n        return deps.db.query(\"SELECT * FROM users\")\n    return RequiresContext(_fetch)\n\ndef process_users(users: list[dict]) -> RequiresContext[int, Dependencies]:\n    def _process(deps: Dependencies) -> int:\n        deps.logger.log(f\"Processing {len(users)} users\")\n        # Process users...\n        return len(users)\n    return RequiresContext(_process)\n\n# Wire it together\ndef get_user_count() -> RequiresContext[int, Dependencies]:\n    return fetch_users().bind(process_users)\n\n# Provide dependencies at the edge\n# deps = Dependencies(db=my_db, logger=my_logger, max_retries=3)\n# count = get_user_count()(deps)\n```\n\n**Example 3: Testing with Different Contexts**\n```python\nfrom returns.context import RequiresContext\n\ndef send_email(to: str, subject: str) -> RequiresContext[bool, dict]:\n    return RequiresContext.ask().map(\n        lambda config: _send_via_smtp(to, subject, config['smtp_server'])\n        if config.get('email_enabled', False)\n        else _log_email(to, subject)\n    )\n\ndef _send_via_smtp(to: str, subject: str, server: str) -> bool:\n    print(f\"Sending email to {to} via {server}\")\n    return True\n\ndef _log_email(to: str, subject: str) -> bool:\n    print(f\"[MOCK] Would send email to {to}: {subject}\")\n    return True\n\n# Production config\nprod_config = {'email_enabled': True, 'smtp_server': 'smtp.gmail.com'}\nsend_email(\"user@example.com\", \"Hello\")(prod_config)\n# Prints: Sending email to user@example.com via smtp.gmail.com\n\n# Test config\ntest_config = {'email_enabled': False}\nsend_email(\"user@example.com\", \"Hello\")(test_config)\n# Prints: [MOCK] Would send email to user@example.com: Hello\n```\n\n### Composing with Context\n\n**Example 1: Mapping and Binding**\n```python\nfrom returns.context import RequiresContext\n\ndef get_timeout() -> RequiresContext[int, dict]:\n    return RequiresContext.ask().map(lambda config: config.get('timeout', 30))\n\ndef get_timeout_message() -> RequiresContext[str, dict]:\n    return get_timeout().map(lambda t: f\"Timeout is {t} seconds\")\n\ndef validate_timeout() -> RequiresContext[bool, dict]:\n    return get_timeout().map(lambda t: 0 < t < 3600)\n\nconfig = {'timeout': 60}\n\nmessage = get_timeout_message()(config)  # \"Timeout is 60 seconds\"\nis_valid = validate_timeout()(config)    # True\n```\n\n**Example 2: Chaining Context-Dependent Operations**\n```python\nfrom returns.context import RequiresContext\n\ndef get_user_id() -> RequiresContext[int, dict]:\n    return RequiresContext.ask().map(lambda ctx: ctx['current_user_id'])\n\ndef fetch_user(user_id: int) -> RequiresContext[dict, dict]:\n    def _fetch(ctx: dict) -> dict:\n        # Could use database from context\n        db = ctx.get('database')\n        return {'id': user_id, 'name': f'User{user_id}'}\n    return RequiresContext(_fetch)\n\ndef get_permissions(user: dict) -> RequiresContext[list[str], dict]:\n    def _get_perms(ctx: dict) -> list[str]:\n        # Use role system from context\n        if user['id'] == 1:\n            return ['admin', 'read', 'write']\n        return ['read']\n    return RequiresContext(_get_perms)\n\n# Chain operations\ndef get_current_user_permissions() -> RequiresContext[list[str], dict]:\n    return get_user_id().bind(fetch_user).bind(get_permissions)\n\ncontext = {'current_user_id': 1, 'database': None}\nperms = get_current_user_permissions()(context)  # ['admin', 'read', 'write']\n```\n\n**Example 3: Modifying Environment**\n```python\nfrom returns.context import RequiresContext\n\ndef get_base_url() -> RequiresContext[str, dict]:\n    return RequiresContext.ask().map(lambda config: config['base_url'])\n\ndef add_api_prefix(url: str) -> str:\n    return f\"{url}/api/v1\"\n\n# Modify environment type\ndef get_api_url() -> RequiresContext[str, dict]:\n    return get_base_url().map(add_api_prefix)\n\n# Transform context before passing\ndef use_with_modified_context() -> str:\n    original_context = {'base_url': 'https://example.com'}\n\n    # Could modify context here\n    modified_context = {**original_context, 'base_url': 'https://api.example.com'}\n\n    return get_api_url()(modified_context)\n\nresult = use_with_modified_context()  # \"https://api.example.com/api/v1\"\n```\n\n---\n\n## Pipelines\n\nThe `returns` library provides powerful pipeline composition tools for chaining operations.\n\n### flow() Function\n\nThe `flow()` function composes a value with multiple functions sequentially.\n\n**Example 1: Basic Flow**\n```python\nfrom returns.pipeline import flow\n\n# Simple data transformation\nresult = flow(\n    '42',\n    int,\n    lambda x: x * 2,\n    float,\n    str\n)\nprint(result)  # '84.0'\n\n# More practical example\ndef normalize(s: str) -> str:\n    return s.strip().lower()\n\ndef remove_spaces(s: str) -> str:\n    return s.replace(' ', '')\n\ndef add_prefix(s: str) -> str:\n    return f\"user_{s}\"\n\nusername = flow(\n    '  John Doe  ',\n    normalize,\n    remove_spaces,\n    add_prefix\n)\nprint(username)  # 'user_johndoe'\n```\n\n**Example 2: Data Processing Pipeline**\n```python\nfrom returns.pipeline import flow\nfrom typing import List\n\ndef parse_csv_line(line: str) -> List[str]:\n    return line.split(',')\n\ndef strip_fields(fields: List[str]) -> List[str]:\n    return [f.strip() for f in fields]\n\ndef validate_fields(fields: List[str]) -> List[str]:\n    if len(fields) < 3:\n        raise ValueError(\"Not enough fields\")\n    return fields\n\ndef create_record(fields: List[str]) -> dict:\n    return {\n        'name': fields[0],\n        'email': fields[1],\n        'age': int(fields[2])\n    }\n\ncsv_line = 'Alice, alice@example.com, 30'\nrecord = flow(\n    csv_line,\n    parse_csv_line,\n    strip_fields,\n    validate_fields,\n    create_record\n)\nprint(record)  # {'name': 'Alice', 'email': 'alice@example.com', 'age': 30}\n```\n\n**Example 3: Complex Business Logic**\n```python\nfrom returns.pipeline import flow\nfrom decimal import Decimal\n\ndef parse_price(s: str) -> Decimal:\n    return Decimal(s.replace('$', '').replace(',', ''))\n\ndef apply_discount(price: Decimal) -> Decimal:\n    return price * Decimal('0.9')  # 10% discount\n\ndef add_tax(price: Decimal) -> Decimal:\n    return price * Decimal('1.08')  # 8% tax\n\ndef round_price(price: Decimal) -> Decimal:\n    return price.quantize(Decimal('0.01'))\n\ndef format_price(price: Decimal) -> str:\n    return f'${price:,.2f}'\n\nfinal_price = flow(\n    '$1,234.56',\n    parse_price,\n    apply_discount,\n    add_tax,\n    round_price,\n    format_price\n)\nprint(final_price)  # '$1,199.47'\n```\n\n### pipe() Function\n\nThe `pipe()` function creates a reusable pipeline without an initial value.\n\n**Example 1: Reusable Pipeline**\n```python\nfrom returns.pipeline import pipe\n\n# Create reusable transformation\nprocess_name = pipe(\n    str.strip,\n    str.lower,\n    lambda s: s.replace(' ', '_')\n)\n\n# Use it multiple times\nname1 = process_name('  John Doe  ')    # 'john_doe'\nname2 = process_name('Jane Smith')      # 'jane_smith'\nname3 = process_name('  Bob  Jones  ')  # 'bob_jones'\n\nprint(name1, name2, name3)\n```\n\n**Example 2: Data Validation Pipeline**\n```python\nfrom returns.pipeline import pipe\n\ndef validate_length(s: str) -> str:\n    if len(s) < 3:\n        raise ValueError(\"Too short\")\n    return s\n\ndef validate_chars(s: str) -> str:\n    if not s.isalnum():\n        raise ValueError(\"Must be alphanumeric\")\n    return s\n\ndef validate_not_empty(s: str) -> str:\n    if not s:\n        raise ValueError(\"Cannot be empty\")\n    return s\n\n# Create validator pipeline\nvalidate_username = pipe(\n    str.strip,\n    validate_not_empty,\n    validate_length,\n    validate_chars,\n    str.lower\n)\n\n# Use it\ntry:\n    username = validate_username('  Alice123  ')\n    print(username)  # 'alice123'\nexcept ValueError as e:\n    print(f\"Validation failed: {e}\")\n\ntry:\n    invalid = validate_username('ab')\nexcept ValueError as e:\n    print(f\"Validation failed: {e}\")  # \"Validation failed: Too short\"\n```\n\n**Example 3: Number Processing**\n```python\nfrom returns.pipeline import pipe\n\n# Create pipeline for number processing\nprocess_number = pipe(\n    float,\n    lambda x: x ** 2,\n    lambda x: x + 10,\n    int\n)\n\nresult1 = process_number('5')   # int((5.0 ** 2) + 10) = 35\nresult2 = process_number('3')   # int((3.0 ** 2) + 10) = 19\n\nprint(result1, result2)  # 35 19\n\n# Create another pipeline\ncalculate_discount = pipe(\n    float,\n    lambda x: x * 0.8,  # 20% discount\n    lambda x: round(x, 2)\n)\n\nprice1 = calculate_discount('100')  # 80.0\nprice2 = calculate_discount('50.5') # 40.4\n\nprint(price1, price2)\n```\n\n### managed() Function\n\nThe `managed()` function handles resource lifecycle management.\n\n**Example 1: File Resource Management**\n```python\nfrom returns.pipeline import managed\nfrom returns.io import IOResult, impure_safe\n\n@impure_safe\ndef open_file(path: str):\n    return open(path, 'r')\n\ndef use_file(file):\n    return IOResult.from_value(file.read())\n\ndef close_file(file, _):\n    file.close()\n    return IOResult.from_value(None)\n\n# Managed resource\n# result = managed(\n#     open_file('data.txt'),\n#     use_file,\n#     close_file\n# )\n# File is automatically closed even if error occurs\n```\n\n**Example 2: Database Connection**\n```python\nfrom returns.pipeline import managed\nfrom returns.io import IOResult\n\nclass DatabaseConnection:\n    def __init__(self, conn_string: str):\n        self.conn_string = conn_string\n        print(f\"Opening connection to {conn_string}\")\n\n    def execute(self, query: str):\n        print(f\"Executing: {query}\")\n        return [{'id': 1, 'name': 'Alice'}]\n\n    def close(self):\n        print(\"Closing connection\")\n\ndef acquire_connection():\n    return IOResult.from_value(DatabaseConnection('postgres://localhost/db'))\n\ndef use_connection(conn):\n    result = conn.execute('SELECT * FROM users')\n    return IOResult.from_value(result)\n\ndef release_connection(conn, _):\n    conn.close()\n    return IOResult.from_value(None)\n\n# Managed database connection\n# result = managed(\n#     acquire_connection(),\n#     use_connection,\n#     release_connection\n# )\n# Connection is automatically closed\n```\n\n**Example 3: Multiple Resources**\n```python\nfrom returns.pipeline import managed\nfrom returns.io import IOResult\nfrom contextlib import contextmanager\n\n@contextmanager\ndef managed_resources():\n    # Acquire resources\n    file1 = open('data1.txt', 'r')\n    file2 = open('data2.txt', 'r')\n\n    try:\n        yield (file1, file2)\n    finally:\n        # Release resources\n        file1.close()\n        file2.close()\n\n# Use with managed\ndef acquire():\n    return IOResult.from_value(managed_resources().__enter__())\n\ndef use_resources(resources):\n    file1, file2 = resources\n    content1 = file1.read()\n    content2 = file2.read()\n    return IOResult.from_value(content1 + content2)\n\ndef release(resources, _):\n    try:\n        managed_resources().__exit__(None, None, None)\n    except:\n        pass\n    return IOResult.from_value(None)\n\n# Both files are properly closed\n# result = managed(acquire(), use_resources, release)\n```\n\n---\n\n## Conclusion\n\nThis guide covered the fundamental types and containers in the `returns` library:\n\n- **Maybe**: Safe handling of optional values\n- **Result**: Explicit error handling without exceptions\n- **Safe decorator**: Converting exception-throwing functions to Results\n- **IO**: Marking and composing impure operations\n- **Future/FutureResult**: Async operations with exception safety\n- **future_safe decorator**: Converting async functions to FutureResults\n- **Context**: Dependency injection with RequiresContext\n- **Pipelines**: Composing operations with flow, pipe, and managed\n\n**Next Steps**: See Part 2 for methods, converters, helper functions, and advanced primitive types.\n\n**Resources**:\n- [Official Documentation](https://returns.readthedocs.io/)\n- [GitHub Repository](https://github.com/dry-python/returns)\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":14,"cache_creation_input_tokens":346,"cache_read_input_tokens":30914,"cache_creation":{"ephemeral_5m_input_tokens":346,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMRs5ahhUa3fWWiD2EyL","type":"assistant","uuid":"967a5ae6-c06d-47b7-92ff-61780d15e560","timestamp":"2026-01-22T00:00:06.887Z"}
{"type":"file-history-snapshot","messageId":"967a5ae6-c06d-47b7-92ff-61780d15e560","snapshot":{"messageId":"48e41a28-8b07-4866-8f09-491a51cfde0b","trackedFileBackups":{"docs/python/references/returns-part1-core-types.md":{"backupFileName":null,"version":1,"backupTime":"2026-01-22T00:00:06.942Z"}},"timestamp":"2026-01-21T23:57:00.493Z"},"isSnapshotUpdate":true}
{"parentUuid":"967a5ae6-c06d-47b7-92ff-61780d15e560","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RRNXzk47gTQUPvNPBzHRK3","type":"tool_result","content":"File created successfully at: /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/docs/python/references/returns-part1-core-types.md"}]},"uuid":"80fb41b3-32eb-4e92-9cd2-5c310e030c10","timestamp":"2026-01-22T00:00:07.346Z","toolUseResult":{"type":"create","filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/docs/python/references/returns-part1-core-types.md","content":"# Returns Library Guide - Part 1: Core Types and Containers\n\nA comprehensive guide to the fundamental types and containers in the `returns` library for functional programming in Python.\n\n## Table of Contents\n\n1. [Introduction](#introduction)\n2. [Maybe Container](#maybe-container)\n   - [Basic Usage](#maybe-basic-usage)\n   - [Creating Maybe Instances](#creating-maybe-instances)\n   - [Working with Maybe](#working-with-maybe)\n   - [Chaining Operations](#chaining-maybe-operations)\n   - [Pattern Matching](#maybe-pattern-matching)\n3. [Result Container](#result-container)\n   - [Success and Failure](#success-and-failure)\n   - [Creating Results](#creating-results)\n   - [Transforming Results](#transforming-results)\n   - [Error Handling](#result-error-handling)\n   - [Pattern Matching](#result-pattern-matching)\n4. [Safe Decorator](#safe-decorator)\n   - [Basic Safe Usage](#basic-safe-usage)\n   - [Filtering Exceptions](#filtering-exceptions)\n   - [Composing Safe Functions](#composing-safe-functions)\n5. [IO Container](#io-container)\n   - [Marking Impure Operations](#marking-impure-operations)\n   - [Creating IO Instances](#creating-io-instances)\n   - [Composing IO Operations](#composing-io-operations)\n   - [IO vs IOResult](#io-vs-ioresult)\n6. [Future Container](#future-container)\n   - [Basic Future Usage](#basic-future-usage)\n   - [FutureResult](#futureresult)\n   - [Composing Async Operations](#composing-async-operations)\n7. [future_safe Decorator](#future_safe-decorator)\n   - [Basic future_safe Usage](#basic-future_safe-usage)\n   - [Error Handling in Async Code](#error-handling-in-async-code)\n8. [Context Container](#context-container)\n   - [RequiresContext Basics](#requirescontext-basics)\n   - [Dependency Injection](#dependency-injection)\n   - [Composing with Context](#composing-with-context)\n9. [Pipelines](#pipelines)\n   - [flow() Function](#flow-function)\n   - [pipe() Function](#pipe-function)\n   - [managed() Function](#managed-function)\n\n---\n\n## Introduction\n\nThe `returns` library brings functional programming patterns to Python, providing container types that make error handling, side effects, and asynchronous operations more explicit and composable. This guide covers the core types and their usage patterns.\n\n**Installation:**\n```bash\npip install returns\n```\n\n**Import conventions:**\n```python\nfrom returns.maybe import Maybe, Some, Nothing\nfrom returns.result import Result, Success, Failure, safe\nfrom returns.io import IO, IOResult, impure, impure_safe\nfrom returns.future import Future, FutureResult, future_safe\nfrom returns.context import RequiresContext\nfrom returns.pipeline import flow, pipe, managed\n```\n\n---\n\n## Maybe Container\n\nThe `Maybe` container eliminates `None`-related bugs by providing explicit `Some` and `Nothing` variants.\n\n### Maybe Basic Usage\n\n**Problem:** Traditional nullable code requires constant None checks:\n```python\ndef get_user_email(user_id: int) -> str | None:\n    user = find_user(user_id)\n    if user is None:\n        return None\n    if user.profile is None:\n        return None\n    if user.profile.email is None:\n        return None\n    return user.profile.email.lower()\n```\n\n**Solution with Maybe:**\n```python\nfrom returns.maybe import Maybe, Some, Nothing\n\ndef get_user_email(user_id: int) -> Maybe[str]:\n    return (\n        find_user(user_id)\n        .bind_optional(lambda user: user.profile)\n        .bind_optional(lambda profile: profile.email)\n        .map(str.lower)\n    )\n```\n\n### Creating Maybe Instances\n\n**Example 1: From Optional Values**\n```python\nfrom returns.maybe import Maybe\n\n# Convert None to Nothing, values to Some\nresult1 = Maybe.from_optional(None)  # Nothing\nresult2 = Maybe.from_optional(42)    # Some(42)\nresult3 = Maybe.from_optional(\"hello\")  # Some(\"hello\")\n\nprint(result1)  # <Nothing>\nprint(result2)  # <Some: 42>\n```\n\n**Example 2: Explicit Construction**\n```python\nfrom returns.maybe import Some, Nothing\n\n# Direct construction\nsuccess = Some(100)\nfailure = Nothing\n\n# Even None can be wrapped if needed\nwrapped_none = Maybe.from_value(None)  # Some(None)\n```\n\n**Example 3: From Functions**\n```python\nfrom returns.maybe import maybe\n\n@maybe\ndef safe_divide(a: int, b: int) -> int | None:\n    if b == 0:\n        return None\n    return a // b\n\nresult1 = safe_divide(10, 2)  # Some(5)\nresult2 = safe_divide(10, 0)  # Nothing\n```\n\n### Working with Maybe\n\n**Example 1: Extracting Values**\n```python\nfrom returns.maybe import Some, Nothing\n\nvalue = Some(42)\nempty = Nothing\n\n# Get value or provide default\nprint(value.value_or(0))   # 42\nprint(empty.value_or(0))   # 0\n\n# Unwrap (raises if Nothing)\nprint(value.unwrap())      # 42\n# empty.unwrap()           # Raises UnwrapFailedError\n\n# Lazy default evaluation\nexpensive_default = lambda: expensive_computation()\nresult = empty.or_else_call(expensive_default)\n```\n\n**Example 2: Mapping Over Maybe**\n```python\nfrom returns.maybe import Some, Nothing\n\ndef double(x: int) -> int:\n    return x * 2\n\nresult1 = Some(5).map(double)    # Some(10)\nresult2 = Nothing.map(double)     # Nothing\n\n# Chain multiple maps\nresult3 = Some(3).map(double).map(lambda x: x + 1)  # Some(7)\n```\n\n**Example 3: Conditional Operations**\n```python\nfrom returns.maybe import Some, Nothing\n\ndef is_positive(x: int) -> bool:\n    return x > 0\n\n# Filter-like behavior\nvalue = Some(10)\nresult = value if is_positive(value.unwrap()) else Nothing\n# Better: use custom filter logic with bind\n```\n\n### Chaining Maybe Operations\n\n**Example 1: Sequential Binds**\n```python\nfrom returns.maybe import Maybe, Some\n\ndef safe_int(s: str) -> Maybe[int]:\n    try:\n        return Some(int(s))\n    except ValueError:\n        return Maybe.empty\n\ndef safe_reciprocal(x: int) -> Maybe[float]:\n    if x == 0:\n        return Maybe.empty\n    return Some(1.0 / x)\n\n# Chain operations\nresult1 = safe_int(\"10\").bind(safe_reciprocal)  # Some(0.1)\nresult2 = safe_int(\"0\").bind(safe_reciprocal)   # Nothing\nresult3 = safe_int(\"abc\").bind(safe_reciprocal) # Nothing\n```\n\n**Example 2: Working with Optionals**\n```python\nfrom returns.maybe import Maybe\n\nclass Address:\n    def __init__(self, city: str | None):\n        self.city = city\n\nclass User:\n    def __init__(self, address: Address | None):\n        self.address = address\n\ndef get_city(user: User | None) -> Maybe[str]:\n    return (\n        Maybe.from_optional(user)\n        .bind_optional(lambda u: u.address)\n        .bind_optional(lambda a: a.city)\n    )\n\nuser1 = User(Address(\"New York\"))\nuser2 = User(Address(None))\nuser3 = User(None)\n\nprint(get_city(user1))  # Some(\"New York\")\nprint(get_city(user2))  # Nothing\nprint(get_city(user3))  # Nothing\n```\n\n**Example 3: Complex Composition**\n```python\nfrom returns.maybe import Maybe, Some\n\ndef parse_config(text: str) -> Maybe[dict]:\n    \"\"\"Parse configuration from text.\"\"\"\n    import json\n    try:\n        return Some(json.loads(text))\n    except json.JSONDecodeError:\n        return Maybe.empty\n\ndef get_database_url(config: dict) -> Maybe[str]:\n    \"\"\"Extract database URL from config.\"\"\"\n    return Maybe.from_optional(config.get('database', {}).get('url'))\n\ndef validate_url(url: str) -> Maybe[str]:\n    \"\"\"Validate URL format.\"\"\"\n    if url.startswith(('postgres://', 'mysql://')):\n        return Some(url)\n    return Maybe.empty\n\n# Complete pipeline\nconfig_text = '{\"database\": {\"url\": \"postgres://localhost/mydb\"}}'\nresult = (\n    parse_config(config_text)\n    .bind(get_database_url)\n    .bind(validate_url)\n)\nprint(result)  # Some(\"postgres://localhost/mydb\")\n```\n\n### Maybe Pattern Matching\n\n**Python 3.10+ Pattern Matching:**\n```python\nfrom returns.maybe import Maybe, Some\n\ndef describe_maybe(value: Maybe[int]) -> str:\n    match value:\n        case Some(n):\n            return f\"Got value: {n}\"\n        case Maybe.empty:\n            return \"Got nothing\"\n\nprint(describe_maybe(Some(42)))    # \"Got value: 42\"\nprint(describe_maybe(Maybe.empty)) # \"Got nothing\"\n\n# Match with guards\ndef classify_number(value: Maybe[int]) -> str:\n    match value:\n        case Some(n) if n > 0:\n            return \"Positive\"\n        case Some(n) if n < 0:\n            return \"Negative\"\n        case Some(0):\n            return \"Zero\"\n        case Maybe.empty:\n            return \"No value\"\n```\n\n---\n\n## Result Container\n\nThe `Result` container makes error handling explicit by returning either `Success` or `Failure` instead of raising exceptions.\n\n### Success and Failure\n\n**Example 1: Basic Usage**\n```python\nfrom returns.result import Success, Failure\n\n# Successful operation\ngood_result: Result[int, str] = Success(42)\n\n# Failed operation\nbad_result: Result[int, str] = Failure(\"Something went wrong\")\n\nprint(good_result)  # <Success: 42>\nprint(bad_result)   # <Failure: Something went wrong>\n```\n\n**Example 2: Type Safety**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef divide(a: int, b: int) -> Result[float, str]:\n    if b == 0:\n        return Failure(\"Division by zero\")\n    return Success(a / b)\n\nresult1 = divide(10, 2)   # Success(5.0)\nresult2 = divide(10, 0)   # Failure(\"Division by zero\")\n```\n\n**Example 3: Using ResultE Alias**\n```python\nfrom returns.result import ResultE, Success, Failure\n\n# ResultE is Result[T, Exception]\ndef parse_int(s: str) -> ResultE[int]:\n    try:\n        return Success(int(s))\n    except ValueError as e:\n        return Failure(e)\n\nresult = parse_int(\"42\")   # Success(42)\nerror = parse_int(\"abc\")   # Failure(ValueError(...))\n```\n\n### Creating Results\n\n**Example 1: From Try-Catch**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef read_file(path: str) -> Result[str, str]:\n    try:\n        with open(path, 'r') as f:\n            return Success(f.read())\n    except FileNotFoundError:\n        return Failure(f\"File not found: {path}\")\n    except PermissionError:\n        return Failure(f\"Permission denied: {path}\")\n    except Exception as e:\n        return Failure(f\"Unexpected error: {e}\")\n\ncontent = read_file(\"config.txt\")\n```\n\n**Example 2: Validation Functions**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef validate_email(email: str) -> Result[str, str]:\n    if '@' not in email:\n        return Failure(\"Email must contain @\")\n    if '.' not in email.split('@')[1]:\n        return Failure(\"Email domain must contain .\")\n    return Success(email)\n\ndef validate_age(age: int) -> Result[int, str]:\n    if age < 0:\n        return Failure(\"Age cannot be negative\")\n    if age > 150:\n        return Failure(\"Age too high\")\n    return Success(age)\n\nemail_result = validate_email(\"user@example.com\")  # Success\nage_result = validate_age(25)                      # Success\n```\n\n**Example 3: Converting from Other Types**\n```python\nfrom returns.result import Result, Success, Failure\nfrom returns.maybe import Maybe, Some, Nothing\n\ndef maybe_to_result(maybe_val: Maybe[int]) -> Result[int, str]:\n    match maybe_val:\n        case Some(value):\n            return Success(value)\n        case Maybe.empty:\n            return Failure(\"No value provided\")\n\nresult1 = maybe_to_result(Some(42))      # Success(42)\nresult2 = maybe_to_result(Maybe.empty)   # Failure(\"No value provided\")\n```\n\n### Transforming Results\n\n**Example 1: Mapping Success Values**\n```python\nfrom returns.result import Success, Failure\n\nresult = Success(5)\ndoubled = result.map(lambda x: x * 2)        # Success(10)\nstringified = doubled.map(str)                # Success(\"10\")\n\n# Failure is unchanged by map\nfailure = Failure(\"error\")\nmapped_failure = failure.map(lambda x: x * 2) # Failure(\"error\")\n```\n\n**Example 2: Transforming Errors with alt**\n```python\nfrom returns.result import Success, Failure\n\ndef make_error_user_friendly(error: str) -> str:\n    return f\"Oops! {error}\"\n\nresult1 = Success(42).alt(make_error_user_friendly)  # Success(42)\nresult2 = Failure(\"DB error\").alt(make_error_user_friendly)\n# Failure(\"Oops! DB error\")\n\n# Chain multiple transformations\nresult3 = (\n    Failure(\"connection timeout\")\n    .alt(str.upper)\n    .alt(lambda e: f\"ERROR: {e}\")\n)\n# Failure(\"ERROR: CONNECTION TIMEOUT\")\n```\n\n**Example 3: Binding Results**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef safe_sqrt(x: float) -> Result[float, str]:\n    if x < 0:\n        return Failure(\"Cannot take square root of negative number\")\n    return Success(x ** 0.5)\n\ndef safe_reciprocal(x: float) -> Result[float, str]:\n    if x == 0:\n        return Failure(\"Cannot divide by zero\")\n    return Success(1 / x)\n\n# Successful chain\nresult1 = Success(16.0).bind(safe_sqrt).bind(safe_reciprocal)\n# Success(0.25)\n\n# Fails at first step\nresult2 = Success(-4.0).bind(safe_sqrt).bind(safe_reciprocal)\n# Failure(\"Cannot take square root of negative number\")\n\n# Fails at second step\nresult3 = Success(0.0).bind(safe_sqrt).bind(safe_reciprocal)\n# Failure(\"Cannot divide by zero\")\n```\n\n### Result Error Handling\n\n**Example 1: Recovering from Errors with lash**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef fetch_from_cache(key: str) -> Result[str, str]:\n    return Failure(\"Cache miss\")\n\ndef fetch_from_database(error: str) -> Result[str, str]:\n    print(f\"Cache failed ({error}), trying database\")\n    return Success(\"data from database\")\n\ndef fetch_from_api(error: str) -> Result[str, str]:\n    print(f\"Database failed ({error}), trying API\")\n    return Success(\"data from API\")\n\n# Try cache, fallback to database\nresult = fetch_from_cache(\"user:123\").lash(fetch_from_database)\n# Prints: Cache failed (Cache miss), trying database\n# Success(\"data from database\")\n\n# Chain multiple fallbacks\nresult2 = (\n    fetch_from_cache(\"user:456\")\n    .lash(lambda _: Failure(\"DB down\"))\n    .lash(fetch_from_api)\n)\n# Prints: Database failed (DB down), trying API\n# Success(\"data from API\")\n```\n\n**Example 2: Value Extraction**\n```python\nfrom returns.result import Success, Failure\n\n# Get value or default\nresult1 = Success(42).value_or(0)       # 42\nresult2 = Failure(\"error\").value_or(0)  # 0\n\n# Unwrap (raises on Failure)\nvalue = Success(100).unwrap()           # 100\n# Failure(\"error\").unwrap()             # Raises UnwrapFailedError\n\n# Get failure value\nerror = Failure(\"oops\").failure()       # \"oops\"\n# Success(42).failure()                 # Raises UnwrapFailedError\n```\n\n**Example 3: Swapping Success and Failure**\n```python\nfrom returns.result import Success, Failure\n\n# Swap success and failure\nresult1 = Success(42).swap()        # Failure(42)\nresult2 = Failure(\"error\").swap()   # Success(\"error\")\n\n# Useful for inverting logic\ndef is_not_found(result: Result[str, str]) -> Result[str, str]:\n    \"\"\"Convert 'not found' errors into success.\"\"\"\n    return result.swap().map(lambda e: \"Item does not exist\")\n\noriginal = Failure(\"Not found\")\ninverted = is_not_found(original)  # Success(\"Item does not exist\")\n```\n\n### Result Pattern Matching\n\n**Python 3.10+ Pattern Matching:**\n```python\nfrom returns.result import Result, Success, Failure\n\ndef handle_result(result: Result[int, str]) -> str:\n    match result:\n        case Success(value):\n            return f\"Success! Value is {value}\"\n        case Failure(error):\n            return f\"Failed with error: {error}\"\n\nprint(handle_result(Success(42)))        # \"Success! Value is 42\"\nprint(handle_result(Failure(\"oops\")))    # \"Failed with error: oops\"\n\n# With guards and nested matching\ndef classify_result(result: Result[int, Exception]) -> str:\n    match result:\n        case Success(n) if n > 0:\n            return \"Positive success\"\n        case Success(n) if n < 0:\n            return \"Negative success\"\n        case Success(0):\n            return \"Zero success\"\n        case Failure(ValueError()):\n            return \"Value error occurred\"\n        case Failure(error):\n            return f\"Other error: {type(error).__name__}\"\n```\n\n---\n\n## Safe Decorator\n\nThe `@safe` decorator automatically converts exception-throwing functions into functions that return `Result` containers.\n\n### Basic Safe Usage\n\n**Example 1: Simple Conversion**\n```python\nfrom returns.result import safe\n\n@safe\ndef divide(a: int, b: int) -> float:\n    return a / b\n\nresult1 = divide(10, 2)   # Success(5.0)\nresult2 = divide(10, 0)   # Failure(ZeroDivisionError(...))\n```\n\n**Example 2: Working with Files**\n```python\nfrom returns.result import safe, ResultE\nimport json\n\n@safe\ndef load_json(filename: str) -> dict:\n    with open(filename, 'r') as f:\n        return json.load(f)\n\nconfig = load_json(\"config.json\")\n# Success({...}) if file exists and is valid JSON\n# Failure(FileNotFoundError(...)) if file doesn't exist\n# Failure(JSONDecodeError(...)) if invalid JSON\n\n# Use the result\nmatch config:\n    case Success(data):\n        print(f\"Loaded {len(data)} config items\")\n    case Failure(error):\n        print(f\"Failed to load config: {error}\")\n```\n\n**Example 3: Database Operations**\n```python\nfrom returns.result import safe, ResultE\n\n@safe\ndef fetch_user(user_id: int) -> dict:\n    # Simulated database call that might raise\n    import sqlite3\n    conn = sqlite3.connect('users.db')\n    cursor = conn.execute('SELECT * FROM users WHERE id = ?', (user_id,))\n    row = cursor.fetchone()\n    if row is None:\n        raise ValueError(f\"User {user_id} not found\")\n    return dict(row)\n\nuser = fetch_user(123)\n# Success({...}) if user exists\n# Failure(ValueError(...)) if not found\n# Failure(sqlite3.Error(...)) for DB errors\n```\n\n### Filtering Exceptions\n\n**Example 1: Catching Specific Exceptions**\n```python\nfrom returns.result import safe\n\n@safe(exceptions=(ValueError,))\ndef parse_positive_int(s: str) -> int:\n    value = int(s)\n    if value <= 0:\n        raise ValueError(\"Must be positive\")\n    return value\n\nresult1 = parse_positive_int(\"42\")    # Success(42)\nresult2 = parse_positive_int(\"-5\")    # Failure(ValueError(...))\n# parse_positive_int(\"abc\")           # Raises TypeError (not caught)\n```\n\n**Example 2: Multiple Exception Types**\n```python\nfrom returns.result import safe\n\n@safe(exceptions=(FileNotFoundError, PermissionError, json.JSONDecodeError))\ndef load_config(path: str) -> dict:\n    import json\n    with open(path, 'r') as f:\n        return json.load(f)\n\nconfig = load_config(\"settings.json\")\n# Catches FileNotFoundError, PermissionError, JSONDecodeError\n# Other exceptions (like MemoryError) would propagate\n```\n\n**Example 3: Custom Exception Handling**\n```python\nfrom returns.result import safe\n\nclass ValidationError(Exception):\n    pass\n\nclass BusinessError(Exception):\n    pass\n\n@safe(exceptions=(ValidationError, BusinessError))\ndef process_payment(amount: float, account: str) -> str:\n    if amount <= 0:\n        raise ValidationError(\"Amount must be positive\")\n    if not account.startswith(\"ACC\"):\n        raise ValidationError(\"Invalid account format\")\n    if amount > 10000:\n        raise BusinessError(\"Amount exceeds limit\")\n    return f\"Payment of ${amount} to {account} processed\"\n\nresult1 = process_payment(100, \"ACC123\")     # Success(...)\nresult2 = process_payment(-50, \"ACC123\")     # Failure(ValidationError(...))\nresult3 = process_payment(20000, \"ACC123\")   # Failure(BusinessError(...))\n```\n\n### Composing Safe Functions\n\n**Example 1: Chaining Safe Operations**\n```python\nfrom returns.result import safe\n\n@safe\ndef fetch_user_id(email: str) -> int:\n    users = {\"alice@example.com\": 1, \"bob@example.com\": 2}\n    if email not in users:\n        raise KeyError(f\"User not found: {email}\")\n    return users[email]\n\n@safe\ndef fetch_user_data(user_id: int) -> dict:\n    data = {1: {\"name\": \"Alice\"}, 2: {\"name\": \"Bob\"}}\n    if user_id not in data:\n        raise ValueError(f\"No data for user {user_id}\")\n    return data[user_id]\n\ndef get_user(email: str) -> Result[dict, Exception]:\n    return fetch_user_id(email).bind(fetch_user_data)\n\nresult = get_user(\"alice@example.com\")\n# Success({\"name\": \"Alice\"})\n\nresult2 = get_user(\"unknown@example.com\")\n# Failure(KeyError(\"User not found: unknown@example.com\"))\n```\n\n**Example 2: Pipeline with Safe Functions**\n```python\nfrom returns.result import safe\nfrom returns.pipeline import flow\n\n@safe\ndef parse_int(s: str) -> int:\n    return int(s)\n\n@safe\ndef validate_positive(n: int) -> int:\n    if n <= 0:\n        raise ValueError(\"Must be positive\")\n    return n\n\n@safe\ndef calculate_square(n: int) -> int:\n    return n * n\n\n# This won't work directly with flow because safe returns Result\n# Instead, use bind:\ndef process_number(s: str) -> Result[int, Exception]:\n    return (\n        parse_int(s)\n        .bind(validate_positive)\n        .bind(calculate_square)\n    )\n\nresult1 = process_number(\"5\")    # Success(25)\nresult2 = process_number(\"-3\")   # Failure(ValueError(...))\nresult3 = process_number(\"abc\")  # Failure(ValueError(...))\n```\n\n**Example 3: Combining Safe with Manual Result Creation**\n```python\nfrom returns.result import safe, Success, Failure, Result\n\n@safe\ndef fetch_from_api(url: str) -> dict:\n    import requests\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.json()\n\ndef validate_response(data: dict) -> Result[dict, str]:\n    if 'id' not in data:\n        return Failure(\"Response missing 'id' field\")\n    if 'name' not in data:\n        return Failure(\"Response missing 'name' field\")\n    return Success(data)\n\ndef fetch_and_validate(url: str) -> Result[dict, str]:\n    return (\n        fetch_from_api(url)\n        .alt(lambda e: f\"API error: {str(e)}\")  # Convert exception to string\n        .bind(validate_response)\n    )\n\nresult = fetch_and_validate(\"https://api.example.com/users/1\")\n# Success({...}) if API call succeeds and validation passes\n# Failure(\"API error: ...\") for network/HTTP errors\n# Failure(\"Response missing...\") for validation errors\n```\n\n---\n\n## IO Container\n\nThe `IO` container marks functions that perform side effects, making impure operations explicit in your type signatures.\n\n### Marking Impure Operations\n\n**Example 1: Pure vs Impure Functions**\n```python\n# Pure function - always returns same output for same input\ndef add(a: int, b: int) -> int:\n    return a + b\n\n# Impure function - output varies or has side effects\nfrom returns.io import IO, impure\nimport random\n\n@impure\ndef get_random_number() -> int:\n    return random.randint(1, 100)\n\n# Type signature shows it's impure\nresult: IO[int] = get_random_number()\n# Result is wrapped, must be unwrapped to use\n```\n\n**Example 2: Marking Side Effects**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef log_message(message: str) -> None:\n    print(f\"[LOG] {message}\")\n    with open('app.log', 'a') as f:\n        f.write(message + '\\n')\n\n@impure\ndef get_current_time() -> float:\n    import time\n    return time.time()\n\n# These return IO containers\nlog_io: IO[None] = log_message(\"Application started\")\ntime_io: IO[float] = get_current_time()\n```\n\n**Example 3: Database Operations**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef fetch_users() -> list[dict]:\n    import sqlite3\n    conn = sqlite3.connect('app.db')\n    cursor = conn.execute('SELECT * FROM users')\n    return [dict(row) for row in cursor.fetchall()]\n\n@impure\ndef save_user(user: dict) -> int:\n    import sqlite3\n    conn = sqlite3.connect('app.db')\n    cursor = conn.execute(\n        'INSERT INTO users (name, email) VALUES (?, ?)',\n        (user['name'], user['email'])\n    )\n    conn.commit()\n    return cursor.lastrowid\n\nusers_io: IO[list[dict]] = fetch_users()\nsave_io: IO[int] = save_user({\"name\": \"Alice\", \"email\": \"alice@example.com\"})\n```\n\n### Creating IO Instances\n\n**Example 1: Using @impure Decorator**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef read_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\n@impure\ndef write_file(path: str, content: str) -> None:\n    with open(path, 'w') as f:\n        f.write(content)\n\ncontent_io = read_file('data.txt')\nwrite_io = write_file('output.txt', 'Hello, World!')\n```\n\n**Example 2: Manual Construction with from_value**\n```python\nfrom returns.io import IO\nimport os\n\ndef get_environment() -> IO[dict]:\n    return IO.from_value(dict(os.environ))\n\ndef get_working_directory() -> IO[str]:\n    return IO.from_value(os.getcwd())\n\nenv_io = get_environment()\ncwd_io = get_working_directory()\n\n# Execute IO to get values\nenv = env_io.unwrap()\ncwd = cwd_io.unwrap()\n```\n\n**Example 3: Lifting Pure Functions**\n```python\nfrom returns.io import IO\n\n# Pure function\ndef calculate_total(items: list[float]) -> float:\n    return sum(items)\n\n# Lift to IO context (though this is unusual since it's pure)\ndef calculate_total_io(items: list[float]) -> IO[float]:\n    return IO(calculate_total(items))\n\nresult = calculate_total_io([1.0, 2.0, 3.0])  # IO[float]\n```\n\n### Composing IO Operations\n\n**Example 1: Mapping Pure Functions**\n```python\nfrom returns.io import IO, impure\nimport datetime\n\n@impure\ndef get_current_timestamp() -> float:\n    return datetime.datetime.now().timestamp()\n\n# Map pure functions over IO\nresult = (\n    get_current_timestamp()\n    .map(lambda ts: datetime.datetime.fromtimestamp(ts))\n    .map(lambda dt: dt.strftime('%Y-%m-%d %H:%M:%S'))\n)\n\nformatted_time = result.unwrap()  # \"2024-01-15 10:30:45\"\n```\n\n**Example 2: Binding IO Operations**\n```python\nfrom returns.io import IO, impure\n\n@impure\ndef read_config_file() -> dict:\n    import json\n    with open('config.json', 'r') as f:\n        return json.load(f)\n\n@impure\ndef setup_database(config: dict) -> str:\n    db_url = config.get('database_url', 'sqlite:///default.db')\n    print(f\"Setting up database: {db_url}\")\n    # Perform actual setup...\n    return db_url\n\n@impure\ndef run_migrations(db_url: str) -> int:\n    print(f\"Running migrations on {db_url}\")\n    # Run migrations...\n    return 5  # Number of migrations run\n\n# Compose IO operations\nresult = (\n    read_config_file()\n    .bind(setup_database)\n    .bind(run_migrations)\n)\n\nmigrations_count = result.unwrap()\n```\n\n**Example 3: Complex IO Pipeline**\n```python\nfrom returns.io import IO, impure\nfrom typing import List\n\n@impure\ndef list_files(directory: str) -> List[str]:\n    import os\n    return os.listdir(directory)\n\n@impure\ndef filter_text_files(files: List[str]) -> List[str]:\n    return [f for f in files if f.endswith('.txt')]\n\n@impure\ndef read_all_files(filenames: List[str]) -> str:\n    contents = []\n    for filename in filenames:\n        with open(filename, 'r') as f:\n            contents.append(f.read())\n    return '\\n---\\n'.join(contents)\n\n# Pipeline\nresult = (\n    list_files('./data')\n    .map(filter_text_files)\n    .bind(read_all_files)\n)\n\nall_content = result.unwrap()\n```\n\n### IO vs IOResult\n\n**Example 1: IO for Never-Failing Operations**\n```python\nfrom returns.io import IO, impure\nimport random\nimport datetime\n\n@impure\ndef get_random() -> int:\n    \"\"\"Never fails, just returns random number.\"\"\"\n    return random.randint(1, 100)\n\n@impure\ndef get_timestamp() -> float:\n    \"\"\"Never fails, just returns current time.\"\"\"\n    return datetime.datetime.now().timestamp()\n\n# These use IO because they can't fail\nrandom_io: IO[int] = get_random()\ntime_io: IO[float] = get_timestamp()\n```\n\n**Example 2: IOResult for Operations That Can Fail**\n```python\nfrom returns.io import IOResult, impure_safe\nfrom returns.result import Success, Failure\n\n@impure_safe\ndef read_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\n@impure_safe\ndef fetch_url(url: str) -> str:\n    import requests\n    response = requests.get(url)\n    response.raise_for_status()\n    return response.text\n\n# These return IOResult because they can fail\nfile_content: IOResult[str, Exception] = read_file('data.txt')\n# Success(...) if file exists, Failure(FileNotFoundError(...)) otherwise\n\nweb_content: IOResult[str, Exception] = fetch_url('https://example.com')\n# Success(...) if request succeeds, Failure(...) for network errors\n```\n\n**Example 3: Converting Between IO and IOResult**\n```python\nfrom returns.io import IO, IOResult, impure, impure_safe\n\n@impure\ndef always_succeeds() -> int:\n    return 42\n\n@impure_safe\ndef might_fail() -> int:\n    import random\n    if random.random() < 0.5:\n        raise ValueError(\"Random failure\")\n    return 100\n\n# Convert IO to IOResult\nio_value = always_succeeds()\nio_result = IOResult.from_io(io_value)  # IOSuccess(42)\n\n# IOResult is already the right type\nio_result_value = might_fail()  # IOSuccess(100) or IOFailure(...)\n\n# Use both in a pipeline\nresult = (\n    io_result_value\n    .map(lambda x: x * 2)\n    .alt(lambda e: f\"Error occurred: {e}\")\n)\n```\n\n---\n\n## Future Container\n\nThe `Future` container enables composing async operations in a sync context while maintaining exception safety.\n\n### Basic Future Usage\n\n**Example 1: Creating Future from Async Function**\n```python\nfrom returns.future import Future, future\nimport asyncio\n\n@future\nasync def fetch_data() -> dict:\n    await asyncio.sleep(0.1)  # Simulate network delay\n    return {\"id\": 1, \"name\": \"Alice\"}\n\n@future\nasync def process_data(data: dict) -> str:\n    await asyncio.sleep(0.05)\n    return f\"Processed: {data['name']}\"\n\n# These return Future containers\ndata_future: Future[dict] = fetch_data()\n# Can compose without await\n```\n\n**Example 2: Running Futures**\n```python\nfrom returns.future import Future, future\nimport asyncio\n\n@future\nasync def get_user(user_id: int) -> dict:\n    await asyncio.sleep(0.1)\n    return {\"id\": user_id, \"name\": f\"User{user_id}\"}\n\n# Create future\nuser_future = get_user(123)\n\n# Execute it\nasync def main():\n    io_result = await user_future.awaitable()\n    user = io_result.unwrap()\n    print(user)  # {\"id\": 123, \"name\": \"User123\"}\n\nasyncio.run(main())\n```\n\n**Example 3: Mapping Over Futures**\n```python\nfrom returns.future import Future, future\n\n@future\nasync def fetch_number() -> int:\n    import asyncio\n    await asyncio.sleep(0.1)\n    return 42\n\n# Map sync functions over async values\nresult = (\n    fetch_number()\n    .map(lambda x: x * 2)\n    .map(lambda x: f\"Result: {x}\")\n)\n\n# Execute\nasync def main():\n    io_value = await result.awaitable()\n    print(io_value.unwrap())  # \"Result: 84\"\n\nimport asyncio\nasyncio.run(main())\n```\n\n### FutureResult\n\n**Example 1: Creating FutureResult**\n```python\nfrom returns.future import FutureResult, future_safe\n\n@future_safe\nasync def fetch_user(user_id: int) -> dict:\n    import asyncio\n    await asyncio.sleep(0.1)\n\n    users = {1: {\"name\": \"Alice\"}, 2: {\"name\": \"Bob\"}}\n    if user_id not in users:\n        raise ValueError(f\"User {user_id} not found\")\n    return users[user_id]\n\n# Returns FutureResult\nuser_future: FutureResult[dict, Exception] = fetch_user(1)\n# Success path\n\nerror_future: FutureResult[dict, Exception] = fetch_user(999)\n# Failure path\n```\n\n**Example 2: Handling Success and Failure**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def divide_async(a: int, b: int) -> float:\n    await asyncio.sleep(0.05)\n    if b == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    return a / b\n\nasync def main():\n    # Success case\n    result1 = await divide_async(10, 2).awaitable()\n    match result1.unwrap():\n        case Success(value):\n            print(f\"Success: {value}\")  # Success: 5.0\n        case Failure(error):\n            print(f\"Error: {error}\")\n\n    # Failure case\n    result2 = await divide_async(10, 0).awaitable()\n    match result2.unwrap():\n        case Success(value):\n            print(f\"Success: {value}\")\n        case Failure(error):\n            print(f\"Error: {error}\")  # Error: Cannot divide by zero\n\nasyncio.run(main())\n```\n\n**Example 3: Converting Future to FutureResult**\n```python\nfrom returns.future import Future, FutureResult, future\nfrom returns.result import Success\n\n@future\nasync def get_data() -> int:\n    import asyncio\n    await asyncio.sleep(0.1)\n    return 42\n\n# Future[int] -> FutureResult[int, Exception]\nfuture_result = get_data().map(Success)\n\n# Now it's a FutureResult\nasync def main():\n    io_result = await future_result.awaitable()\n    result = io_result.unwrap()  # Success(42)\n    print(result.unwrap())  # 42\n\nimport asyncio\nasyncio.run(main())\n```\n\n### Composing Async Operations\n\n**Example 1: Chaining Async Operations**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_user_id(email: str) -> int:\n    await asyncio.sleep(0.1)\n    users = {\"alice@example.com\": 1, \"bob@example.com\": 2}\n    if email not in users:\n        raise KeyError(f\"User not found: {email}\")\n    return users[email]\n\n@future_safe\nasync def fetch_user_profile(user_id: int) -> dict:\n    await asyncio.sleep(0.1)\n    profiles = {1: {\"name\": \"Alice\", \"age\": 30}, 2: {\"name\": \"Bob\", \"age\": 25}}\n    if user_id not in profiles:\n        raise ValueError(f\"Profile not found for user {user_id}\")\n    return profiles[user_id]\n\n@future_safe\nasync def format_profile(profile: dict) -> str:\n    await asyncio.sleep(0.05)\n    return f\"{profile['name']} ({profile['age']} years old)\"\n\n# Compose async operations\nasync def get_formatted_profile(email: str) -> IOResult[str, Exception]:\n    return await (\n        fetch_user_id(email)\n        .bind(fetch_user_profile)\n        .bind(format_profile)\n        .awaitable()\n    )\n\nasync def main():\n    result = await get_formatted_profile(\"alice@example.com\")\n    print(result.unwrap())  # \"Alice (30 years old)\"\n\nasyncio.run(main())\n```\n\n**Example 2: Parallel Future Execution**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_weather(city: str) -> dict:\n    await asyncio.sleep(0.2)\n    return {\"city\": city, \"temp\": 72, \"conditions\": \"Sunny\"}\n\n@future_safe\nasync def fetch_news(city: str) -> list:\n    await asyncio.sleep(0.15)\n    return [f\"News 1 for {city}\", f\"News 2 for {city}\"]\n\n@future_safe\nasync def fetch_events(city: str) -> list:\n    await asyncio.sleep(0.1)\n    return [f\"Event 1 in {city}\", f\"Event 2 in {city}\"]\n\nasync def fetch_city_data(city: str) -> dict:\n    # Launch all fetches in parallel\n    weather_future = fetch_weather(city).awaitable()\n    news_future = fetch_news(city).awaitable()\n    events_future = fetch_events(city).awaitable()\n\n    # Wait for all\n    weather, news, events = await asyncio.gather(\n        weather_future,\n        news_future,\n        events_future\n    )\n\n    return {\n        \"weather\": weather.unwrap().unwrap(),\n        \"news\": news.unwrap().unwrap(),\n        \"events\": events.unwrap().unwrap()\n    }\n\nasync def main():\n    data = await fetch_city_data(\"San Francisco\")\n    print(data)\n\nasyncio.run(main())\n```\n\n**Example 3: Mixing Sync and Async**\n```python\nfrom returns.future import FutureResult, future_safe, asyncify\nimport asyncio\n\n# Sync function\ndef validate_email(email: str) -> str:\n    if '@' not in email:\n        raise ValueError(\"Invalid email\")\n    return email\n\n# Async function\n@future_safe\nasync def send_email(email: str) -> str:\n    await asyncio.sleep(0.1)\n    return f\"Email sent to {email}\"\n\n# Compose sync and async\nasync def process_email(email: str) -> IOResult[str, Exception]:\n    # Need to lift sync validation into Future context\n    validated = FutureResult.from_result(\n        safe(validate_email)(email)\n    )\n\n    return await validated.bind(send_email).awaitable()\n\nasync def main():\n    result = await process_email(\"user@example.com\")\n    print(result.unwrap().unwrap())  # \"Email sent to user@example.com\"\n\nasyncio.run(main())\n```\n\n---\n\n## future_safe Decorator\n\nThe `@future_safe` decorator converts async exception-throwing functions into functions returning `FutureResult`.\n\n### Basic future_safe Usage\n\n**Example 1: Converting Async Functions**\n```python\nfrom returns.future import future_safe, FutureResult\nimport asyncio\n\n@future_safe\nasync def fetch_data(url: str) -> dict:\n    await asyncio.sleep(0.1)\n    if not url.startswith('https://'):\n        raise ValueError(\"URL must use HTTPS\")\n    return {\"url\": url, \"data\": \"...\"}\n\n# Returns FutureResult\nresult: FutureResult[dict, Exception] = fetch_data(\"https://example.com\")\nerror: FutureResult[dict, Exception] = fetch_data(\"http://example.com\")\n\nasync def main():\n    success = await result.awaitable()\n    print(success.unwrap())  # Success({\"url\": ..., \"data\": \"...\"})\n\n    failure = await error.awaitable()\n    print(failure.unwrap())  # Failure(ValueError(\"URL must use HTTPS\"))\n\nasyncio.run(main())\n```\n\n**Example 2: API Calls with Error Handling**\n```python\nfrom returns.future import future_safe\nimport asyncio\nimport aiohttp\n\n@future_safe\nasync def fetch_json(url: str) -> dict:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(url) as response:\n            response.raise_for_status()\n            return await response.json()\n\nasync def main():\n    # Success case\n    result1 = await fetch_json(\"https://api.github.com/users/github\").awaitable()\n    match result1.unwrap():\n        case Success(data):\n            print(f\"Got user: {data.get('login')}\")\n        case Failure(error):\n            print(f\"Error: {error}\")\n\n    # Failure case (404)\n    result2 = await fetch_json(\"https://api.github.com/users/nonexistent999\").awaitable()\n    match result2.unwrap():\n        case Success(data):\n            print(f\"Got user: {data.get('login')}\")\n        case Failure(error):\n            print(f\"Error: {error}\")\n\n# asyncio.run(main())  # Uncomment to run\n```\n\n**Example 3: Database Operations**\n```python\nfrom returns.future import future_safe, FutureResult\nimport asyncio\nimport asyncpg\n\n@future_safe\nasync def fetch_users(conn_string: str) -> list[dict]:\n    conn = await asyncpg.connect(conn_string)\n    try:\n        rows = await conn.fetch('SELECT * FROM users')\n        return [dict(row) for row in rows]\n    finally:\n        await conn.close()\n\n@future_safe\nasync def create_user(conn_string: str, name: str, email: str) -> int:\n    conn = await asyncpg.connect(conn_string)\n    try:\n        user_id = await conn.fetchval(\n            'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id',\n            name, email\n        )\n        return user_id\n    finally:\n        await conn.close()\n\n# Both return FutureResult and handle exceptions automatically\n```\n\n### Error Handling in Async Code\n\n**Example 1: Fallback Chains**\n```python\nfrom returns.future import future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_from_primary(key: str) -> str:\n    await asyncio.sleep(0.1)\n    raise ConnectionError(\"Primary server down\")\n\n@future_safe\nasync def fetch_from_secondary(key: str) -> str:\n    await asyncio.sleep(0.1)\n    raise ConnectionError(\"Secondary server down\")\n\n@future_safe\nasync def fetch_from_cache(key: str) -> str:\n    await asyncio.sleep(0.05)\n    return f\"Cached value for {key}\"\n\nasync def fetch_with_fallback(key: str):\n    return await (\n        fetch_from_primary(key)\n        .lash(lambda _: fetch_from_secondary(key))\n        .lash(lambda _: fetch_from_cache(key))\n        .awaitable()\n    )\n\nasync def main():\n    result = await fetch_with_fallback(\"user:123\")\n    print(result.unwrap())  # Success(\"Cached value for user:123\")\n\nasyncio.run(main())\n```\n\n**Example 2: Error Transformation**\n```python\nfrom returns.future import future_safe\nimport asyncio\n\nclass APIError(Exception):\n    pass\n\n@future_safe\nasync def call_external_api(endpoint: str) -> dict:\n    await asyncio.sleep(0.1)\n    raise ConnectionError(\"Network error\")\n\nasync def call_api_with_friendly_errors(endpoint: str):\n    return await (\n        call_external_api(endpoint)\n        .alt(lambda e: APIError(f\"Failed to call {endpoint}: {str(e)}\"))\n        .awaitable()\n    )\n\nasync def main():\n    result = await call_api_with_friendly_errors(\"/users\")\n    match result.unwrap():\n        case Failure(APIError() as error):\n            print(f\"API Error: {error}\")\n        case Failure(error):\n            print(f\"Other error: {error}\")\n        case Success(data):\n            print(f\"Success: {data}\")\n\nasyncio.run(main())\n```\n\n**Example 3: Retry Logic**\n```python\nfrom returns.future import future_safe, FutureResult\nfrom returns.result import Success, Failure\nimport asyncio\n\n@future_safe\nasync def unreliable_operation() -> str:\n    import random\n    await asyncio.sleep(0.1)\n    if random.random() < 0.7:  # 70% failure rate\n        raise Exception(\"Random failure\")\n    return \"Success!\"\n\nasync def retry_operation(max_retries: int = 3) -> IOResult[str, Exception]:\n    for attempt in range(max_retries):\n        result = await unreliable_operation().awaitable()\n        inner_result = result.unwrap()\n\n        match inner_result:\n            case Success(value):\n                return result\n            case Failure(error):\n                if attempt < max_retries - 1:\n                    print(f\"Attempt {attempt + 1} failed, retrying...\")\n                    await asyncio.sleep(0.5)\n                else:\n                    print(f\"All {max_retries} attempts failed\")\n                    return result\n\nasync def main():\n    result = await retry_operation(max_retries=3)\n    print(result.unwrap())\n\nasyncio.run(main())\n```\n\n---\n\n## Context Container\n\nThe `Context` module provides dependency injection through `RequiresContext` and related containers.\n\n### RequiresContext Basics\n\n**Example 1: Simple Context Usage**\n```python\nfrom returns.context import RequiresContext\n\n# Function that requires config\ndef get_database_url() -> RequiresContext[str, dict]:\n    return RequiresContext(lambda config: config['database_url'])\n\ndef get_api_key() -> RequiresContext[str, dict]:\n    return RequiresContext(lambda config: config['api_key'])\n\n# Provide context\nconfig = {\n    'database_url': 'postgres://localhost/mydb',\n    'api_key': 'secret123'\n}\n\ndb_url = get_database_url()(config)  # \"postgres://localhost/mydb\"\napi_key = get_api_key()(config)      # \"secret123\"\n```\n\n**Example 2: Using .ask() Method**\n```python\nfrom returns.context import RequiresContext\n\ndef create_connection_string() -> RequiresContext[str, dict]:\n    # Access context with .ask()\n    return RequiresContext.ask().map(\n        lambda config: f\"{config['db_type']}://{config['db_host']}/{config['db_name']}\"\n    )\n\nconfig = {\n    'db_type': 'postgresql',\n    'db_host': 'localhost',\n    'db_name': 'app_db'\n}\n\nconn_string = create_connection_string()(config)\n# \"postgresql://localhost/app_db\"\n```\n\n**Example 3: Nested Context Access**\n```python\nfrom returns.context import RequiresContext\n\nclass AppConfig:\n    def __init__(self, db_host: str, db_port: int, debug: bool):\n        self.db_host = db_host\n        self.db_port = db_port\n        self.debug = debug\n\ndef get_db_connection() -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(\n        lambda config: f\"{config.db_host}:{config.db_port}\"\n    )\n\ndef should_log_queries() -> RequiresContext[bool, AppConfig]:\n    return RequiresContext.ask().map(lambda config: config.debug)\n\n# Provide context\napp_config = AppConfig(db_host=\"localhost\", db_port=5432, debug=True)\n\ndb_conn = get_db_connection()(app_config)      # \"localhost:5432\"\nshould_log = should_log_queries()(app_config)  # True\n```\n\n### Dependency Injection\n\n**Example 1: Service Layer with DI**\n```python\nfrom returns.context import RequiresContext\nfrom dataclasses import dataclass\n\n@dataclass\nclass ServiceConfig:\n    cache_enabled: bool\n    timeout: int\n    api_url: str\n\nclass UserService:\n    @staticmethod\n    def fetch_user(user_id: int) -> RequiresContext[dict, ServiceConfig]:\n        def _fetch(config: ServiceConfig) -> dict:\n            # Use config values\n            print(f\"Fetching from {config.api_url} with timeout {config.timeout}\")\n            return {\"id\": user_id, \"name\": f\"User{user_id}\"}\n        return RequiresContext(_fetch)\n\n    @staticmethod\n    def should_cache() -> RequiresContext[bool, ServiceConfig]:\n        return RequiresContext.ask().map(lambda config: config.cache_enabled)\n\n# Usage\nconfig = ServiceConfig(cache_enabled=True, timeout=30, api_url=\"https://api.example.com\")\n\nuser = UserService.fetch_user(123)(config)\ncache_enabled = UserService.should_cache()(config)\n```\n\n**Example 2: Multi-Layer Application**\n```python\nfrom returns.context import RequiresContext\nfrom typing import Protocol\n\nclass Database(Protocol):\n    def query(self, sql: str) -> list[dict]: ...\n\nclass Logger(Protocol):\n    def log(self, message: str) -> None: ...\n\n@dataclass\nclass Dependencies:\n    db: Database\n    logger: Logger\n    max_retries: int\n\ndef fetch_users() -> RequiresContext[list[dict], Dependencies]:\n    def _fetch(deps: Dependencies) -> list[dict]:\n        deps.logger.log(\"Fetching users\")\n        return deps.db.query(\"SELECT * FROM users\")\n    return RequiresContext(_fetch)\n\ndef process_users(users: list[dict]) -> RequiresContext[int, Dependencies]:\n    def _process(deps: Dependencies) -> int:\n        deps.logger.log(f\"Processing {len(users)} users\")\n        # Process users...\n        return len(users)\n    return RequiresContext(_process)\n\n# Wire it together\ndef get_user_count() -> RequiresContext[int, Dependencies]:\n    return fetch_users().bind(process_users)\n\n# Provide dependencies at the edge\n# deps = Dependencies(db=my_db, logger=my_logger, max_retries=3)\n# count = get_user_count()(deps)\n```\n\n**Example 3: Testing with Different Contexts**\n```python\nfrom returns.context import RequiresContext\n\ndef send_email(to: str, subject: str) -> RequiresContext[bool, dict]:\n    return RequiresContext.ask().map(\n        lambda config: _send_via_smtp(to, subject, config['smtp_server'])\n        if config.get('email_enabled', False)\n        else _log_email(to, subject)\n    )\n\ndef _send_via_smtp(to: str, subject: str, server: str) -> bool:\n    print(f\"Sending email to {to} via {server}\")\n    return True\n\ndef _log_email(to: str, subject: str) -> bool:\n    print(f\"[MOCK] Would send email to {to}: {subject}\")\n    return True\n\n# Production config\nprod_config = {'email_enabled': True, 'smtp_server': 'smtp.gmail.com'}\nsend_email(\"user@example.com\", \"Hello\")(prod_config)\n# Prints: Sending email to user@example.com via smtp.gmail.com\n\n# Test config\ntest_config = {'email_enabled': False}\nsend_email(\"user@example.com\", \"Hello\")(test_config)\n# Prints: [MOCK] Would send email to user@example.com: Hello\n```\n\n### Composing with Context\n\n**Example 1: Mapping and Binding**\n```python\nfrom returns.context import RequiresContext\n\ndef get_timeout() -> RequiresContext[int, dict]:\n    return RequiresContext.ask().map(lambda config: config.get('timeout', 30))\n\ndef get_timeout_message() -> RequiresContext[str, dict]:\n    return get_timeout().map(lambda t: f\"Timeout is {t} seconds\")\n\ndef validate_timeout() -> RequiresContext[bool, dict]:\n    return get_timeout().map(lambda t: 0 < t < 3600)\n\nconfig = {'timeout': 60}\n\nmessage = get_timeout_message()(config)  # \"Timeout is 60 seconds\"\nis_valid = validate_timeout()(config)    # True\n```\n\n**Example 2: Chaining Context-Dependent Operations**\n```python\nfrom returns.context import RequiresContext\n\ndef get_user_id() -> RequiresContext[int, dict]:\n    return RequiresContext.ask().map(lambda ctx: ctx['current_user_id'])\n\ndef fetch_user(user_id: int) -> RequiresContext[dict, dict]:\n    def _fetch(ctx: dict) -> dict:\n        # Could use database from context\n        db = ctx.get('database')\n        return {'id': user_id, 'name': f'User{user_id}'}\n    return RequiresContext(_fetch)\n\ndef get_permissions(user: dict) -> RequiresContext[list[str], dict]:\n    def _get_perms(ctx: dict) -> list[str]:\n        # Use role system from context\n        if user['id'] == 1:\n            return ['admin', 'read', 'write']\n        return ['read']\n    return RequiresContext(_get_perms)\n\n# Chain operations\ndef get_current_user_permissions() -> RequiresContext[list[str], dict]:\n    return get_user_id().bind(fetch_user).bind(get_permissions)\n\ncontext = {'current_user_id': 1, 'database': None}\nperms = get_current_user_permissions()(context)  # ['admin', 'read', 'write']\n```\n\n**Example 3: Modifying Environment**\n```python\nfrom returns.context import RequiresContext\n\ndef get_base_url() -> RequiresContext[str, dict]:\n    return RequiresContext.ask().map(lambda config: config['base_url'])\n\ndef add_api_prefix(url: str) -> str:\n    return f\"{url}/api/v1\"\n\n# Modify environment type\ndef get_api_url() -> RequiresContext[str, dict]:\n    return get_base_url().map(add_api_prefix)\n\n# Transform context before passing\ndef use_with_modified_context() -> str:\n    original_context = {'base_url': 'https://example.com'}\n\n    # Could modify context here\n    modified_context = {**original_context, 'base_url': 'https://api.example.com'}\n\n    return get_api_url()(modified_context)\n\nresult = use_with_modified_context()  # \"https://api.example.com/api/v1\"\n```\n\n---\n\n## Pipelines\n\nThe `returns` library provides powerful pipeline composition tools for chaining operations.\n\n### flow() Function\n\nThe `flow()` function composes a value with multiple functions sequentially.\n\n**Example 1: Basic Flow**\n```python\nfrom returns.pipeline import flow\n\n# Simple data transformation\nresult = flow(\n    '42',\n    int,\n    lambda x: x * 2,\n    float,\n    str\n)\nprint(result)  # '84.0'\n\n# More practical example\ndef normalize(s: str) -> str:\n    return s.strip().lower()\n\ndef remove_spaces(s: str) -> str:\n    return s.replace(' ', '')\n\ndef add_prefix(s: str) -> str:\n    return f\"user_{s}\"\n\nusername = flow(\n    '  John Doe  ',\n    normalize,\n    remove_spaces,\n    add_prefix\n)\nprint(username)  # 'user_johndoe'\n```\n\n**Example 2: Data Processing Pipeline**\n```python\nfrom returns.pipeline import flow\nfrom typing import List\n\ndef parse_csv_line(line: str) -> List[str]:\n    return line.split(',')\n\ndef strip_fields(fields: List[str]) -> List[str]:\n    return [f.strip() for f in fields]\n\ndef validate_fields(fields: List[str]) -> List[str]:\n    if len(fields) < 3:\n        raise ValueError(\"Not enough fields\")\n    return fields\n\ndef create_record(fields: List[str]) -> dict:\n    return {\n        'name': fields[0],\n        'email': fields[1],\n        'age': int(fields[2])\n    }\n\ncsv_line = 'Alice, alice@example.com, 30'\nrecord = flow(\n    csv_line,\n    parse_csv_line,\n    strip_fields,\n    validate_fields,\n    create_record\n)\nprint(record)  # {'name': 'Alice', 'email': 'alice@example.com', 'age': 30}\n```\n\n**Example 3: Complex Business Logic**\n```python\nfrom returns.pipeline import flow\nfrom decimal import Decimal\n\ndef parse_price(s: str) -> Decimal:\n    return Decimal(s.replace('$', '').replace(',', ''))\n\ndef apply_discount(price: Decimal) -> Decimal:\n    return price * Decimal('0.9')  # 10% discount\n\ndef add_tax(price: Decimal) -> Decimal:\n    return price * Decimal('1.08')  # 8% tax\n\ndef round_price(price: Decimal) -> Decimal:\n    return price.quantize(Decimal('0.01'))\n\ndef format_price(price: Decimal) -> str:\n    return f'${price:,.2f}'\n\nfinal_price = flow(\n    '$1,234.56',\n    parse_price,\n    apply_discount,\n    add_tax,\n    round_price,\n    format_price\n)\nprint(final_price)  # '$1,199.47'\n```\n\n### pipe() Function\n\nThe `pipe()` function creates a reusable pipeline without an initial value.\n\n**Example 1: Reusable Pipeline**\n```python\nfrom returns.pipeline import pipe\n\n# Create reusable transformation\nprocess_name = pipe(\n    str.strip,\n    str.lower,\n    lambda s: s.replace(' ', '_')\n)\n\n# Use it multiple times\nname1 = process_name('  John Doe  ')    # 'john_doe'\nname2 = process_name('Jane Smith')      # 'jane_smith'\nname3 = process_name('  Bob  Jones  ')  # 'bob_jones'\n\nprint(name1, name2, name3)\n```\n\n**Example 2: Data Validation Pipeline**\n```python\nfrom returns.pipeline import pipe\n\ndef validate_length(s: str) -> str:\n    if len(s) < 3:\n        raise ValueError(\"Too short\")\n    return s\n\ndef validate_chars(s: str) -> str:\n    if not s.isalnum():\n        raise ValueError(\"Must be alphanumeric\")\n    return s\n\ndef validate_not_empty(s: str) -> str:\n    if not s:\n        raise ValueError(\"Cannot be empty\")\n    return s\n\n# Create validator pipeline\nvalidate_username = pipe(\n    str.strip,\n    validate_not_empty,\n    validate_length,\n    validate_chars,\n    str.lower\n)\n\n# Use it\ntry:\n    username = validate_username('  Alice123  ')\n    print(username)  # 'alice123'\nexcept ValueError as e:\n    print(f\"Validation failed: {e}\")\n\ntry:\n    invalid = validate_username('ab')\nexcept ValueError as e:\n    print(f\"Validation failed: {e}\")  # \"Validation failed: Too short\"\n```\n\n**Example 3: Number Processing**\n```python\nfrom returns.pipeline import pipe\n\n# Create pipeline for number processing\nprocess_number = pipe(\n    float,\n    lambda x: x ** 2,\n    lambda x: x + 10,\n    int\n)\n\nresult1 = process_number('5')   # int((5.0 ** 2) + 10) = 35\nresult2 = process_number('3')   # int((3.0 ** 2) + 10) = 19\n\nprint(result1, result2)  # 35 19\n\n# Create another pipeline\ncalculate_discount = pipe(\n    float,\n    lambda x: x * 0.8,  # 20% discount\n    lambda x: round(x, 2)\n)\n\nprice1 = calculate_discount('100')  # 80.0\nprice2 = calculate_discount('50.5') # 40.4\n\nprint(price1, price2)\n```\n\n### managed() Function\n\nThe `managed()` function handles resource lifecycle management.\n\n**Example 1: File Resource Management**\n```python\nfrom returns.pipeline import managed\nfrom returns.io import IOResult, impure_safe\n\n@impure_safe\ndef open_file(path: str):\n    return open(path, 'r')\n\ndef use_file(file):\n    return IOResult.from_value(file.read())\n\ndef close_file(file, _):\n    file.close()\n    return IOResult.from_value(None)\n\n# Managed resource\n# result = managed(\n#     open_file('data.txt'),\n#     use_file,\n#     close_file\n# )\n# File is automatically closed even if error occurs\n```\n\n**Example 2: Database Connection**\n```python\nfrom returns.pipeline import managed\nfrom returns.io import IOResult\n\nclass DatabaseConnection:\n    def __init__(self, conn_string: str):\n        self.conn_string = conn_string\n        print(f\"Opening connection to {conn_string}\")\n\n    def execute(self, query: str):\n        print(f\"Executing: {query}\")\n        return [{'id': 1, 'name': 'Alice'}]\n\n    def close(self):\n        print(\"Closing connection\")\n\ndef acquire_connection():\n    return IOResult.from_value(DatabaseConnection('postgres://localhost/db'))\n\ndef use_connection(conn):\n    result = conn.execute('SELECT * FROM users')\n    return IOResult.from_value(result)\n\ndef release_connection(conn, _):\n    conn.close()\n    return IOResult.from_value(None)\n\n# Managed database connection\n# result = managed(\n#     acquire_connection(),\n#     use_connection,\n#     release_connection\n# )\n# Connection is automatically closed\n```\n\n**Example 3: Multiple Resources**\n```python\nfrom returns.pipeline import managed\nfrom returns.io import IOResult\nfrom contextlib import contextmanager\n\n@contextmanager\ndef managed_resources():\n    # Acquire resources\n    file1 = open('data1.txt', 'r')\n    file2 = open('data2.txt', 'r')\n\n    try:\n        yield (file1, file2)\n    finally:\n        # Release resources\n        file1.close()\n        file2.close()\n\n# Use with managed\ndef acquire():\n    return IOResult.from_value(managed_resources().__enter__())\n\ndef use_resources(resources):\n    file1, file2 = resources\n    content1 = file1.read()\n    content2 = file2.read()\n    return IOResult.from_value(content1 + content2)\n\ndef release(resources, _):\n    try:\n        managed_resources().__exit__(None, None, None)\n    except:\n        pass\n    return IOResult.from_value(None)\n\n# Both files are properly closed\n# result = managed(acquire(), use_resources, release)\n```\n\n---\n\n## Conclusion\n\nThis guide covered the fundamental types and containers in the `returns` library:\n\n- **Maybe**: Safe handling of optional values\n- **Result**: Explicit error handling without exceptions\n- **Safe decorator**: Converting exception-throwing functions to Results\n- **IO**: Marking and composing impure operations\n- **Future/FutureResult**: Async operations with exception safety\n- **future_safe decorator**: Converting async functions to FutureResults\n- **Context**: Dependency injection with RequiresContext\n- **Pipelines**: Composing operations with flow, pipe, and managed\n\n**Next Steps**: See Part 2 for methods, converters, helper functions, and advanced primitive types.\n\n**Resources**:\n- [Official Documentation](https://returns.readthedocs.io/)\n- [GitHub Repository](https://github.com/dry-python/returns)\n","structuredPatch":[],"originalFile":null},"sourceToolAssistantUUID":"967a5ae6-c06d-47b7-92ff-61780d15e560"}
{"parentUuid":"80fb41b3-32eb-4e92-9cd2-5c310e030c10","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AJwRacZbdxQ6DB4stN5Jh2","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Excellent! Part 1 is complete. Now I need to create Part 2 covering:\n- Methods (cond, unwrap_or_failure, partition)\n- RequiresContext (deeper dive with all the variants)\n- Converters (result_to_maybe, maybe_to_result, flatten)\n- Helper Functions (pointfree style)\n- Primitive Types (IOResult, FutureResult, RequiresContextResult, RequiresContextIOResult, RequiresContextFutureResult)\n\nLet me create this second document.","signature":"EsgECkYICxgCKkBA7trSwC/LFFchptNSMfoKUAElA0uHqfLjwRbfrxsQcP3izTDZWoUkiU5jg/4z1mv0wQoQtMNsvmV+bGLiT769EgxA+pBwhHR9rXJWRJYaDH++/phkG6qMDY1SYSIwZv02zSR0xgSefRGX7Uzg9fAcapAw5QOiA7fzqonEYC1ZRNClA8AvpsgI45Ox3Ld+Kq8DjjYsjm8ySWqjbHJ/2g4Xb/M/Q56i8E0QUtJjuDJCV3Bi/jDuTfilhS54Wz8WuFHe22fvhOIriUbrbEIdaj80j+2VpylmRdZYHxIUQysRPBT8rhSjqtz7Am3CYxnCqAbrgRS9sPnzAuET+NKF3V7Q6eglk5y65yDhs1LRPJsPBdlz9t2XROodl2G46tDJH+XGMjDipnO1RkwcjvoO6EZoQM6GQfOaL6uFFIOLcV3Oio++hGRWvOZDuqJLMKFrD0g7uWdECddH4bg0aIkGCcCL/ILdFoZdyH2oWQjkJuO3B6/OX2uNf2VzsoO+mBZGuNA8W/DFUpwF/VS0xvTT+CqKv8PM+UkNdP6MgXElYWcQ9o03XiyaMTGQIU47zpoU/LcTY3lCwDbLZehWTPZbRNv3XW2CTyFInw+jFNsZwZJwuhfr5KezUH4FAUyrrJZJv7JEbUJ65QTbwS5yYXg8PoilB/HLhmbMhOpslLVZKbrw2lCX5O4YaqYLJXeP9Z8UlipURn5fzKx9mW45yLWgP+3FUf9gtHhiCGsJ5vEg3AS2vTeeqL4J0fDBRXzLYWDYaRwYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":17357,"cache_read_input_tokens":31260,"cache_creation":{"ephemeral_5m_input_tokens":17357,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXMS3vbGfe2rshgus14C7","type":"assistant","uuid":"807cba0f-546d-4d0e-a479-634cff987a71","timestamp":"2026-01-22T00:00:10.939Z"}
{"parentUuid":"807cba0f-546d-4d0e-a479-634cff987a71","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AJwRacZbdxQ6DB4stN5Jh2","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me create the second document covering methods, converters, helper functions, and advanced primitive types."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":17357,"cache_read_input_tokens":31260,"cache_creation":{"ephemeral_5m_input_tokens":17357,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXMS3vbGfe2rshgus14C7","type":"assistant","uuid":"79ad1ab9-1b5d-405a-a477-68d70a73c8a8","timestamp":"2026-01-22T00:00:11.371Z"}
{"parentUuid":"79ad1ab9-1b5d-405a-a477-68d70a73c8a8","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01AJwRacZbdxQ6DB4stN5Jh2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W83xSVt8xiuPrZQz8CYQzd","name":"Write","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/docs/python/references/returns-part2-advanced-features.md","content":"# Returns Library Guide - Part 2: Advanced Features\n\nA comprehensive guide to advanced features, methods, converters, and primitive types in the `returns` library.\n\n## Table of Contents\n\n1. [Introduction](#introduction)\n2. [Methods Module](#methods-module)\n   - [cond() Function](#cond-function)\n   - [unwrap_or_failure() Function](#unwrap_or_failure-function)\n   - [partition() Function](#partition-function)\n   - [is_successful() Function](#is_successful-function)\n3. [RequiresContext Deep Dive](#requirescontext-deep-dive)\n   - [RequiresContext Basics](#requirescontext-basics-1)\n   - [RequiresContextResult](#requirescontextresult)\n   - [RequiresContextIOResult](#requirescontextioresult)\n   - [RequiresContextFutureResult](#requirescontextfutureresult)\n   - [Complex Context Patterns](#complex-context-patterns)\n4. [Converters](#converters)\n   - [result_to_maybe()](#result_to_maybe)\n   - [maybe_to_result()](#maybe_to_result)\n   - [flatten()](#flatten)\n   - [Advanced Conversions](#advanced-conversions)\n5. [Helper Functions (Pointfree)](#helper-functions-pointfree)\n   - [map_() Function](#map_-function)\n   - [bind() Function](#bind-function)\n   - [alt() Function](#alt-function)\n   - [lash() Function](#lash-function)\n   - [apply() Function](#apply-function)\n   - [Specialized Binds](#specialized-binds)\n6. [Primitive Types](#primitive-types)\n   - [IOResult](#ioresult)\n   - [FutureResult](#futureresult-1)\n   - [RequiresContextResult](#requirescontextresult-1)\n   - [RequiresContextIOResult](#requirescontextioresult-1)\n   - [RequiresContextFutureResult](#requirescontextfutureresult-1)\n\n---\n\n## Introduction\n\nThis guide covers advanced features of the `returns` library including utility methods, type converters, pointfree helpers, and composite primitive types that combine multiple effects.\n\n**Import conventions:**\n```python\nfrom returns import methods\nfrom returns.converters import result_to_maybe, maybe_to_result, flatten\nfrom returns.pointfree import map_, bind, alt, lash, apply\nfrom returns.io import IOResult, impure_safe\nfrom returns.future import FutureResult, future_safe\nfrom returns.context import (\n    RequiresContext,\n    RequiresContextResult,\n    RequiresContextIOResult,\n    RequiresContextFutureResult,\n)\n```\n\n---\n\n## Methods Module\n\nThe `methods` module provides utility functions for working with container types.\n\n### cond() Function\n\nThe `cond()` function provides a functional alternative to if/else statements for container types.\n\n**Example 1: Basic Conditional**\n```python\nfrom returns import methods\nfrom returns.result import Result\n\ndef check_number(n: int) -> Result[str, str]:\n    return methods.cond(\n        Result,\n        n > 0,\n        'Positive number',\n        'Non-positive number'\n    )\n\nresult1 = check_number(5)    # Success('Positive number')\nresult2 = check_number(-3)   # Failure('Non-positive number')\nresult3 = check_number(0)    # Failure('Non-positive number')\n\nprint(result1)  # <Success: Positive number>\nprint(result2)  # <Failure: Non-positive number>\n```\n\n**Example 2: Validation with cond**\n```python\nfrom returns import methods\nfrom returns.result import Result\n\ndef validate_age(age: int) -> Result[int, str]:\n    return methods.cond(\n        Result,\n        0 <= age <= 150,\n        age,\n        f'Invalid age: {age}'\n    )\n\ndef validate_email(email: str) -> Result[str, str]:\n    return methods.cond(\n        Result,\n        '@' in email and '.' in email,\n        email,\n        f'Invalid email: {email}'\n    )\n\nage_result = validate_age(25)              # Success(25)\ninvalid_age = validate_age(200)            # Failure('Invalid age: 200')\n\nemail_result = validate_email('a@b.com')   # Success('a@b.com')\ninvalid_email = validate_email('notanemail') # Failure('Invalid email: notanemail')\n```\n\n**Example 3: Pipeline Integration**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success\nfrom returns.pipeline import flow\n\ndef is_even(n: int) -> bool:\n    return n % 2 == 0\n\ndef process_number(n: int) -> Result[str, str]:\n    return methods.cond(\n        Result,\n        is_even(n),\n        f'{n} is even',\n        f'{n} is odd'\n    )\n\n# Use in a chain\ndef validate_and_check(s: str) -> Result[str, str]:\n    return (\n        Success(s)\n        .map(int)\n        .bind(lambda n: methods.cond(\n            Result,\n            n > 0,\n            n,\n            'Number must be positive'\n        ))\n        .bind(process_number)\n    )\n\nresult1 = validate_and_check('4')   # Success('4 is even')\nresult2 = validate_and_check('5')   # Success('5 is odd')\nresult3 = validate_and_check('-2')  # Failure('Number must be positive')\n```\n\n### unwrap_or_failure() Function\n\nExtracts values from container types, retrieving either the success or failure value.\n\n**Example 1: Basic Unwrapping**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\n\nsuccess_value = Success(42)\nfailure_value = Failure('error')\n\n# Extract the inner value (success or failure)\nvalue1 = methods.unwrap_or_failure(success_value)  # 42\nvalue2 = methods.unwrap_or_failure(failure_value)  # 'error'\n\nprint(value1)  # 42\nprint(value2)  # 'error'\n```\n\n**Example 2: After bimap Transformation**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\n\ndef double(x: int) -> int:\n    return x * 2\n\ndef error_to_upper(e: str) -> str:\n    return e.upper()\n\nsuccess = Success(21)\nfailure = Failure('network error')\n\n# Transform both channels\ntransformed_success = success.bimap(double, error_to_upper)\ntransformed_failure = failure.bimap(double, error_to_upper)\n\n# Unwrap the transformed values\nprint(methods.unwrap_or_failure(transformed_success))  # 42\nprint(methods.unwrap_or_failure(transformed_failure))  # 'NETWORK ERROR'\n```\n\n**Example 3: Logging Results**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\n\ndef process_data(data: str) -> Result[int, str]:\n    try:\n        return Success(int(data))\n    except ValueError:\n        return Failure(f'Invalid data: {data}')\n\ndef log_result(result: Result[int, str]) -> None:\n    value = methods.unwrap_or_failure(result)\n    result_type = 'Success' if result.is_success() else 'Failure'\n    print(f'{result_type}: {value}')\n\nlog_result(process_data('42'))   # Success: 42\nlog_result(process_data('abc'))  # Failure: Invalid data: abc\n```\n\n### partition() Function\n\nConverts a list of container instances into separate lists of successes and failures.\n\n**Example 1: Basic Partitioning**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\n\nresults = [\n    Success(1),\n    Failure('error 1'),\n    Success(2),\n    Success(3),\n    Failure('error 2'),\n]\n\nsuccesses, failures = methods.partition(results)\n\nprint(successes)  # [1, 2, 3]\nprint(failures)   # ['error 1', 'error 2']\n```\n\n**Example 2: Batch Processing**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\n\ndef parse_int(s: str) -> Result[int, str]:\n    try:\n        return Success(int(s))\n    except ValueError:\n        return Failure(f'Cannot parse: {s}')\n\ninputs = ['1', '2', 'abc', '3', 'def', '4']\nresults = [parse_int(s) for s in inputs]\n\nvalid, invalid = methods.partition(results)\n\nprint(f'Valid numbers: {valid}')      # Valid numbers: [1, 2, 3, 4]\nprint(f'Invalid inputs: {invalid}')   # Invalid inputs: ['Cannot parse: abc', ...]\n```\n\n**Example 3: Validation Report**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\nfrom typing import List\n\ndef validate_email(email: str) -> Result[str, str]:\n    if '@' not in email:\n        return Failure(f'{email}: missing @')\n    if '.' not in email.split('@')[1]:\n        return Failure(f'{email}: invalid domain')\n    return Success(email)\n\ndef validate_all_emails(emails: List[str]) -> dict:\n    results = [validate_email(email) for email in emails]\n    valid, invalid = methods.partition(results)\n\n    return {\n        'valid_count': len(valid),\n        'invalid_count': len(invalid),\n        'valid_emails': valid,\n        'errors': invalid\n    }\n\nemails = [\n    'alice@example.com',\n    'invalid',\n    'bob@test.com',\n    'missing@domain',\n    'charlie@company.org'\n]\n\nreport = validate_all_emails(emails)\nprint(f\"Valid: {report['valid_count']}, Invalid: {report['invalid_count']}\")\nprint(f\"Errors: {report['errors']}\")\n```\n\n### is_successful() Function\n\nDetermines whether a container represents a success state.\n\n**Example 1: Basic Success Checking**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\nfrom returns.maybe import Some, Nothing\n\n# Result types\nassert methods.is_successful(Success(42)) == True\nassert methods.is_successful(Failure('error')) == False\n\n# Maybe types\nassert methods.is_successful(Some(100)) == True\nassert methods.is_successful(Nothing) == False\n```\n\n**Example 2: Filtering Successful Results**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\nfrom typing import List\n\ndef process_batch(items: List[str]) -> List[Result[int, str]]:\n    results = []\n    for item in items:\n        try:\n            results.append(Success(int(item)))\n        except ValueError:\n            results.append(Failure(f'Invalid: {item}'))\n    return results\n\ndef get_successful_results(results: List[Result]) -> List[Result]:\n    return [r for r in results if methods.is_successful(r)]\n\ndef get_failed_results(results: List[Result]) -> List[Result]:\n    return [r for r in results if not methods.is_successful(r)]\n\nitems = ['1', '2', 'abc', '3']\nresults = process_batch(items)\n\nsuccessful = get_successful_results(results)\nfailed = get_failed_results(results)\n\nprint(f'Successful: {len(successful)}')  # Successful: 3\nprint(f'Failed: {len(failed)}')          # Failed: 1\n```\n\n**Example 3: Conditional Processing**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\n\ndef process_with_retry(result: Result[int, str], retries: int = 3) -> Result[int, str]:\n    if methods.is_successful(result):\n        return result\n\n    # Retry logic for failures\n    for attempt in range(retries):\n        print(f'Retry attempt {attempt + 1}')\n        # Simulate retry (in real code, would retry the operation)\n        new_result = Success(42) if attempt == retries - 1 else result\n\n        if methods.is_successful(new_result):\n            return new_result\n\n    return result\n\n# First call succeeds\nresult1 = process_with_retry(Success(100))\nprint(result1)  # <Success: 100>\n\n# First call fails, retries\nresult2 = process_with_retry(Failure('timeout'))\nprint(result2)  # <Success: 42> (after retries)\n```\n\n---\n\n## RequiresContext Deep Dive\n\nThe Context module provides several specialized containers for dependency injection combined with different effects.\n\n### RequiresContext Basics\n\n**Example 1: Simple Context Function**\n```python\nfrom returns.context import RequiresContext\n\ndef get_api_key() -> RequiresContext[str, dict]:\n    \"\"\"Extract API key from config context.\"\"\"\n    return RequiresContext.ask().map(lambda config: config['api_key'])\n\ndef get_timeout() -> RequiresContext[int, dict]:\n    \"\"\"Extract timeout from config context.\"\"\"\n    return RequiresContext.ask().map(lambda config: config.get('timeout', 30))\n\n# Provide context\nconfig = {\n    'api_key': 'secret-key-123',\n    'timeout': 60,\n    'debug': True\n}\n\napi_key = get_api_key()(config)  # 'secret-key-123'\ntimeout = get_timeout()(config)   # 60\n```\n\n**Example 2: Composing Context Operations**\n```python\nfrom returns.context import RequiresContext\n\nclass AppConfig:\n    def __init__(self, base_url: str, api_version: str):\n        self.base_url = base_url\n        self.api_version = api_version\n\ndef get_base_url() -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(lambda c: c.base_url)\n\ndef get_api_version() -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(lambda c: c.api_version)\n\ndef build_api_url(endpoint: str) -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(\n        lambda c: f'{c.base_url}/api/{c.api_version}/{endpoint}'\n    )\n\n# Alternative: compose existing functions\ndef build_api_url_v2(endpoint: str) -> RequiresContext[str, AppConfig]:\n    def _build(base_url: str) -> RequiresContext[str, AppConfig]:\n        return get_api_version().map(\n            lambda version: f'{base_url}/api/{version}/{endpoint}'\n        )\n    return get_base_url().bind(_build)\n\nconfig = AppConfig('https://api.example.com', 'v2')\nurl = build_api_url('users')(config)\n# 'https://api.example.com/api/v2/users'\n```\n\n**Example 3: Complex Context Transformations**\n```python\nfrom returns.context import RequiresContext\nfrom typing import List\n\nclass DatabaseConfig:\n    def __init__(self, host: str, port: int, database: str, pool_size: int):\n        self.host = host\n        self.port = port\n        self.database = database\n        self.pool_size = pool_size\n\ndef get_connection_string() -> RequiresContext[str, DatabaseConfig]:\n    return RequiresContext.ask().map(\n        lambda c: f'postgresql://{c.host}:{c.port}/{c.database}'\n    )\n\ndef get_pool_config() -> RequiresContext[dict, DatabaseConfig]:\n    return RequiresContext.ask().map(\n        lambda c: {\n            'pool_size': c.pool_size,\n            'max_overflow': c.pool_size * 2,\n            'pool_timeout': 30\n        }\n    )\n\ndef create_engine_config() -> RequiresContext[dict, DatabaseConfig]:\n    def _combine(conn_str: str) -> RequiresContext[dict, DatabaseConfig]:\n        return get_pool_config().map(\n            lambda pool: {\n                'connection_string': conn_str,\n                **pool\n            }\n        )\n    return get_connection_string().bind(_combine)\n\ndb_config = DatabaseConfig('localhost', 5432, 'myapp', 10)\nengine_config = create_engine_config()(db_config)\n# {'connection_string': 'postgresql://localhost:5432/myapp',\n#  'pool_size': 10, 'max_overflow': 20, 'pool_timeout': 30}\n```\n\n### RequiresContextResult\n\nCombines context dependency with Result for operations that require config and can fail.\n\n**Example 1: Basic RequiresContextResult**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure\n\ndef validate_api_key(key: str) -> RequiresContextResult[str, str, dict]:\n    \"\"\"Validate API key against config.\"\"\"\n    def _validate(config: dict) -> Result[str, str]:\n        expected_key = config.get('expected_api_key')\n        if key == expected_key:\n            return Success(key)\n        return Failure('Invalid API key')\n\n    return RequiresContextResult(_validate)\n\nconfig = {'expected_api_key': 'secret123'}\n\nresult1 = validate_api_key('secret123')(config)  # Success('secret123')\nresult2 = validate_api_key('wrong')(config)      # Failure('Invalid API key')\n```\n\n**Example 2: Database Operations with Context**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure, Result\n\nclass DbContext:\n    def __init__(self, connection_string: str, max_retries: int):\n        self.connection_string = connection_string\n        self.max_retries = max_retries\n\ndef fetch_user(user_id: int) -> RequiresContextResult[dict, str, DbContext]:\n    \"\"\"Fetch user from database using connection from context.\"\"\"\n    def _fetch(ctx: DbContext) -> Result[dict, str]:\n        print(f'Connecting to {ctx.connection_string}')\n        # Simulate database query\n        if user_id > 0:\n            return Success({'id': user_id, 'name': f'User{user_id}'})\n        return Failure('Invalid user ID')\n\n    return RequiresContextResult(_fetch)\n\ndef update_user(user_id: int, name: str) -> RequiresContextResult[bool, str, DbContext]:\n    \"\"\"Update user in database.\"\"\"\n    def _update(ctx: DbContext) -> Result[bool, str]:\n        print(f'Updating user {user_id} with {ctx.max_retries} max retries')\n        # Simulate update\n        if user_id > 0:\n            return Success(True)\n        return Failure('Cannot update invalid user')\n\n    return RequiresContextResult(_update)\n\n# Use with context\ndb_ctx = DbContext('postgresql://localhost/db', 3)\n\nuser_result = fetch_user(123)(db_ctx)\n# Connects and returns Success({'id': 123, 'name': 'User123'})\n\nupdate_result = update_user(123, 'Alice')(db_ctx)\n# Returns Success(True)\n```\n\n**Example 3: Chaining Context-Result Operations**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure, Result\n\nclass AppContext:\n    def __init__(self, db_url: str, cache_enabled: bool):\n        self.db_url = db_url\n        self.cache_enabled = cache_enabled\n\ndef check_cache(key: str) -> RequiresContextResult[str, str, AppContext]:\n    \"\"\"Check cache if enabled.\"\"\"\n    def _check(ctx: AppContext) -> Result[str, str]:\n        if not ctx.cache_enabled:\n            return Failure('Cache disabled')\n        # Simulate cache lookup\n        if key == 'user:1':\n            return Success('Cached data for user:1')\n        return Failure('Cache miss')\n\n    return RequiresContextResult(_check)\n\ndef fetch_from_db(error: str) -> RequiresContextResult[str, str, AppContext]:\n    \"\"\"Fallback to database on cache miss.\"\"\"\n    def _fetch(ctx: AppContext) -> Result[str, str]:\n        print(f'Cache failed: {error}, fetching from {ctx.db_url}')\n        return Success('Fresh data from database')\n\n    return RequiresContextResult(lambda ctx: _fetch(ctx))\n\ndef get_data(key: str) -> RequiresContextResult[str, str, AppContext]:\n    \"\"\"Get data with cache fallback.\"\"\"\n    return check_cache(key).lash(fetch_from_db)\n\nctx = AppContext('postgresql://localhost/db', True)\nresult = get_data('user:1')(ctx)  # Success('Cached data for user:1')\n\nctx_no_cache = AppContext('postgresql://localhost/db', False)\nresult2 = get_data('user:1')(ctx_no_cache)\n# Prints: Cache failed: Cache disabled, fetching from postgresql://localhost/db\n# Success('Fresh data from database')\n```\n\n### RequiresContextIOResult\n\nCombines context, IO effects, and Result for impure operations that need config and can fail.\n\n**Example 1: File Operations with Context**\n```python\nfrom returns.context import RequiresContextIOResult\nfrom returns.io import IOResult\nfrom returns.result import Success, Failure\n\nclass FileContext:\n    def __init__(self, base_path: str, encoding: str):\n        self.base_path = base_path\n        self.encoding = encoding\n\ndef read_config_file(filename: str) -> RequiresContextIOResult[str, str, FileContext]:\n    \"\"\"Read file using base path from context.\"\"\"\n    def _read(ctx: FileContext) -> IOResult[str, str]:\n        import os\n        full_path = os.path.join(ctx.base_path, filename)\n        try:\n            with open(full_path, 'r', encoding=ctx.encoding) as f:\n                return IOResult.from_result(Success(f.read()))\n        except FileNotFoundError:\n            return IOResult.from_result(Failure(f'File not found: {full_path}'))\n        except Exception as e:\n            return IOResult.from_result(Failure(str(e)))\n\n    return RequiresContextIOResult(_read)\n\ndef write_log(message: str) -> RequiresContextIOResult[None, str, FileContext]:\n    \"\"\"Write to log file.\"\"\"\n    def _write(ctx: FileContext) -> IOResult[None, str]:\n        import os\n        log_path = os.path.join(ctx.base_path, 'app.log')\n        try:\n            with open(log_path, 'a', encoding=ctx.encoding) as f:\n                f.write(message + '\\n')\n            return IOResult.from_result(Success(None))\n        except Exception as e:\n            return IOResult.from_result(Failure(str(e)))\n\n    return RequiresContextIOResult(_write)\n\n# Usage\nfile_ctx = FileContext('/app/data', 'utf-8')\n\n# These return IOResult when executed\n# config = read_config_file('config.json')(file_ctx)\n# log_result = write_log('Application started')(file_ctx)\n```\n\n**Example 2: HTTP Requests with Context**\n```python\nfrom returns.context import RequiresContextIOResult\nfrom returns.io import IOResult, impure_safe\nfrom returns.result import Success, Failure\n\nclass APIContext:\n    def __init__(self, base_url: str, api_key: str, timeout: int):\n        self.base_url = base_url\n        self.api_key = api_key\n        self.timeout = timeout\n\ndef make_request(endpoint: str) -> RequiresContextIOResult[dict, str, APIContext]:\n    \"\"\"Make HTTP request using API context.\"\"\"\n    def _request(ctx: APIContext) -> IOResult[dict, str]:\n        import requests\n\n        @impure_safe\n        def _do_request() -> dict:\n            url = f'{ctx.base_url}/{endpoint}'\n            headers = {'Authorization': f'Bearer {ctx.api_key}'}\n            response = requests.get(url, headers=headers, timeout=ctx.timeout)\n            response.raise_for_status()\n            return response.json()\n\n        return _do_request().alt(lambda e: f'Request failed: {str(e)}')\n\n    return RequiresContextIOResult(_request)\n\ndef fetch_user_data(user_id: int) -> RequiresContextIOResult[dict, str, APIContext]:\n    \"\"\"Fetch user data from API.\"\"\"\n    return make_request(f'users/{user_id}')\n\n# Usage\napi_ctx = APIContext('https://api.example.com', 'secret-key', 30)\n# user_data = fetch_user_data(123)(api_ctx)\n```\n\n**Example 3: Database with Transaction Context**\n```python\nfrom returns.context import RequiresContextIOResult\nfrom returns.io import IOResult\nfrom returns.result import Success, Failure\n\nclass TransactionContext:\n    def __init__(self, conn_string: str, isolation_level: str):\n        self.conn_string = conn_string\n        self.isolation_level = isolation_level\n        self.transaction = None\n\ndef begin_transaction() -> RequiresContextIOResult[None, str, TransactionContext]:\n    \"\"\"Begin database transaction.\"\"\"\n    def _begin(ctx: TransactionContext) -> IOResult[None, str]:\n        print(f'Beginning transaction with {ctx.isolation_level} isolation')\n        ctx.transaction = {'active': True}\n        return IOResult.from_result(Success(None))\n\n    return RequiresContextIOResult(_begin)\n\ndef execute_query(query: str) -> RequiresContextIOResult[list, str, TransactionContext]:\n    \"\"\"Execute query in transaction.\"\"\"\n    def _execute(ctx: TransactionContext) -> IOResult[list, str]:\n        if not ctx.transaction or not ctx.transaction.get('active'):\n            return IOResult.from_result(Failure('No active transaction'))\n\n        print(f'Executing: {query}')\n        # Simulate query execution\n        return IOResult.from_result(Success([{'id': 1}]))\n\n    return RequiresContextIOResult(_execute)\n\ndef commit_transaction() -> RequiresContextIOResult[None, str, TransactionContext]:\n    \"\"\"Commit transaction.\"\"\"\n    def _commit(ctx: TransactionContext) -> IOResult[None, str]:\n        if ctx.transaction:\n            print('Committing transaction')\n            ctx.transaction['active'] = False\n        return IOResult.from_result(Success(None))\n\n    return RequiresContextIOResult(_commit)\n\n# Chain transaction operations\ndef run_transaction() -> RequiresContextIOResult[list, str, TransactionContext]:\n    return (\n        begin_transaction()\n        .bind(lambda _: execute_query('INSERT INTO users VALUES (1)'))\n        .bind(lambda result: commit_transaction().map(lambda _: result))\n    )\n\ntx_ctx = TransactionContext('postgresql://localhost/db', 'READ_COMMITTED')\n# result = run_transaction()(tx_ctx)\n```\n\n### RequiresContextFutureResult\n\nCombines context, async operations, and Result for async operations that need config and can fail.\n\n**Example 1: Async API Calls with Context**\n```python\nfrom returns.context import RequiresContextFutureResult\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\nclass AsyncAPIContext:\n    def __init__(self, base_url: str, api_key: str):\n        self.base_url = base_url\n        self.api_key = api_key\n\ndef async_fetch_user(user_id: int) -> RequiresContextFutureResult[dict, str, AsyncAPIContext]:\n    \"\"\"Fetch user asynchronously using API context.\"\"\"\n    def _fetch(ctx: AsyncAPIContext) -> FutureResult[dict, str]:\n        @future_safe\n        async def _do_fetch() -> dict:\n            await asyncio.sleep(0.1)  # Simulate network delay\n            print(f'Fetching from {ctx.base_url} with key {ctx.api_key}')\n\n            # Simulate API response\n            if user_id > 0:\n                return {'id': user_id, 'name': f'User{user_id}'}\n            raise ValueError('Invalid user ID')\n\n        return _do_fetch()\n\n    return RequiresContextFutureResult(_fetch)\n\ndef async_fetch_posts(user_id: int) -> RequiresContextFutureResult[list, str, AsyncAPIContext]:\n    \"\"\"Fetch user posts asynchronously.\"\"\"\n    def _fetch(ctx: AsyncAPIContext) -> FutureResult[list, str]:\n        @future_safe\n        async def _do_fetch() -> list:\n            await asyncio.sleep(0.1)\n            print(f'Fetching posts for user {user_id}')\n            return [\n                {'id': 1, 'title': 'Post 1'},\n                {'id': 2, 'title': 'Post 2'}\n            ]\n\n        return _do_fetch()\n\n    return RequiresContextFutureResult(_fetch)\n\n# Chain async operations\ndef get_user_with_posts(user_id: int) -> RequiresContextFutureResult[dict, str, AsyncAPIContext]:\n    def _combine(user: dict) -> RequiresContextFutureResult[dict, str, AsyncAPIContext]:\n        return async_fetch_posts(user_id).map(\n            lambda posts: {**user, 'posts': posts}\n        )\n\n    return async_fetch_user(user_id).bind(_combine)\n\n# Usage\nasync def main():\n    api_ctx = AsyncAPIContext('https://api.example.com', 'secret-key')\n    future_result = get_user_with_posts(123)(api_ctx)\n    io_result = await future_result.awaitable()\n    result = io_result.unwrap()\n    print(result)\n\n# asyncio.run(main())\n```\n\n**Example 2: Parallel Async Operations with Context**\n```python\nfrom returns.context import RequiresContextFutureResult\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\nclass ServiceContext:\n    def __init__(self, timeout: int, max_concurrent: int):\n        self.timeout = timeout\n        self.max_concurrent = max_concurrent\n\ndef fetch_data_async(source: str) -> RequiresContextFutureResult[str, str, ServiceContext]:\n    \"\"\"Fetch data from source asynchronously.\"\"\"\n    def _fetch(ctx: ServiceContext) -> FutureResult[str, str]:\n        @future_safe\n        async def _do_fetch() -> str:\n            await asyncio.sleep(0.2)\n            print(f'Fetched from {source} with timeout {ctx.timeout}')\n            return f'Data from {source}'\n\n        return _do_fetch()\n\n    return RequiresContextFutureResult(_fetch)\n\nasync def fetch_all_data(sources: list[str], ctx: ServiceContext):\n    \"\"\"Fetch from multiple sources in parallel.\"\"\"\n    futures = [\n        fetch_data_async(source)(ctx).awaitable()\n        for source in sources[:ctx.max_concurrent]\n    ]\n\n    results = await asyncio.gather(*futures)\n    return [r.unwrap() for r in results]\n\n# Usage\nasync def main():\n    ctx = ServiceContext(timeout=30, max_concurrent=3)\n    sources = ['api1', 'api2', 'api3', 'api4']\n    results = await fetch_all_data(sources, ctx)\n    print(results)\n\n# asyncio.run(main())\n```\n\n**Example 3: Complex Async Pipeline with Context**\n```python\nfrom returns.context import RequiresContextFutureResult\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\nclass PipelineContext:\n    def __init__(self, stage1_url: str, stage2_url: str, cache_enabled: bool):\n        self.stage1_url = stage1_url\n        self.stage2_url = stage2_url\n        self.cache_enabled = cache_enabled\n\ndef stage1_process(data: str) -> RequiresContextFutureResult[dict, str, PipelineContext]:\n    \"\"\"First processing stage.\"\"\"\n    def _process(ctx: PipelineContext) -> FutureResult[dict, str]:\n        @future_safe\n        async def _do_process() -> dict:\n            await asyncio.sleep(0.1)\n            print(f'Stage 1 processing at {ctx.stage1_url}')\n            return {'processed': data, 'stage': 1}\n\n        return _do_process()\n\n    return RequiresContextFutureResult(_process)\n\ndef stage2_process(data: dict) -> RequiresContextFutureResult[dict, str, PipelineContext]:\n    \"\"\"Second processing stage.\"\"\"\n    def _process(ctx: PipelineContext) -> FutureResult[dict, str]:\n        @future_safe\n        async def _do_process() -> dict:\n            await asyncio.sleep(0.1)\n            print(f'Stage 2 processing at {ctx.stage2_url}')\n            return {**data, 'stage': 2, 'cached': ctx.cache_enabled}\n\n        return _do_process()\n\n    return RequiresContextFutureResult(_process)\n\ndef run_pipeline(input_data: str) -> RequiresContextFutureResult[dict, str, PipelineContext]:\n    \"\"\"Run complete processing pipeline.\"\"\"\n    return stage1_process(input_data).bind(stage2_process)\n\n# Usage\nasync def main():\n    ctx = PipelineContext(\n        stage1_url='https://stage1.example.com',\n        stage2_url='https://stage2.example.com',\n        cache_enabled=True\n    )\n\n    future_result = run_pipeline('test data')(ctx)\n    io_result = await future_result.awaitable()\n    result = io_result.unwrap()\n    print(result)\n    # {'processed': 'test data', 'stage': 2, 'cached': True}\n\n# asyncio.run(main())\n```\n\n### Complex Context Patterns\n\n**Example 1: Multi-Environment Context**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure, Result\nfrom dataclasses import dataclass\nfrom typing import Literal\n\n@dataclass\nclass EnvironmentConfig:\n    env: Literal['dev', 'staging', 'prod']\n    db_url: str\n    api_url: str\n    debug: bool\n\ndef get_feature_flag(feature: str) -> RequiresContextResult[bool, str, EnvironmentConfig]:\n    \"\"\"Get feature flag based on environment.\"\"\"\n    def _get_flag(ctx: EnvironmentConfig) -> Result[bool, str]:\n        # Different features enabled per environment\n        if ctx.env == 'dev':\n            return Success(True)  # All features in dev\n        elif ctx.env == 'staging':\n            return Success(feature in ['feature_a', 'feature_b'])\n        else:  # prod\n            return Success(feature == 'feature_a')\n\n    return RequiresContextResult(_get_flag)\n\ndef execute_if_enabled(\n    feature: str,\n    action: str\n) -> RequiresContextResult[str, str, EnvironmentConfig]:\n    \"\"\"Execute action only if feature is enabled.\"\"\"\n    def _execute_with_flag(enabled: bool) -> RequiresContextResult[str, str, EnvironmentConfig]:\n        if enabled:\n            return RequiresContextResult(lambda ctx: Success(f'Executed {action} in {ctx.env}'))\n        return RequiresContextResult(lambda ctx: Failure(f'Feature {feature} disabled'))\n\n    return get_feature_flag(feature).bind(_execute_with_flag)\n\n# Use with different environments\ndev_config = EnvironmentConfig('dev', 'postgres://localhost/dev', 'http://localhost:8000', True)\nprod_config = EnvironmentConfig('prod', 'postgres://prod/db', 'https://api.example.com', False)\n\ndev_result = execute_if_enabled('feature_x', 'process_data')(dev_config)\n# Success('Executed process_data in dev')\n\nprod_result = execute_if_enabled('feature_x', 'process_data')(prod_config)\n# Failure('Feature feature_x disabled')\n```\n\n**Example 2: Hierarchical Context**\n```python\nfrom returns.context import RequiresContext\nfrom dataclasses import dataclass\n\n@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    database: str\n\n@dataclass\nclass CacheConfig:\n    host: str\n    ttl: int\n\n@dataclass\nclass ApplicationConfig:\n    db: DatabaseConfig\n    cache: CacheConfig\n    app_name: str\n\ndef get_db_url() -> RequiresContext[str, ApplicationConfig]:\n    \"\"\"Extract database URL from nested config.\"\"\"\n    return RequiresContext.ask().map(\n        lambda config: f'postgresql://{config.db.host}:{config.db.port}/{config.db.database}'\n    )\n\ndef get_cache_url() -> RequiresContext[str, ApplicationConfig]:\n    \"\"\"Extract cache URL from nested config.\"\"\"\n    return RequiresContext.ask().map(\n        lambda config: f'redis://{config.cache.host}'\n    )\n\ndef get_full_config() -> RequiresContext[dict, ApplicationConfig]:\n    \"\"\"Build complete config dictionary.\"\"\"\n    def _build_with_db(db_url: str) -> RequiresContext[dict, ApplicationConfig]:\n        return get_cache_url().map(\n            lambda cache_url: RequiresContext.ask().map(\n                lambda config: {\n                    'app_name': config.app_name,\n                    'database': db_url,\n                    'cache': cache_url,\n                    'cache_ttl': config.cache.ttl\n                }\n            )\n        ).bind(lambda x: x)\n\n    return get_db_url().bind(_build_with_db)\n\n# Usage\napp_config = ApplicationConfig(\n    db=DatabaseConfig('localhost', 5432, 'myapp'),\n    cache=CacheConfig('localhost', 3600),\n    app_name='MyApp'\n)\n\nconfig_dict = get_full_config()(app_config)\n# {\n#     'app_name': 'MyApp',\n#     'database': 'postgresql://localhost:5432/myapp',\n#     'cache': 'redis://localhost',\n#     'cache_ttl': 3600\n# }\n```\n\n**Example 3: Context Transformation**\n```python\nfrom returns.context import RequiresContext\nfrom dataclasses import dataclass\n\n@dataclass\nclass UserContext:\n    user_id: int\n    roles: list[str]\n\n@dataclass\nclass RequestContext:\n    user: UserContext\n    request_id: str\n    ip_address: str\n\ndef has_role(role: str) -> RequiresContext[bool, RequestContext]:\n    \"\"\"Check if user has specific role.\"\"\"\n    return RequiresContext.ask().map(\n        lambda ctx: role in ctx.user.roles\n    )\n\ndef is_admin() -> RequiresContext[bool, RequestContext]:\n    \"\"\"Check if user is admin.\"\"\"\n    return has_role('admin')\n\ndef get_user_id() -> RequiresContext[int, RequestContext]:\n    \"\"\"Extract user ID from request context.\"\"\"\n    return RequiresContext.ask().map(lambda ctx: ctx.user.user_id)\n\ndef log_request(message: str) -> RequiresContext[str, RequestContext]:\n    \"\"\"Create log message with request context.\"\"\"\n    return RequiresContext.ask().map(\n        lambda ctx: f'[{ctx.request_id}] [{ctx.ip_address}] User {ctx.user.user_id}: {message}'\n    )\n\n# Modify context for sub-operations\ndef with_user_context(\n    operation: RequiresContext[str, UserContext]\n) -> RequiresContext[str, RequestContext]:\n    \"\"\"Transform operation requiring UserContext to work with RequestContext.\"\"\"\n    return RequiresContext(\n        lambda request_ctx: operation(request_ctx.user)\n    )\n\n# Usage\nrequest_ctx = RequestContext(\n    user=UserContext(user_id=123, roles=['admin', 'user']),\n    request_id='req-456',\n    ip_address='192.168.1.1'\n)\n\nadmin_check = is_admin()(request_ctx)  # True\nlog_msg = log_request('Accessed resource')(request_ctx)\n# '[req-456] [192.168.1.1] User 123: Accessed resource'\n```\n\n---\n\n## Converters\n\nThe converters module provides functions to transform between different container types.\n\n### result_to_maybe()\n\nConverts a `Result` container to a `Maybe` container, discarding error information.\n\n**Example 1: Basic Conversion**\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Success, Failure\nfrom returns.maybe import Some, Nothing\n\nsuccess = Success(42)\nfailure = Failure('error')\n\nmaybe_success = result_to_maybe(success)  # Some(42)\nmaybe_failure = result_to_maybe(failure)  # Nothing\n\nprint(maybe_success)  # <Some: 42>\nprint(maybe_failure)  # <Nothing>\n```\n\n**Example 2: Pipeline Integration**\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import safe\nfrom returns.maybe import Maybe\n\n@safe\ndef divide(a: int, b: int) -> float:\n    return a / b\n\ndef safe_divide_maybe(a: int, b: int) -> Maybe[float]:\n    \"\"\"Divide and convert to Maybe, ignoring error details.\"\"\"\n    return result_to_maybe(divide(a, b))\n\nresult1 = safe_divide_maybe(10, 2)  # Some(5.0)\nresult2 = safe_divide_maybe(10, 0)  # Nothing\n\n# Use with Maybe operations\nresult3 = safe_divide_maybe(20, 4).map(lambda x: x * 2).value_or(0)\n# 10.0\n```\n\n**Example 3: Optional Value Extraction**\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Result, Success, Failure\nfrom returns.maybe import Maybe\n\ndef find_user(user_id: int) -> Result[dict, str]:\n    \"\"\"Find user by ID.\"\"\"\n    users = {1: {'name': 'Alice'}, 2: {'name': 'Bob'}}\n    if user_id in users:\n        return Success(users[user_id])\n    return Failure(f'User {user_id} not found')\n\ndef get_user_optional(user_id: int) -> Maybe[dict]:\n    \"\"\"Get user as Maybe, discarding error message.\"\"\"\n    return result_to_maybe(find_user(user_id))\n\n# Process without caring about error details\nuser = get_user_optional(1).map(lambda u: u['name']).value_or('Unknown')\n# 'Alice'\n\nmissing_user = get_user_optional(999).map(lambda u: u['name']).value_or('Unknown')\n# 'Unknown'\n```\n\n### maybe_to_result()\n\nConverts a `Maybe` container to a `Result`, optionally specifying the error value for `Nothing`.\n\n**Example 1: Basic Conversion**\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.maybe import Some, Nothing\nfrom returns.result import Success, Failure\n\nsome_value = Some(42)\nnothing_value = Nothing\n\n# Convert without custom error\nresult1 = maybe_to_result(some_value)  # Success(42)\nresult2 = maybe_to_result(nothing_value)  # Failure(None)\n\n# Convert with custom error\nresult3 = maybe_to_result(nothing_value, default_error='No value found')\n# Failure('No value found')\n\nprint(result1)  # <Success: 42>\nprint(result2)  # <Failure: None>\nprint(result3)  # <Failure: No value found>\n```\n\n**Example 2: Adding Error Context**\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.maybe import Maybe\n\ndef parse_optional_config(key: str) -> Maybe[str]:\n    \"\"\"Get optional configuration value.\"\"\"\n    config = {'api_key': 'secret', 'timeout': '30'}\n    return Maybe.from_optional(config.get(key))\n\ndef require_config(key: str) -> Result[str, str]:\n    \"\"\"Convert optional config to required, with error message.\"\"\"\n    return maybe_to_result(\n        parse_optional_config(key),\n        default_error=f'Required configuration {key} is missing'\n    )\n\napi_key = require_config('api_key')  # Success('secret')\nmissing = require_config('database_url')\n# Failure('Required configuration database_url is missing')\n```\n\n**Example 3: Validation Pipeline**\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.maybe import Maybe, Some, Nothing\nfrom returns.result import Result\n\ndef find_in_list(items: list, predicate) -> Maybe[any]:\n    \"\"\"Find first item matching predicate.\"\"\"\n    for item in items:\n        if predicate(item):\n            return Some(item)\n    return Nothing\n\ndef require_item(\n    items: list,\n    predicate,\n    error_message: str\n) -> Result[any, str]:\n    \"\"\"Require an item to exist in list.\"\"\"\n    return maybe_to_result(\n        find_in_list(items, predicate),\n        default_error=error_message\n    )\n\nusers = [\n    {'id': 1, 'name': 'Alice', 'active': True},\n    {'id': 2, 'name': 'Bob', 'active': False},\n]\n\n# Find active user\nactive_user = require_item(\n    users,\n    lambda u: u['active'],\n    'No active user found'\n)\n# Success({'id': 1, 'name': 'Alice', 'active': True})\n\n# Find admin user (doesn't exist)\nadmin_user = require_item(\n    users,\n    lambda u: u.get('role') == 'admin',\n    'No admin user found'\n)\n# Failure('No admin user found')\n```\n\n### flatten()\n\nFlattens nested containers of the same type.\n\n**Example 1: Flatten Nested Results**\n```python\nfrom returns.converters import flatten\nfrom returns.result import Success, Failure\n\n# Nested Success\nnested_success = Success(Success(42))\nflat_success = flatten(nested_success)  # Success(42)\n\n# Success containing Failure\nsuccess_with_failure = Success(Failure('error'))\nflat_failure = flatten(success_with_failure)  # Failure('error')\n\n# Failure containing Success\nfailure_with_success = Failure(Success(42))\nstill_failure = flatten(failure_with_success)  # Failure(Success(42))\n\nprint(flat_success)   # <Success: 42>\nprint(flat_failure)   # <Failure: error>\n```\n\n**Example 2: Flatten Nested Maybe**\n```python\nfrom returns.converters import flatten\nfrom returns.maybe import Some, Nothing\n\n# Nested Some\nnested_some = Some(Some(100))\nflat_some = flatten(nested_some)  # Some(100)\n\n# Some containing Nothing\nsome_nothing = Some(Nothing)\nflat_nothing = flatten(some_nothing)  # Nothing\n\nprint(flat_some)      # <Some: 100>\nprint(flat_nothing)   # <Nothing>\n```\n\n**Example 3: Flatten IO Containers**\n```python\nfrom returns.converters import flatten\nfrom returns.io import IO\n\n# Nested IO\ndef get_value() -> int:\n    return 42\n\nnested_io = IO(IO(get_value()))\nflat_io = flatten(nested_io)\n\n# Both execute to same value\nprint(flat_io.unwrap())  # Prints value\n```\n\n### Advanced Conversions\n\n**Example 1: Chaining Conversions**\n```python\nfrom returns.converters import result_to_maybe, maybe_to_result\nfrom returns.result import Success, Failure\nfrom returns.maybe import Maybe\n\n# Round-trip conversion\noriginal = Success(42)\nas_maybe = result_to_maybe(original)  # Some(42)\nback_to_result = maybe_to_result(as_maybe)  # Success(42)\n\n# Information loss with Failure\noriginal_failure = Failure('detailed error')\nas_maybe_fail = result_to_maybe(original_failure)  # Nothing\nback_to_result_fail = maybe_to_result(as_maybe_fail)  # Failure(None) - lost error detail!\n\n# Preserve error information with custom error\nback_with_error = maybe_to_result(as_maybe_fail, default_error='Operation failed')\n# Failure('Operation failed')\n```\n\n**Example 2: Complex Pipeline with Conversions**\n```python\nfrom returns.converters import result_to_maybe, maybe_to_result\nfrom returns.result import safe, Success\nfrom returns.maybe import Maybe\n\n@safe\ndef parse_int(s: str) -> int:\n    return int(s)\n\ndef process_optional_number(s: str | None) -> Maybe[int]:\n    \"\"\"Process an optional string as number.\"\"\"\n    if s is None:\n        return Maybe.empty\n\n    # Convert Result to Maybe\n    return result_to_maybe(parse_int(s))\n\ndef require_positive_number(maybe_num: Maybe[int]) -> Result[int, str]:\n    \"\"\"Require number to be positive.\"\"\"\n    result = maybe_to_result(maybe_num, default_error='No number provided')\n\n    return result.bind(lambda n:\n        Success(n) if n > 0 else Failure(f'{n} is not positive')\n    )\n\n# Use the pipeline\nresult1 = require_positive_number(process_optional_number('42'))\n# Success(42)\n\nresult2 = require_positive_number(process_optional_number('-5'))\n# Failure('-5 is not positive')\n\nresult3 = require_positive_number(process_optional_number(None))\n# Failure('No number provided')\n\nresult4 = require_positive_number(process_optional_number('abc'))\n# Failure('No number provided')\n```\n\n**Example 3: Converting IO Containers**\n```python\nfrom returns.converters import flatten\nfrom returns.io import IO, IOResult, impure, impure_safe\nfrom returns.result import Success\n\n@impure\ndef get_config() -> dict:\n    return {'timeout': 30}\n\n@impure_safe\ndef load_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\n# Convert IO[Result] to IOResult using flatten conceptually\ndef safe_get_config() -> IOResult[dict, Exception]:\n    return IOResult.from_io(get_config())\n\n# Flatten nested IO operations\n@impure\ndef nested_operation() -> IO[int]:\n    return IO(42)\n\nnested = IO(nested_operation())\nflat = flatten(nested)\n# Now flat is IO[int] instead of IO[IO[int]]\n```\n\n---\n\n## Helper Functions (Pointfree)\n\nThe pointfree module provides functions that enable functional composition by reversing the typical method call order.\n\n### map_() Function\n\nLifts regular functions to work with containers, transforming `a -> b` into `Container[a] -> Container[b]`.\n\n**Example 1: Basic Mapping**\n```python\nfrom returns.pointfree import map_\nfrom returns.result import Success, Failure\nfrom returns.maybe import Some, Nothing\n\ndef double(x: int) -> int:\n    return x * 2\n\n# Create a pointfree version\ndouble_in_container = map_(double)\n\n# Apply to different containers\nresult1 = double_in_container(Success(5))   # Success(10)\nresult2 = double_in_container(Failure('e')) # Failure('e')\nmaybe1 = double_in_container(Some(3))       # Some(6)\nmaybe2 = double_in_container(Nothing)       # Nothing\n\nprint(result1)  # <Success: 10>\nprint(maybe1)   # <Some: 6>\n```\n\n**Example 2: Pipeline Composition**\n```python\nfrom returns.pointfree import map_\nfrom returns.result import Success\nfrom returns.pipeline import flow\n\ndef add_one(x: int) -> int:\n    return x + 1\n\ndef to_string(x: int) -> str:\n    return str(x)\n\ndef add_prefix(s: str) -> str:\n    return f'Value: {s}'\n\n# Compose pointfree operations\ntransform = flow(\n    Success(5),\n    map_(add_one),      # Success(6)\n    map_(to_string),    # Success('6')\n    map_(add_prefix),   # Success('Value: 6')\n)\n\nprint(transform)  # <Success: Value: 6>\n```\n\n**Example 3: Reusable Transformations**\n```python\nfrom returns.pointfree import map_\nfrom returns.result import Result, Success, Failure\n\n# Create reusable transformations\nto_upper = map_(str.upper)\nstrip = map_(str.strip)\nlength = map_(len)\n\ndef process_string(result: Result[str, str]) -> Result[int, str]:\n    \"\"\"Chain multiple map operations.\"\"\"\n    return length(to_upper(strip(result)))\n\ninput1 = Success('  hello  ')\noutput1 = process_string(input1)  # Success(5)\n\ninput2 = Failure('error')\noutput2 = process_string(input2)  # Failure('error')\n\nprint(output1)  # <Success: 5>\n```\n\n### bind() Function\n\nHandles functions returning containers, converting `a -> Container[b]` to `Container[a] -> Container[b]`.\n\n**Example 1: Basic Binding**\n```python\nfrom returns.pointfree import bind\nfrom returns.result import Result, Success, Failure\n\ndef safe_divide(x: int) -> Result[float, str]:\n    if x == 0:\n        return Failure('Division by zero')\n    return Success(1.0 / x)\n\n# Create pointfree version\ndivide_in_container = bind(safe_divide)\n\n# Apply to containers\nresult1 = divide_in_container(Success(2))   # Success(0.5)\nresult2 = divide_in_container(Success(0))   # Failure('Division by zero')\nresult3 = divide_in_container(Failure('e')) # Failure('e')\n\nprint(result1)  # <Success: 0.5>\nprint(result2)  # <Failure: Division by zero>\n```\n\n**Example 2: Chaining Operations**\n```python\nfrom returns.pointfree import bind\nfrom returns.result import Result, Success, Failure\nfrom returns.pipeline import flow\n\ndef parse_int(s: str) -> Result[int, str]:\n    try:\n        return Success(int(s))\n    except ValueError:\n        return Failure(f'Cannot parse: {s}')\n\ndef validate_positive(n: int) -> Result[int, str]:\n    if n > 0:\n        return Success(n)\n    return Failure(f'Not positive: {n}')\n\ndef calculate_square(n: int) -> Result[int, str]:\n    return Success(n * n)\n\n# Create pipeline\nprocess = lambda input: flow(\n    input,\n    bind(parse_int),\n    bind(validate_positive),\n    bind(calculate_square),\n)\n\nresult1 = process(Success('5'))    # Success(25)\nresult2 = process(Success('-3'))   # Failure('Not positive: -3')\nresult3 = process(Success('abc'))  # Failure('Cannot parse: abc')\n\nprint(result1)  # <Success: 25>\n```\n\n**Example 3: Complex Bind Chains**\n```python\nfrom returns.pointfree import bind, map_\nfrom returns.result import Result, Success, Failure\n\ndef fetch_user(user_id: int) -> Result[dict, str]:\n    users = {1: {'name': 'Alice', 'email': 'alice@example.com'}}\n    if user_id in users:\n        return Success(users[user_id])\n    return Failure(f'User {user_id} not found')\n\ndef fetch_preferences(user: dict) -> Result[dict, str]:\n    email = user.get('email')\n    prefs = {'alice@example.com': {'theme': 'dark'}}\n    if email in prefs:\n        return Success(prefs[email])\n    return Failure(f'No preferences for {email}')\n\ndef get_theme(prefs: dict) -> Result[str, str]:\n    if 'theme' in prefs:\n        return Success(prefs['theme'])\n    return Failure('No theme set')\n\n# Compose with pointfree\nget_user_theme = lambda user_id: flow(\n    Success(user_id),\n    bind(fetch_user),\n    bind(fetch_preferences),\n    bind(get_theme),\n)\n\nresult = get_user_theme(1)  # Success('dark')\nprint(result)\n```\n\n### alt() Function\n\nOperates on error states, transforming `a -> b` into `Container[_, a] -> Container[_, b]`.\n\n**Example 1: Basic Error Transformation**\n```python\nfrom returns.pointfree import alt\nfrom returns.result import Success, Failure\n\ndef make_error_friendly(error: str) -> str:\n    return f'Oops! {error}'\n\n# Create pointfree version\nfriendly_errors = alt(make_error_friendly)\n\n# Apply to containers\nresult1 = friendly_errors(Success(42))          # Success(42) - unchanged\nresult2 = friendly_errors(Failure('db error'))  # Failure('Oops! db error')\n\nprint(result1)  # <Success: 42>\nprint(result2)  # <Failure: Oops! db error>\n```\n\n**Example 2: Error Message Enhancement**\n```python\nfrom returns.pointfree import alt\nfrom returns.result import Result, Success, Failure\n\ndef add_context(error: str) -> str:\n    return f'[USER_SERVICE] {error}'\n\ndef to_upper_error(error: str) -> str:\n    return error.upper()\n\n# Chain error transformations\nenhance_errors = lambda result: flow(\n    result,\n    alt(add_context),\n    alt(to_upper_error),\n)\n\nfrom returns.pipeline import flow\n\nresult1 = enhance_errors(Failure('connection failed'))\n# Failure('[USER_SERVICE] CONNECTION FAILED')\n\nresult2 = enhance_errors(Success(100))\n# Success(100) - unchanged\n```\n\n**Example 3: Converting Error Types**\n```python\nfrom returns.pointfree import alt\nfrom returns.result import Result, Failure, Success\n\nclass APIError:\n    def __init__(self, message: str, code: int):\n        self.message = message\n        self.code = code\n\n    def __str__(self):\n        return f'APIError({self.code}): {self.message}'\n\ndef exception_to_api_error(e: Exception) -> APIError:\n    return APIError(str(e), 500)\n\n# Create converter\nconvert_errors = alt(exception_to_api_error)\n\n# Apply\nresult1 = convert_errors(Failure(ValueError('Invalid input')))\n# Failure(APIError(500): Invalid input)\n\nresult2 = convert_errors(Success({'data': 'value'}))\n# Success({'data': 'value'})\n```\n\n### lash() Function\n\nLike bind but for failed containers, enabling recovery operations.\n\n**Example 1: Basic Error Recovery**\n```python\nfrom returns.pointfree import lash\nfrom returns.result import Result, Success, Failure\n\ndef fallback_value(error: str) -> Result[int, str]:\n    print(f'Recovering from error: {error}')\n    return Success(0)\n\n# Create pointfree version\nwith_fallback = lash(fallback_value)\n\n# Apply to containers\nresult1 = with_fallback(Success(42))          # Success(42) - unchanged\nresult2 = with_fallback(Failure('db error'))  # Success(0) - recovered\n# Prints: Recovering from error: db error\n\nprint(result1)  # <Success: 42>\nprint(result2)  # <Success: 0>\n```\n\n**Example 2: Cascading Fallbacks**\n```python\nfrom returns.pointfree import lash\nfrom returns.result import Result, Success, Failure\nfrom returns.pipeline import flow\n\ndef try_cache(error: str) -> Result[str, str]:\n    print('Trying cache...')\n    return Failure('Cache miss')\n\ndef try_database(error: str) -> Result[str, str]:\n    print('Trying database...')\n    return Success('Data from database')\n\ndef try_default(error: str) -> Result[str, str]:\n    print('Using default...')\n    return Success('Default data')\n\n# Create cascading fallback\nfetch_with_fallbacks = lambda: flow(\n    Failure('Initial failure'),\n    lash(try_cache),\n    lash(try_database),\n    lash(try_default),\n)\n\nresult = fetch_with_fallbacks()\n# Prints:\n# Trying cache...\n# Trying database...\n# Result: Success('Data from database')\n```\n\n**Example 3: Conditional Recovery**\n```python\nfrom returns.pointfree import lash\nfrom returns.result import Result, Success, Failure\n\nclass NetworkError(Exception):\n    pass\n\nclass ValidationError(Exception):\n    pass\n\ndef recover_network_error(error: Exception) -> Result[dict, Exception]:\n    if isinstance(error, NetworkError):\n        print('Network error detected, using cached data')\n        return Success({'cached': True, 'data': []})\n    return Failure(error)  # Don't recover from other errors\n\n# Create recovery function\nwith_network_recovery = lash(recover_network_error)\n\n# Apply\nresult1 = with_network_recovery(Failure(NetworkError('Timeout')))\n# Success({'cached': True, 'data': []})\n\nresult2 = with_network_recovery(Failure(ValidationError('Invalid input')))\n# Failure(ValidationError('Invalid input'))\n\nresult3 = with_network_recovery(Success({'data': [1, 2, 3]}))\n# Success({'data': [1, 2, 3]})\n```\n\n### apply() Function\n\nEnables using container-wrapped functions as callables.\n\n**Example 1: Basic Apply**\n```python\nfrom returns.pointfree import apply\nfrom returns.result import Success, Failure\n\n# Container with function\ndef add_ten(x: int) -> int:\n    return x + 10\n\nfunc_container = Success(add_ten)\nvalue_container = Success(5)\n\n# Apply the wrapped function\nresult = apply(func_container)(value_container)  # Success(15)\n\nprint(result)  # <Success: 15>\n```\n\n**Example 2: Partial Application Pattern**\n```python\nfrom returns.pointfree import apply\nfrom returns.result import Success, Failure\n\ndef multiply(x: int) -> callable:\n    def _multiply(y: int) -> int:\n        return x * y\n    return _multiply\n\n# Create partially applied function in container\ndouble = Success(multiply(2))\ntriple = Success(multiply(3))\n\n# Apply to values\nresult1 = apply(double)(Success(5))   # Success(10)\nresult2 = apply(triple)(Success(5))   # Success(15)\n\n# Failure propagates\nresult3 = apply(Failure('e'))(Success(5))   # Failure('e')\nresult4 = apply(double)(Failure('e'))       # Failure('e')\n```\n\n**Example 3: Function Composition in Containers**\n```python\nfrom returns.pointfree import apply\nfrom returns.result import Success, Result\n\ndef compose_functions(f, g):\n    \"\"\"Compose two functions.\"\"\"\n    def _composed(x):\n        return f(g(x))\n    return _composed\n\n# Functions in containers\nadd_one = Success(lambda x: x + 1)\ndouble = Success(lambda x: x * 2)\n\n# Compose them\ncomposed = Success(compose_functions).apply(add_one).apply(double)\n\n# Wait, apply doesn't work this way. Let me fix:\n# apply is used differently\n\n# Correct usage with apply\nfunc_in_container = Success(lambda x: x * 2)\nvalue_in_container = Success(21)\n\nresult = apply(func_in_container)(value_in_container)  # Success(42)\nprint(result)\n```\n\n### Specialized Binds\n\n**Example 1: bind_result for Result Types**\n```python\nfrom returns.pointfree import bind_result\nfrom returns.io import IOResult, impure_safe\n\n@impure_safe\ndef read_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\ndef parse_json(content: str) -> Result[dict, Exception]:\n    import json\n    try:\n        return Success(json.loads(content))\n    except json.JSONDecodeError as e:\n        return Failure(e)\n\n# bind_result works with IOResult\nprocess_file = lambda path: bind_result(parse_json)(read_file(path))\n\n# result = process_file('config.json')\n# IOResult[dict, Exception]\n```\n\n**Example 2: bind_io for IO Types**\n```python\nfrom returns.pointfree import bind_io\nfrom returns.io import IO, impure\n\n@impure\ndef get_timestamp() -> float:\n    import time\n    return time.time()\n\n@impure\ndef format_timestamp(ts: float) -> str:\n    import datetime\n    return datetime.datetime.fromtimestamp(ts).isoformat()\n\n# Compose IO operations\nformatted_time = bind_io(format_timestamp)(get_timestamp())\n\n# Execute\n# print(formatted_time.unwrap())\n```\n\n**Example 3: bind_async for Async Operations**\n```python\nfrom returns.pointfree import bind_async\nfrom returns.future import Future, future\nimport asyncio\n\n@future\nasync def fetch_user_id(email: str) -> int:\n    await asyncio.sleep(0.1)\n    return 123\n\n@future\nasync def fetch_user_data(user_id: int) -> dict:\n    await asyncio.sleep(0.1)\n    return {'id': user_id, 'name': 'Alice'}\n\n# Compose async operations\nget_user_by_email = lambda email: bind_async(fetch_user_data)(fetch_user_id(email))\n\n# Execute\nasync def main():\n    io_result = await get_user_by_email('alice@example.com').awaitable()\n    print(io_result.unwrap())\n\n# asyncio.run(main())\n```\n\n---\n\n## Primitive Types\n\nThe `returns` library provides several composite primitive types that combine multiple effects.\n\n### IOResult\n\nCombines IO effects with Result for impure operations that can fail.\n\n**Example 1: File Operations**\n```python\nfrom returns.io import IOResult, impure_safe\n\n@impure_safe\ndef read_config(path: str) -> dict:\n    import json\n    with open(path, 'r') as f:\n        return json.load(f)\n\n@impure_safe\ndef write_config(path: str, data: dict) -> None:\n    import json\n    with open(path, 'w') as f:\n        json.dump(data, f, indent=2)\n\n# These return IOResult[T, Exception]\nconfig_result = read_config('config.json')\n# IOSuccess({...}) or IOFailure(FileNotFoundError(...))\n\nwrite_result = write_config('config.json', {'key': 'value'})\n# IOSuccess(None) or IOFailure(PermissionError(...))\n\n# Execute and handle\nmatch config_result.unwrap():\n    case Success(data):\n        print(f'Config loaded: {data}')\n    case Failure(error):\n        print(f'Failed to load config: {error}')\n```\n\n**Example 2: Database Operations**\n```python\nfrom returns.io import IOResult, impure_safe\nfrom returns.result import Success, Failure\n\n@impure_safe\ndef query_database(sql: str) -> list[dict]:\n    # Simulated database query\n    if 'SELECT' in sql:\n        return [{'id': 1, 'name': 'Alice'}]\n    raise ValueError('Only SELECT queries allowed')\n\n@impure_safe\ndef insert_record(table: str, data: dict) -> int:\n    # Simulated insert\n    print(f'Inserting into {table}: {data}')\n    return 1  # Return ID\n\n# Compose database operations\ndef fetch_and_update_user(user_id: int) -> IOResult[int, Exception]:\n    return (\n        query_database(f'SELECT * FROM users WHERE id = {user_id}')\n        .map(lambda rows: rows[0] if rows else None)\n        .bind(lambda user: insert_record('audit_log', {'user_id': user['id']}))\n    )\n\n# result = fetch_and_update_user(1)\n```\n\n**Example 3: Network Requests**\n```python\nfrom returns.io import IOResult, impure_safe\nimport requests\n\n@impure_safe\ndef fetch_json(url: str) -> dict:\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()\n    return response.json()\n\n@impure_safe\ndef post_json(url: str, data: dict) -> dict:\n    response = requests.post(url, json=data, timeout=10)\n    response.raise_for_status()\n    return response.json()\n\n# Compose HTTP operations\ndef fetch_and_post(get_url: str, post_url: str) -> IOResult[dict, Exception]:\n    return (\n        fetch_json(get_url)\n        .map(lambda data: {**data, 'processed': True})\n        .bind(lambda processed: post_json(post_url, processed))\n    )\n\n# response = fetch_and_post('https://api.example.com/data', 'https://api.example.com/submit')\n```\n\n### FutureResult\n\nCombines async operations with Result for async operations that can fail.\n\n**Example 1: Async API Calls**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\nimport aiohttp\n\n@future_safe\nasync def async_fetch_user(user_id: int) -> dict:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f'https://api.example.com/users/{user_id}') as response:\n            response.raise_for_status()\n            return await response.json()\n\n@future_safe\nasync def async_fetch_posts(user_id: int) -> list:\n    await asyncio.sleep(0.1)\n    # Simulate API call\n    return [{'id': 1, 'title': 'Post 1'}, {'id': 2, 'title': 'Post 2'}]\n\n# Compose async operations\ndef get_user_with_posts(user_id: int) -> FutureResult[dict, Exception]:\n    def _add_posts(user: dict) -> FutureResult[dict, Exception]:\n        return async_fetch_posts(user_id).map(\n            lambda posts: {**user, 'posts': posts}\n        )\n\n    return async_fetch_user(user_id).bind(_add_posts)\n\n# Execute\nasync def main():\n    io_result = await get_user_with_posts(1).awaitable()\n    match io_result.unwrap():\n        case Success(data):\n            print(f'User data: {data}')\n        case Failure(error):\n            print(f'Error: {error}')\n\n# asyncio.run(main())\n```\n\n**Example 2: Parallel Async Operations**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_weather() -> dict:\n    await asyncio.sleep(0.2)\n    return {'temp': 72, 'conditions': 'Sunny'}\n\n@future_safe\nasync def fetch_news() -> list:\n    await asyncio.sleep(0.15)\n    return ['News 1', 'News 2']\n\n@future_safe\nasync def fetch_stocks() -> dict:\n    await asyncio.sleep(0.1)\n    return {'AAPL': 150.25, 'GOOGL': 2800.50}\n\nasync def fetch_dashboard_data() -> dict:\n    # Launch all in parallel\n    weather_future = fetch_weather().awaitable()\n    news_future = fetch_news().awaitable()\n    stocks_future = fetch_stocks().awaitable()\n\n    # Wait for all\n    weather, news, stocks = await asyncio.gather(\n        weather_future,\n        news_future,\n        stocks_future\n    )\n\n    # Combine results\n    return {\n        'weather': weather.unwrap().unwrap(),\n        'news': news.unwrap().unwrap(),\n        'stocks': stocks.unwrap().unwrap()\n    }\n\n# async def main():\n#     dashboard = await fetch_dashboard_data()\n#     print(dashboard)\n```\n\n**Example 3: Retry Logic with FutureResult**\n```python\nfrom returns.future import FutureResult, future_safe\nfrom returns.result import Success, Failure\nimport asyncio\n\n@future_safe\nasync def unreliable_async_call() -> str:\n    await asyncio.sleep(0.1)\n    import random\n    if random.random() < 0.7:\n        raise Exception('Random failure')\n    return 'Success!'\n\nasync def retry_async(\n    operation: FutureResult,\n    max_retries: int = 3\n) -> IOResult[str, Exception]:\n    for attempt in range(max_retries):\n        result = await operation.awaitable()\n        inner = result.unwrap()\n\n        match inner:\n            case Success(value):\n                return result\n            case Failure(error):\n                if attempt < max_retries - 1:\n                    print(f'Attempt {attempt + 1} failed, retrying...')\n                    await asyncio.sleep(0.5)\n                else:\n                    print('All retries exhausted')\n                    return result\n\n# async def main():\n#     result = await retry_async(unreliable_async_call())\n#     print(result.unwrap())\n```\n\n### RequiresContextResult\n\n**Already covered in detail in [RequiresContext Deep Dive](#requirescontextresult)**\n\n### RequiresContextIOResult\n\n**Already covered in detail in [RequiresContext Deep Dive](#requirescontextioresult)**\n\n### RequiresContextFutureResult\n\n**Already covered in detail in [RequiresContext Deep Dive](#requirescontextfutureresult)**\n\n---\n\n## Conclusion\n\nThis guide covered advanced features of the `returns` library:\n\n- **Methods Module**: Utilities like `cond()`, `partition()`, and `is_successful()`\n- **RequiresContext**: Comprehensive dependency injection patterns\n- **Converters**: Transforming between container types\n- **Pointfree Helpers**: Functional composition tools\n- **Primitive Types**: Composite types combining multiple effects\n\n**Key Takeaways:**\n\n1. Use `methods.cond()` for functional conditionals\n2. Use `partition()` to separate successful and failed results\n3. RequiresContext variants enable typed dependency injection\n4. Converters allow flexible transformation between types\n5. Pointfree style enables cleaner function composition\n6. Primitive types like IOResult and FutureResult combine effects safely\n\n**Next Steps:**\n- Explore the [official documentation](https://returns.readthedocs.io/)\n- Review Part 1 for core types and containers\n- Practice combining these patterns in real applications\n\n**Resources:**\n- [Official Documentation](https://returns.readthedocs.io/)\n- [GitHub Repository](https://github.com/dry-python/returns)\n- [Railway-Oriented Programming](https://fsharpforfunandprofit.com/rop/)\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":17357,"cache_read_input_tokens":31260,"cache_creation":{"ephemeral_5m_input_tokens":17357,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXMS3vbGfe2rshgus14C7","type":"assistant","uuid":"6c939be0-3fa0-433c-8f2e-1bed7529a3b5","timestamp":"2026-01-22T00:02:50.793Z"}
{"type":"file-history-snapshot","messageId":"6c939be0-3fa0-433c-8f2e-1bed7529a3b5","snapshot":{"messageId":"48e41a28-8b07-4866-8f09-491a51cfde0b","trackedFileBackups":{"docs/python/references/returns-part1-core-types.md":{"backupFileName":null,"version":1,"backupTime":"2026-01-22T00:00:06.942Z"},"docs/python/references/returns-part2-advanced-features.md":{"backupFileName":"8f43ca35485f1e5c@v1","version":1,"backupTime":"2026-01-22T00:02:50.873Z"}},"timestamp":"2026-01-21T23:57:00.493Z"},"isSnapshotUpdate":true}
{"parentUuid":"6c939be0-3fa0-433c-8f2e-1bed7529a3b5","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W83xSVt8xiuPrZQz8CYQzd","type":"tool_result","content":"File created successfully at: /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/docs/python/references/returns-part2-advanced-features.md"}]},"uuid":"123599a4-894d-43ec-8560-ce05c540dd8a","timestamp":"2026-01-22T00:02:50.873Z","toolUseResult":{"type":"create","filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/docs/python/references/returns-part2-advanced-features.md","content":"# Returns Library Guide - Part 2: Advanced Features\n\nA comprehensive guide to advanced features, methods, converters, and primitive types in the `returns` library.\n\n## Table of Contents\n\n1. [Introduction](#introduction)\n2. [Methods Module](#methods-module)\n   - [cond() Function](#cond-function)\n   - [unwrap_or_failure() Function](#unwrap_or_failure-function)\n   - [partition() Function](#partition-function)\n   - [is_successful() Function](#is_successful-function)\n3. [RequiresContext Deep Dive](#requirescontext-deep-dive)\n   - [RequiresContext Basics](#requirescontext-basics-1)\n   - [RequiresContextResult](#requirescontextresult)\n   - [RequiresContextIOResult](#requirescontextioresult)\n   - [RequiresContextFutureResult](#requirescontextfutureresult)\n   - [Complex Context Patterns](#complex-context-patterns)\n4. [Converters](#converters)\n   - [result_to_maybe()](#result_to_maybe)\n   - [maybe_to_result()](#maybe_to_result)\n   - [flatten()](#flatten)\n   - [Advanced Conversions](#advanced-conversions)\n5. [Helper Functions (Pointfree)](#helper-functions-pointfree)\n   - [map_() Function](#map_-function)\n   - [bind() Function](#bind-function)\n   - [alt() Function](#alt-function)\n   - [lash() Function](#lash-function)\n   - [apply() Function](#apply-function)\n   - [Specialized Binds](#specialized-binds)\n6. [Primitive Types](#primitive-types)\n   - [IOResult](#ioresult)\n   - [FutureResult](#futureresult-1)\n   - [RequiresContextResult](#requirescontextresult-1)\n   - [RequiresContextIOResult](#requirescontextioresult-1)\n   - [RequiresContextFutureResult](#requirescontextfutureresult-1)\n\n---\n\n## Introduction\n\nThis guide covers advanced features of the `returns` library including utility methods, type converters, pointfree helpers, and composite primitive types that combine multiple effects.\n\n**Import conventions:**\n```python\nfrom returns import methods\nfrom returns.converters import result_to_maybe, maybe_to_result, flatten\nfrom returns.pointfree import map_, bind, alt, lash, apply\nfrom returns.io import IOResult, impure_safe\nfrom returns.future import FutureResult, future_safe\nfrom returns.context import (\n    RequiresContext,\n    RequiresContextResult,\n    RequiresContextIOResult,\n    RequiresContextFutureResult,\n)\n```\n\n---\n\n## Methods Module\n\nThe `methods` module provides utility functions for working with container types.\n\n### cond() Function\n\nThe `cond()` function provides a functional alternative to if/else statements for container types.\n\n**Example 1: Basic Conditional**\n```python\nfrom returns import methods\nfrom returns.result import Result\n\ndef check_number(n: int) -> Result[str, str]:\n    return methods.cond(\n        Result,\n        n > 0,\n        'Positive number',\n        'Non-positive number'\n    )\n\nresult1 = check_number(5)    # Success('Positive number')\nresult2 = check_number(-3)   # Failure('Non-positive number')\nresult3 = check_number(0)    # Failure('Non-positive number')\n\nprint(result1)  # <Success: Positive number>\nprint(result2)  # <Failure: Non-positive number>\n```\n\n**Example 2: Validation with cond**\n```python\nfrom returns import methods\nfrom returns.result import Result\n\ndef validate_age(age: int) -> Result[int, str]:\n    return methods.cond(\n        Result,\n        0 <= age <= 150,\n        age,\n        f'Invalid age: {age}'\n    )\n\ndef validate_email(email: str) -> Result[str, str]:\n    return methods.cond(\n        Result,\n        '@' in email and '.' in email,\n        email,\n        f'Invalid email: {email}'\n    )\n\nage_result = validate_age(25)              # Success(25)\ninvalid_age = validate_age(200)            # Failure('Invalid age: 200')\n\nemail_result = validate_email('a@b.com')   # Success('a@b.com')\ninvalid_email = validate_email('notanemail') # Failure('Invalid email: notanemail')\n```\n\n**Example 3: Pipeline Integration**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success\nfrom returns.pipeline import flow\n\ndef is_even(n: int) -> bool:\n    return n % 2 == 0\n\ndef process_number(n: int) -> Result[str, str]:\n    return methods.cond(\n        Result,\n        is_even(n),\n        f'{n} is even',\n        f'{n} is odd'\n    )\n\n# Use in a chain\ndef validate_and_check(s: str) -> Result[str, str]:\n    return (\n        Success(s)\n        .map(int)\n        .bind(lambda n: methods.cond(\n            Result,\n            n > 0,\n            n,\n            'Number must be positive'\n        ))\n        .bind(process_number)\n    )\n\nresult1 = validate_and_check('4')   # Success('4 is even')\nresult2 = validate_and_check('5')   # Success('5 is odd')\nresult3 = validate_and_check('-2')  # Failure('Number must be positive')\n```\n\n### unwrap_or_failure() Function\n\nExtracts values from container types, retrieving either the success or failure value.\n\n**Example 1: Basic Unwrapping**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\n\nsuccess_value = Success(42)\nfailure_value = Failure('error')\n\n# Extract the inner value (success or failure)\nvalue1 = methods.unwrap_or_failure(success_value)  # 42\nvalue2 = methods.unwrap_or_failure(failure_value)  # 'error'\n\nprint(value1)  # 42\nprint(value2)  # 'error'\n```\n\n**Example 2: After bimap Transformation**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\n\ndef double(x: int) -> int:\n    return x * 2\n\ndef error_to_upper(e: str) -> str:\n    return e.upper()\n\nsuccess = Success(21)\nfailure = Failure('network error')\n\n# Transform both channels\ntransformed_success = success.bimap(double, error_to_upper)\ntransformed_failure = failure.bimap(double, error_to_upper)\n\n# Unwrap the transformed values\nprint(methods.unwrap_or_failure(transformed_success))  # 42\nprint(methods.unwrap_or_failure(transformed_failure))  # 'NETWORK ERROR'\n```\n\n**Example 3: Logging Results**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\n\ndef process_data(data: str) -> Result[int, str]:\n    try:\n        return Success(int(data))\n    except ValueError:\n        return Failure(f'Invalid data: {data}')\n\ndef log_result(result: Result[int, str]) -> None:\n    value = methods.unwrap_or_failure(result)\n    result_type = 'Success' if result.is_success() else 'Failure'\n    print(f'{result_type}: {value}')\n\nlog_result(process_data('42'))   # Success: 42\nlog_result(process_data('abc'))  # Failure: Invalid data: abc\n```\n\n### partition() Function\n\nConverts a list of container instances into separate lists of successes and failures.\n\n**Example 1: Basic Partitioning**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\n\nresults = [\n    Success(1),\n    Failure('error 1'),\n    Success(2),\n    Success(3),\n    Failure('error 2'),\n]\n\nsuccesses, failures = methods.partition(results)\n\nprint(successes)  # [1, 2, 3]\nprint(failures)   # ['error 1', 'error 2']\n```\n\n**Example 2: Batch Processing**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\n\ndef parse_int(s: str) -> Result[int, str]:\n    try:\n        return Success(int(s))\n    except ValueError:\n        return Failure(f'Cannot parse: {s}')\n\ninputs = ['1', '2', 'abc', '3', 'def', '4']\nresults = [parse_int(s) for s in inputs]\n\nvalid, invalid = methods.partition(results)\n\nprint(f'Valid numbers: {valid}')      # Valid numbers: [1, 2, 3, 4]\nprint(f'Invalid inputs: {invalid}')   # Invalid inputs: ['Cannot parse: abc', ...]\n```\n\n**Example 3: Validation Report**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\nfrom typing import List\n\ndef validate_email(email: str) -> Result[str, str]:\n    if '@' not in email:\n        return Failure(f'{email}: missing @')\n    if '.' not in email.split('@')[1]:\n        return Failure(f'{email}: invalid domain')\n    return Success(email)\n\ndef validate_all_emails(emails: List[str]) -> dict:\n    results = [validate_email(email) for email in emails]\n    valid, invalid = methods.partition(results)\n\n    return {\n        'valid_count': len(valid),\n        'invalid_count': len(invalid),\n        'valid_emails': valid,\n        'errors': invalid\n    }\n\nemails = [\n    'alice@example.com',\n    'invalid',\n    'bob@test.com',\n    'missing@domain',\n    'charlie@company.org'\n]\n\nreport = validate_all_emails(emails)\nprint(f\"Valid: {report['valid_count']}, Invalid: {report['invalid_count']}\")\nprint(f\"Errors: {report['errors']}\")\n```\n\n### is_successful() Function\n\nDetermines whether a container represents a success state.\n\n**Example 1: Basic Success Checking**\n```python\nfrom returns import methods\nfrom returns.result import Success, Failure\nfrom returns.maybe import Some, Nothing\n\n# Result types\nassert methods.is_successful(Success(42)) == True\nassert methods.is_successful(Failure('error')) == False\n\n# Maybe types\nassert methods.is_successful(Some(100)) == True\nassert methods.is_successful(Nothing) == False\n```\n\n**Example 2: Filtering Successful Results**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\nfrom typing import List\n\ndef process_batch(items: List[str]) -> List[Result[int, str]]:\n    results = []\n    for item in items:\n        try:\n            results.append(Success(int(item)))\n        except ValueError:\n            results.append(Failure(f'Invalid: {item}'))\n    return results\n\ndef get_successful_results(results: List[Result]) -> List[Result]:\n    return [r for r in results if methods.is_successful(r)]\n\ndef get_failed_results(results: List[Result]) -> List[Result]:\n    return [r for r in results if not methods.is_successful(r)]\n\nitems = ['1', '2', 'abc', '3']\nresults = process_batch(items)\n\nsuccessful = get_successful_results(results)\nfailed = get_failed_results(results)\n\nprint(f'Successful: {len(successful)}')  # Successful: 3\nprint(f'Failed: {len(failed)}')          # Failed: 1\n```\n\n**Example 3: Conditional Processing**\n```python\nfrom returns import methods\nfrom returns.result import Result, Success, Failure\n\ndef process_with_retry(result: Result[int, str], retries: int = 3) -> Result[int, str]:\n    if methods.is_successful(result):\n        return result\n\n    # Retry logic for failures\n    for attempt in range(retries):\n        print(f'Retry attempt {attempt + 1}')\n        # Simulate retry (in real code, would retry the operation)\n        new_result = Success(42) if attempt == retries - 1 else result\n\n        if methods.is_successful(new_result):\n            return new_result\n\n    return result\n\n# First call succeeds\nresult1 = process_with_retry(Success(100))\nprint(result1)  # <Success: 100>\n\n# First call fails, retries\nresult2 = process_with_retry(Failure('timeout'))\nprint(result2)  # <Success: 42> (after retries)\n```\n\n---\n\n## RequiresContext Deep Dive\n\nThe Context module provides several specialized containers for dependency injection combined with different effects.\n\n### RequiresContext Basics\n\n**Example 1: Simple Context Function**\n```python\nfrom returns.context import RequiresContext\n\ndef get_api_key() -> RequiresContext[str, dict]:\n    \"\"\"Extract API key from config context.\"\"\"\n    return RequiresContext.ask().map(lambda config: config['api_key'])\n\ndef get_timeout() -> RequiresContext[int, dict]:\n    \"\"\"Extract timeout from config context.\"\"\"\n    return RequiresContext.ask().map(lambda config: config.get('timeout', 30))\n\n# Provide context\nconfig = {\n    'api_key': 'secret-key-123',\n    'timeout': 60,\n    'debug': True\n}\n\napi_key = get_api_key()(config)  # 'secret-key-123'\ntimeout = get_timeout()(config)   # 60\n```\n\n**Example 2: Composing Context Operations**\n```python\nfrom returns.context import RequiresContext\n\nclass AppConfig:\n    def __init__(self, base_url: str, api_version: str):\n        self.base_url = base_url\n        self.api_version = api_version\n\ndef get_base_url() -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(lambda c: c.base_url)\n\ndef get_api_version() -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(lambda c: c.api_version)\n\ndef build_api_url(endpoint: str) -> RequiresContext[str, AppConfig]:\n    return RequiresContext.ask().map(\n        lambda c: f'{c.base_url}/api/{c.api_version}/{endpoint}'\n    )\n\n# Alternative: compose existing functions\ndef build_api_url_v2(endpoint: str) -> RequiresContext[str, AppConfig]:\n    def _build(base_url: str) -> RequiresContext[str, AppConfig]:\n        return get_api_version().map(\n            lambda version: f'{base_url}/api/{version}/{endpoint}'\n        )\n    return get_base_url().bind(_build)\n\nconfig = AppConfig('https://api.example.com', 'v2')\nurl = build_api_url('users')(config)\n# 'https://api.example.com/api/v2/users'\n```\n\n**Example 3: Complex Context Transformations**\n```python\nfrom returns.context import RequiresContext\nfrom typing import List\n\nclass DatabaseConfig:\n    def __init__(self, host: str, port: int, database: str, pool_size: int):\n        self.host = host\n        self.port = port\n        self.database = database\n        self.pool_size = pool_size\n\ndef get_connection_string() -> RequiresContext[str, DatabaseConfig]:\n    return RequiresContext.ask().map(\n        lambda c: f'postgresql://{c.host}:{c.port}/{c.database}'\n    )\n\ndef get_pool_config() -> RequiresContext[dict, DatabaseConfig]:\n    return RequiresContext.ask().map(\n        lambda c: {\n            'pool_size': c.pool_size,\n            'max_overflow': c.pool_size * 2,\n            'pool_timeout': 30\n        }\n    )\n\ndef create_engine_config() -> RequiresContext[dict, DatabaseConfig]:\n    def _combine(conn_str: str) -> RequiresContext[dict, DatabaseConfig]:\n        return get_pool_config().map(\n            lambda pool: {\n                'connection_string': conn_str,\n                **pool\n            }\n        )\n    return get_connection_string().bind(_combine)\n\ndb_config = DatabaseConfig('localhost', 5432, 'myapp', 10)\nengine_config = create_engine_config()(db_config)\n# {'connection_string': 'postgresql://localhost:5432/myapp',\n#  'pool_size': 10, 'max_overflow': 20, 'pool_timeout': 30}\n```\n\n### RequiresContextResult\n\nCombines context dependency with Result for operations that require config and can fail.\n\n**Example 1: Basic RequiresContextResult**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure\n\ndef validate_api_key(key: str) -> RequiresContextResult[str, str, dict]:\n    \"\"\"Validate API key against config.\"\"\"\n    def _validate(config: dict) -> Result[str, str]:\n        expected_key = config.get('expected_api_key')\n        if key == expected_key:\n            return Success(key)\n        return Failure('Invalid API key')\n\n    return RequiresContextResult(_validate)\n\nconfig = {'expected_api_key': 'secret123'}\n\nresult1 = validate_api_key('secret123')(config)  # Success('secret123')\nresult2 = validate_api_key('wrong')(config)      # Failure('Invalid API key')\n```\n\n**Example 2: Database Operations with Context**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure, Result\n\nclass DbContext:\n    def __init__(self, connection_string: str, max_retries: int):\n        self.connection_string = connection_string\n        self.max_retries = max_retries\n\ndef fetch_user(user_id: int) -> RequiresContextResult[dict, str, DbContext]:\n    \"\"\"Fetch user from database using connection from context.\"\"\"\n    def _fetch(ctx: DbContext) -> Result[dict, str]:\n        print(f'Connecting to {ctx.connection_string}')\n        # Simulate database query\n        if user_id > 0:\n            return Success({'id': user_id, 'name': f'User{user_id}'})\n        return Failure('Invalid user ID')\n\n    return RequiresContextResult(_fetch)\n\ndef update_user(user_id: int, name: str) -> RequiresContextResult[bool, str, DbContext]:\n    \"\"\"Update user in database.\"\"\"\n    def _update(ctx: DbContext) -> Result[bool, str]:\n        print(f'Updating user {user_id} with {ctx.max_retries} max retries')\n        # Simulate update\n        if user_id > 0:\n            return Success(True)\n        return Failure('Cannot update invalid user')\n\n    return RequiresContextResult(_update)\n\n# Use with context\ndb_ctx = DbContext('postgresql://localhost/db', 3)\n\nuser_result = fetch_user(123)(db_ctx)\n# Connects and returns Success({'id': 123, 'name': 'User123'})\n\nupdate_result = update_user(123, 'Alice')(db_ctx)\n# Returns Success(True)\n```\n\n**Example 3: Chaining Context-Result Operations**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure, Result\n\nclass AppContext:\n    def __init__(self, db_url: str, cache_enabled: bool):\n        self.db_url = db_url\n        self.cache_enabled = cache_enabled\n\ndef check_cache(key: str) -> RequiresContextResult[str, str, AppContext]:\n    \"\"\"Check cache if enabled.\"\"\"\n    def _check(ctx: AppContext) -> Result[str, str]:\n        if not ctx.cache_enabled:\n            return Failure('Cache disabled')\n        # Simulate cache lookup\n        if key == 'user:1':\n            return Success('Cached data for user:1')\n        return Failure('Cache miss')\n\n    return RequiresContextResult(_check)\n\ndef fetch_from_db(error: str) -> RequiresContextResult[str, str, AppContext]:\n    \"\"\"Fallback to database on cache miss.\"\"\"\n    def _fetch(ctx: AppContext) -> Result[str, str]:\n        print(f'Cache failed: {error}, fetching from {ctx.db_url}')\n        return Success('Fresh data from database')\n\n    return RequiresContextResult(lambda ctx: _fetch(ctx))\n\ndef get_data(key: str) -> RequiresContextResult[str, str, AppContext]:\n    \"\"\"Get data with cache fallback.\"\"\"\n    return check_cache(key).lash(fetch_from_db)\n\nctx = AppContext('postgresql://localhost/db', True)\nresult = get_data('user:1')(ctx)  # Success('Cached data for user:1')\n\nctx_no_cache = AppContext('postgresql://localhost/db', False)\nresult2 = get_data('user:1')(ctx_no_cache)\n# Prints: Cache failed: Cache disabled, fetching from postgresql://localhost/db\n# Success('Fresh data from database')\n```\n\n### RequiresContextIOResult\n\nCombines context, IO effects, and Result for impure operations that need config and can fail.\n\n**Example 1: File Operations with Context**\n```python\nfrom returns.context import RequiresContextIOResult\nfrom returns.io import IOResult\nfrom returns.result import Success, Failure\n\nclass FileContext:\n    def __init__(self, base_path: str, encoding: str):\n        self.base_path = base_path\n        self.encoding = encoding\n\ndef read_config_file(filename: str) -> RequiresContextIOResult[str, str, FileContext]:\n    \"\"\"Read file using base path from context.\"\"\"\n    def _read(ctx: FileContext) -> IOResult[str, str]:\n        import os\n        full_path = os.path.join(ctx.base_path, filename)\n        try:\n            with open(full_path, 'r', encoding=ctx.encoding) as f:\n                return IOResult.from_result(Success(f.read()))\n        except FileNotFoundError:\n            return IOResult.from_result(Failure(f'File not found: {full_path}'))\n        except Exception as e:\n            return IOResult.from_result(Failure(str(e)))\n\n    return RequiresContextIOResult(_read)\n\ndef write_log(message: str) -> RequiresContextIOResult[None, str, FileContext]:\n    \"\"\"Write to log file.\"\"\"\n    def _write(ctx: FileContext) -> IOResult[None, str]:\n        import os\n        log_path = os.path.join(ctx.base_path, 'app.log')\n        try:\n            with open(log_path, 'a', encoding=ctx.encoding) as f:\n                f.write(message + '\\n')\n            return IOResult.from_result(Success(None))\n        except Exception as e:\n            return IOResult.from_result(Failure(str(e)))\n\n    return RequiresContextIOResult(_write)\n\n# Usage\nfile_ctx = FileContext('/app/data', 'utf-8')\n\n# These return IOResult when executed\n# config = read_config_file('config.json')(file_ctx)\n# log_result = write_log('Application started')(file_ctx)\n```\n\n**Example 2: HTTP Requests with Context**\n```python\nfrom returns.context import RequiresContextIOResult\nfrom returns.io import IOResult, impure_safe\nfrom returns.result import Success, Failure\n\nclass APIContext:\n    def __init__(self, base_url: str, api_key: str, timeout: int):\n        self.base_url = base_url\n        self.api_key = api_key\n        self.timeout = timeout\n\ndef make_request(endpoint: str) -> RequiresContextIOResult[dict, str, APIContext]:\n    \"\"\"Make HTTP request using API context.\"\"\"\n    def _request(ctx: APIContext) -> IOResult[dict, str]:\n        import requests\n\n        @impure_safe\n        def _do_request() -> dict:\n            url = f'{ctx.base_url}/{endpoint}'\n            headers = {'Authorization': f'Bearer {ctx.api_key}'}\n            response = requests.get(url, headers=headers, timeout=ctx.timeout)\n            response.raise_for_status()\n            return response.json()\n\n        return _do_request().alt(lambda e: f'Request failed: {str(e)}')\n\n    return RequiresContextIOResult(_request)\n\ndef fetch_user_data(user_id: int) -> RequiresContextIOResult[dict, str, APIContext]:\n    \"\"\"Fetch user data from API.\"\"\"\n    return make_request(f'users/{user_id}')\n\n# Usage\napi_ctx = APIContext('https://api.example.com', 'secret-key', 30)\n# user_data = fetch_user_data(123)(api_ctx)\n```\n\n**Example 3: Database with Transaction Context**\n```python\nfrom returns.context import RequiresContextIOResult\nfrom returns.io import IOResult\nfrom returns.result import Success, Failure\n\nclass TransactionContext:\n    def __init__(self, conn_string: str, isolation_level: str):\n        self.conn_string = conn_string\n        self.isolation_level = isolation_level\n        self.transaction = None\n\ndef begin_transaction() -> RequiresContextIOResult[None, str, TransactionContext]:\n    \"\"\"Begin database transaction.\"\"\"\n    def _begin(ctx: TransactionContext) -> IOResult[None, str]:\n        print(f'Beginning transaction with {ctx.isolation_level} isolation')\n        ctx.transaction = {'active': True}\n        return IOResult.from_result(Success(None))\n\n    return RequiresContextIOResult(_begin)\n\ndef execute_query(query: str) -> RequiresContextIOResult[list, str, TransactionContext]:\n    \"\"\"Execute query in transaction.\"\"\"\n    def _execute(ctx: TransactionContext) -> IOResult[list, str]:\n        if not ctx.transaction or not ctx.transaction.get('active'):\n            return IOResult.from_result(Failure('No active transaction'))\n\n        print(f'Executing: {query}')\n        # Simulate query execution\n        return IOResult.from_result(Success([{'id': 1}]))\n\n    return RequiresContextIOResult(_execute)\n\ndef commit_transaction() -> RequiresContextIOResult[None, str, TransactionContext]:\n    \"\"\"Commit transaction.\"\"\"\n    def _commit(ctx: TransactionContext) -> IOResult[None, str]:\n        if ctx.transaction:\n            print('Committing transaction')\n            ctx.transaction['active'] = False\n        return IOResult.from_result(Success(None))\n\n    return RequiresContextIOResult(_commit)\n\n# Chain transaction operations\ndef run_transaction() -> RequiresContextIOResult[list, str, TransactionContext]:\n    return (\n        begin_transaction()\n        .bind(lambda _: execute_query('INSERT INTO users VALUES (1)'))\n        .bind(lambda result: commit_transaction().map(lambda _: result))\n    )\n\ntx_ctx = TransactionContext('postgresql://localhost/db', 'READ_COMMITTED')\n# result = run_transaction()(tx_ctx)\n```\n\n### RequiresContextFutureResult\n\nCombines context, async operations, and Result for async operations that need config and can fail.\n\n**Example 1: Async API Calls with Context**\n```python\nfrom returns.context import RequiresContextFutureResult\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\nclass AsyncAPIContext:\n    def __init__(self, base_url: str, api_key: str):\n        self.base_url = base_url\n        self.api_key = api_key\n\ndef async_fetch_user(user_id: int) -> RequiresContextFutureResult[dict, str, AsyncAPIContext]:\n    \"\"\"Fetch user asynchronously using API context.\"\"\"\n    def _fetch(ctx: AsyncAPIContext) -> FutureResult[dict, str]:\n        @future_safe\n        async def _do_fetch() -> dict:\n            await asyncio.sleep(0.1)  # Simulate network delay\n            print(f'Fetching from {ctx.base_url} with key {ctx.api_key}')\n\n            # Simulate API response\n            if user_id > 0:\n                return {'id': user_id, 'name': f'User{user_id}'}\n            raise ValueError('Invalid user ID')\n\n        return _do_fetch()\n\n    return RequiresContextFutureResult(_fetch)\n\ndef async_fetch_posts(user_id: int) -> RequiresContextFutureResult[list, str, AsyncAPIContext]:\n    \"\"\"Fetch user posts asynchronously.\"\"\"\n    def _fetch(ctx: AsyncAPIContext) -> FutureResult[list, str]:\n        @future_safe\n        async def _do_fetch() -> list:\n            await asyncio.sleep(0.1)\n            print(f'Fetching posts for user {user_id}')\n            return [\n                {'id': 1, 'title': 'Post 1'},\n                {'id': 2, 'title': 'Post 2'}\n            ]\n\n        return _do_fetch()\n\n    return RequiresContextFutureResult(_fetch)\n\n# Chain async operations\ndef get_user_with_posts(user_id: int) -> RequiresContextFutureResult[dict, str, AsyncAPIContext]:\n    def _combine(user: dict) -> RequiresContextFutureResult[dict, str, AsyncAPIContext]:\n        return async_fetch_posts(user_id).map(\n            lambda posts: {**user, 'posts': posts}\n        )\n\n    return async_fetch_user(user_id).bind(_combine)\n\n# Usage\nasync def main():\n    api_ctx = AsyncAPIContext('https://api.example.com', 'secret-key')\n    future_result = get_user_with_posts(123)(api_ctx)\n    io_result = await future_result.awaitable()\n    result = io_result.unwrap()\n    print(result)\n\n# asyncio.run(main())\n```\n\n**Example 2: Parallel Async Operations with Context**\n```python\nfrom returns.context import RequiresContextFutureResult\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\nclass ServiceContext:\n    def __init__(self, timeout: int, max_concurrent: int):\n        self.timeout = timeout\n        self.max_concurrent = max_concurrent\n\ndef fetch_data_async(source: str) -> RequiresContextFutureResult[str, str, ServiceContext]:\n    \"\"\"Fetch data from source asynchronously.\"\"\"\n    def _fetch(ctx: ServiceContext) -> FutureResult[str, str]:\n        @future_safe\n        async def _do_fetch() -> str:\n            await asyncio.sleep(0.2)\n            print(f'Fetched from {source} with timeout {ctx.timeout}')\n            return f'Data from {source}'\n\n        return _do_fetch()\n\n    return RequiresContextFutureResult(_fetch)\n\nasync def fetch_all_data(sources: list[str], ctx: ServiceContext):\n    \"\"\"Fetch from multiple sources in parallel.\"\"\"\n    futures = [\n        fetch_data_async(source)(ctx).awaitable()\n        for source in sources[:ctx.max_concurrent]\n    ]\n\n    results = await asyncio.gather(*futures)\n    return [r.unwrap() for r in results]\n\n# Usage\nasync def main():\n    ctx = ServiceContext(timeout=30, max_concurrent=3)\n    sources = ['api1', 'api2', 'api3', 'api4']\n    results = await fetch_all_data(sources, ctx)\n    print(results)\n\n# asyncio.run(main())\n```\n\n**Example 3: Complex Async Pipeline with Context**\n```python\nfrom returns.context import RequiresContextFutureResult\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\nclass PipelineContext:\n    def __init__(self, stage1_url: str, stage2_url: str, cache_enabled: bool):\n        self.stage1_url = stage1_url\n        self.stage2_url = stage2_url\n        self.cache_enabled = cache_enabled\n\ndef stage1_process(data: str) -> RequiresContextFutureResult[dict, str, PipelineContext]:\n    \"\"\"First processing stage.\"\"\"\n    def _process(ctx: PipelineContext) -> FutureResult[dict, str]:\n        @future_safe\n        async def _do_process() -> dict:\n            await asyncio.sleep(0.1)\n            print(f'Stage 1 processing at {ctx.stage1_url}')\n            return {'processed': data, 'stage': 1}\n\n        return _do_process()\n\n    return RequiresContextFutureResult(_process)\n\ndef stage2_process(data: dict) -> RequiresContextFutureResult[dict, str, PipelineContext]:\n    \"\"\"Second processing stage.\"\"\"\n    def _process(ctx: PipelineContext) -> FutureResult[dict, str]:\n        @future_safe\n        async def _do_process() -> dict:\n            await asyncio.sleep(0.1)\n            print(f'Stage 2 processing at {ctx.stage2_url}')\n            return {**data, 'stage': 2, 'cached': ctx.cache_enabled}\n\n        return _do_process()\n\n    return RequiresContextFutureResult(_process)\n\ndef run_pipeline(input_data: str) -> RequiresContextFutureResult[dict, str, PipelineContext]:\n    \"\"\"Run complete processing pipeline.\"\"\"\n    return stage1_process(input_data).bind(stage2_process)\n\n# Usage\nasync def main():\n    ctx = PipelineContext(\n        stage1_url='https://stage1.example.com',\n        stage2_url='https://stage2.example.com',\n        cache_enabled=True\n    )\n\n    future_result = run_pipeline('test data')(ctx)\n    io_result = await future_result.awaitable()\n    result = io_result.unwrap()\n    print(result)\n    # {'processed': 'test data', 'stage': 2, 'cached': True}\n\n# asyncio.run(main())\n```\n\n### Complex Context Patterns\n\n**Example 1: Multi-Environment Context**\n```python\nfrom returns.context import RequiresContextResult\nfrom returns.result import Success, Failure, Result\nfrom dataclasses import dataclass\nfrom typing import Literal\n\n@dataclass\nclass EnvironmentConfig:\n    env: Literal['dev', 'staging', 'prod']\n    db_url: str\n    api_url: str\n    debug: bool\n\ndef get_feature_flag(feature: str) -> RequiresContextResult[bool, str, EnvironmentConfig]:\n    \"\"\"Get feature flag based on environment.\"\"\"\n    def _get_flag(ctx: EnvironmentConfig) -> Result[bool, str]:\n        # Different features enabled per environment\n        if ctx.env == 'dev':\n            return Success(True)  # All features in dev\n        elif ctx.env == 'staging':\n            return Success(feature in ['feature_a', 'feature_b'])\n        else:  # prod\n            return Success(feature == 'feature_a')\n\n    return RequiresContextResult(_get_flag)\n\ndef execute_if_enabled(\n    feature: str,\n    action: str\n) -> RequiresContextResult[str, str, EnvironmentConfig]:\n    \"\"\"Execute action only if feature is enabled.\"\"\"\n    def _execute_with_flag(enabled: bool) -> RequiresContextResult[str, str, EnvironmentConfig]:\n        if enabled:\n            return RequiresContextResult(lambda ctx: Success(f'Executed {action} in {ctx.env}'))\n        return RequiresContextResult(lambda ctx: Failure(f'Feature {feature} disabled'))\n\n    return get_feature_flag(feature).bind(_execute_with_flag)\n\n# Use with different environments\ndev_config = EnvironmentConfig('dev', 'postgres://localhost/dev', 'http://localhost:8000', True)\nprod_config = EnvironmentConfig('prod', 'postgres://prod/db', 'https://api.example.com', False)\n\ndev_result = execute_if_enabled('feature_x', 'process_data')(dev_config)\n# Success('Executed process_data in dev')\n\nprod_result = execute_if_enabled('feature_x', 'process_data')(prod_config)\n# Failure('Feature feature_x disabled')\n```\n\n**Example 2: Hierarchical Context**\n```python\nfrom returns.context import RequiresContext\nfrom dataclasses import dataclass\n\n@dataclass\nclass DatabaseConfig:\n    host: str\n    port: int\n    database: str\n\n@dataclass\nclass CacheConfig:\n    host: str\n    ttl: int\n\n@dataclass\nclass ApplicationConfig:\n    db: DatabaseConfig\n    cache: CacheConfig\n    app_name: str\n\ndef get_db_url() -> RequiresContext[str, ApplicationConfig]:\n    \"\"\"Extract database URL from nested config.\"\"\"\n    return RequiresContext.ask().map(\n        lambda config: f'postgresql://{config.db.host}:{config.db.port}/{config.db.database}'\n    )\n\ndef get_cache_url() -> RequiresContext[str, ApplicationConfig]:\n    \"\"\"Extract cache URL from nested config.\"\"\"\n    return RequiresContext.ask().map(\n        lambda config: f'redis://{config.cache.host}'\n    )\n\ndef get_full_config() -> RequiresContext[dict, ApplicationConfig]:\n    \"\"\"Build complete config dictionary.\"\"\"\n    def _build_with_db(db_url: str) -> RequiresContext[dict, ApplicationConfig]:\n        return get_cache_url().map(\n            lambda cache_url: RequiresContext.ask().map(\n                lambda config: {\n                    'app_name': config.app_name,\n                    'database': db_url,\n                    'cache': cache_url,\n                    'cache_ttl': config.cache.ttl\n                }\n            )\n        ).bind(lambda x: x)\n\n    return get_db_url().bind(_build_with_db)\n\n# Usage\napp_config = ApplicationConfig(\n    db=DatabaseConfig('localhost', 5432, 'myapp'),\n    cache=CacheConfig('localhost', 3600),\n    app_name='MyApp'\n)\n\nconfig_dict = get_full_config()(app_config)\n# {\n#     'app_name': 'MyApp',\n#     'database': 'postgresql://localhost:5432/myapp',\n#     'cache': 'redis://localhost',\n#     'cache_ttl': 3600\n# }\n```\n\n**Example 3: Context Transformation**\n```python\nfrom returns.context import RequiresContext\nfrom dataclasses import dataclass\n\n@dataclass\nclass UserContext:\n    user_id: int\n    roles: list[str]\n\n@dataclass\nclass RequestContext:\n    user: UserContext\n    request_id: str\n    ip_address: str\n\ndef has_role(role: str) -> RequiresContext[bool, RequestContext]:\n    \"\"\"Check if user has specific role.\"\"\"\n    return RequiresContext.ask().map(\n        lambda ctx: role in ctx.user.roles\n    )\n\ndef is_admin() -> RequiresContext[bool, RequestContext]:\n    \"\"\"Check if user is admin.\"\"\"\n    return has_role('admin')\n\ndef get_user_id() -> RequiresContext[int, RequestContext]:\n    \"\"\"Extract user ID from request context.\"\"\"\n    return RequiresContext.ask().map(lambda ctx: ctx.user.user_id)\n\ndef log_request(message: str) -> RequiresContext[str, RequestContext]:\n    \"\"\"Create log message with request context.\"\"\"\n    return RequiresContext.ask().map(\n        lambda ctx: f'[{ctx.request_id}] [{ctx.ip_address}] User {ctx.user.user_id}: {message}'\n    )\n\n# Modify context for sub-operations\ndef with_user_context(\n    operation: RequiresContext[str, UserContext]\n) -> RequiresContext[str, RequestContext]:\n    \"\"\"Transform operation requiring UserContext to work with RequestContext.\"\"\"\n    return RequiresContext(\n        lambda request_ctx: operation(request_ctx.user)\n    )\n\n# Usage\nrequest_ctx = RequestContext(\n    user=UserContext(user_id=123, roles=['admin', 'user']),\n    request_id='req-456',\n    ip_address='192.168.1.1'\n)\n\nadmin_check = is_admin()(request_ctx)  # True\nlog_msg = log_request('Accessed resource')(request_ctx)\n# '[req-456] [192.168.1.1] User 123: Accessed resource'\n```\n\n---\n\n## Converters\n\nThe converters module provides functions to transform between different container types.\n\n### result_to_maybe()\n\nConverts a `Result` container to a `Maybe` container, discarding error information.\n\n**Example 1: Basic Conversion**\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Success, Failure\nfrom returns.maybe import Some, Nothing\n\nsuccess = Success(42)\nfailure = Failure('error')\n\nmaybe_success = result_to_maybe(success)  # Some(42)\nmaybe_failure = result_to_maybe(failure)  # Nothing\n\nprint(maybe_success)  # <Some: 42>\nprint(maybe_failure)  # <Nothing>\n```\n\n**Example 2: Pipeline Integration**\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import safe\nfrom returns.maybe import Maybe\n\n@safe\ndef divide(a: int, b: int) -> float:\n    return a / b\n\ndef safe_divide_maybe(a: int, b: int) -> Maybe[float]:\n    \"\"\"Divide and convert to Maybe, ignoring error details.\"\"\"\n    return result_to_maybe(divide(a, b))\n\nresult1 = safe_divide_maybe(10, 2)  # Some(5.0)\nresult2 = safe_divide_maybe(10, 0)  # Nothing\n\n# Use with Maybe operations\nresult3 = safe_divide_maybe(20, 4).map(lambda x: x * 2).value_or(0)\n# 10.0\n```\n\n**Example 3: Optional Value Extraction**\n```python\nfrom returns.converters import result_to_maybe\nfrom returns.result import Result, Success, Failure\nfrom returns.maybe import Maybe\n\ndef find_user(user_id: int) -> Result[dict, str]:\n    \"\"\"Find user by ID.\"\"\"\n    users = {1: {'name': 'Alice'}, 2: {'name': 'Bob'}}\n    if user_id in users:\n        return Success(users[user_id])\n    return Failure(f'User {user_id} not found')\n\ndef get_user_optional(user_id: int) -> Maybe[dict]:\n    \"\"\"Get user as Maybe, discarding error message.\"\"\"\n    return result_to_maybe(find_user(user_id))\n\n# Process without caring about error details\nuser = get_user_optional(1).map(lambda u: u['name']).value_or('Unknown')\n# 'Alice'\n\nmissing_user = get_user_optional(999).map(lambda u: u['name']).value_or('Unknown')\n# 'Unknown'\n```\n\n### maybe_to_result()\n\nConverts a `Maybe` container to a `Result`, optionally specifying the error value for `Nothing`.\n\n**Example 1: Basic Conversion**\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.maybe import Some, Nothing\nfrom returns.result import Success, Failure\n\nsome_value = Some(42)\nnothing_value = Nothing\n\n# Convert without custom error\nresult1 = maybe_to_result(some_value)  # Success(42)\nresult2 = maybe_to_result(nothing_value)  # Failure(None)\n\n# Convert with custom error\nresult3 = maybe_to_result(nothing_value, default_error='No value found')\n# Failure('No value found')\n\nprint(result1)  # <Success: 42>\nprint(result2)  # <Failure: None>\nprint(result3)  # <Failure: No value found>\n```\n\n**Example 2: Adding Error Context**\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.maybe import Maybe\n\ndef parse_optional_config(key: str) -> Maybe[str]:\n    \"\"\"Get optional configuration value.\"\"\"\n    config = {'api_key': 'secret', 'timeout': '30'}\n    return Maybe.from_optional(config.get(key))\n\ndef require_config(key: str) -> Result[str, str]:\n    \"\"\"Convert optional config to required, with error message.\"\"\"\n    return maybe_to_result(\n        parse_optional_config(key),\n        default_error=f'Required configuration {key} is missing'\n    )\n\napi_key = require_config('api_key')  # Success('secret')\nmissing = require_config('database_url')\n# Failure('Required configuration database_url is missing')\n```\n\n**Example 3: Validation Pipeline**\n```python\nfrom returns.converters import maybe_to_result\nfrom returns.maybe import Maybe, Some, Nothing\nfrom returns.result import Result\n\ndef find_in_list(items: list, predicate) -> Maybe[any]:\n    \"\"\"Find first item matching predicate.\"\"\"\n    for item in items:\n        if predicate(item):\n            return Some(item)\n    return Nothing\n\ndef require_item(\n    items: list,\n    predicate,\n    error_message: str\n) -> Result[any, str]:\n    \"\"\"Require an item to exist in list.\"\"\"\n    return maybe_to_result(\n        find_in_list(items, predicate),\n        default_error=error_message\n    )\n\nusers = [\n    {'id': 1, 'name': 'Alice', 'active': True},\n    {'id': 2, 'name': 'Bob', 'active': False},\n]\n\n# Find active user\nactive_user = require_item(\n    users,\n    lambda u: u['active'],\n    'No active user found'\n)\n# Success({'id': 1, 'name': 'Alice', 'active': True})\n\n# Find admin user (doesn't exist)\nadmin_user = require_item(\n    users,\n    lambda u: u.get('role') == 'admin',\n    'No admin user found'\n)\n# Failure('No admin user found')\n```\n\n### flatten()\n\nFlattens nested containers of the same type.\n\n**Example 1: Flatten Nested Results**\n```python\nfrom returns.converters import flatten\nfrom returns.result import Success, Failure\n\n# Nested Success\nnested_success = Success(Success(42))\nflat_success = flatten(nested_success)  # Success(42)\n\n# Success containing Failure\nsuccess_with_failure = Success(Failure('error'))\nflat_failure = flatten(success_with_failure)  # Failure('error')\n\n# Failure containing Success\nfailure_with_success = Failure(Success(42))\nstill_failure = flatten(failure_with_success)  # Failure(Success(42))\n\nprint(flat_success)   # <Success: 42>\nprint(flat_failure)   # <Failure: error>\n```\n\n**Example 2: Flatten Nested Maybe**\n```python\nfrom returns.converters import flatten\nfrom returns.maybe import Some, Nothing\n\n# Nested Some\nnested_some = Some(Some(100))\nflat_some = flatten(nested_some)  # Some(100)\n\n# Some containing Nothing\nsome_nothing = Some(Nothing)\nflat_nothing = flatten(some_nothing)  # Nothing\n\nprint(flat_some)      # <Some: 100>\nprint(flat_nothing)   # <Nothing>\n```\n\n**Example 3: Flatten IO Containers**\n```python\nfrom returns.converters import flatten\nfrom returns.io import IO\n\n# Nested IO\ndef get_value() -> int:\n    return 42\n\nnested_io = IO(IO(get_value()))\nflat_io = flatten(nested_io)\n\n# Both execute to same value\nprint(flat_io.unwrap())  # Prints value\n```\n\n### Advanced Conversions\n\n**Example 1: Chaining Conversions**\n```python\nfrom returns.converters import result_to_maybe, maybe_to_result\nfrom returns.result import Success, Failure\nfrom returns.maybe import Maybe\n\n# Round-trip conversion\noriginal = Success(42)\nas_maybe = result_to_maybe(original)  # Some(42)\nback_to_result = maybe_to_result(as_maybe)  # Success(42)\n\n# Information loss with Failure\noriginal_failure = Failure('detailed error')\nas_maybe_fail = result_to_maybe(original_failure)  # Nothing\nback_to_result_fail = maybe_to_result(as_maybe_fail)  # Failure(None) - lost error detail!\n\n# Preserve error information with custom error\nback_with_error = maybe_to_result(as_maybe_fail, default_error='Operation failed')\n# Failure('Operation failed')\n```\n\n**Example 2: Complex Pipeline with Conversions**\n```python\nfrom returns.converters import result_to_maybe, maybe_to_result\nfrom returns.result import safe, Success\nfrom returns.maybe import Maybe\n\n@safe\ndef parse_int(s: str) -> int:\n    return int(s)\n\ndef process_optional_number(s: str | None) -> Maybe[int]:\n    \"\"\"Process an optional string as number.\"\"\"\n    if s is None:\n        return Maybe.empty\n\n    # Convert Result to Maybe\n    return result_to_maybe(parse_int(s))\n\ndef require_positive_number(maybe_num: Maybe[int]) -> Result[int, str]:\n    \"\"\"Require number to be positive.\"\"\"\n    result = maybe_to_result(maybe_num, default_error='No number provided')\n\n    return result.bind(lambda n:\n        Success(n) if n > 0 else Failure(f'{n} is not positive')\n    )\n\n# Use the pipeline\nresult1 = require_positive_number(process_optional_number('42'))\n# Success(42)\n\nresult2 = require_positive_number(process_optional_number('-5'))\n# Failure('-5 is not positive')\n\nresult3 = require_positive_number(process_optional_number(None))\n# Failure('No number provided')\n\nresult4 = require_positive_number(process_optional_number('abc'))\n# Failure('No number provided')\n```\n\n**Example 3: Converting IO Containers**\n```python\nfrom returns.converters import flatten\nfrom returns.io import IO, IOResult, impure, impure_safe\nfrom returns.result import Success\n\n@impure\ndef get_config() -> dict:\n    return {'timeout': 30}\n\n@impure_safe\ndef load_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\n# Convert IO[Result] to IOResult using flatten conceptually\ndef safe_get_config() -> IOResult[dict, Exception]:\n    return IOResult.from_io(get_config())\n\n# Flatten nested IO operations\n@impure\ndef nested_operation() -> IO[int]:\n    return IO(42)\n\nnested = IO(nested_operation())\nflat = flatten(nested)\n# Now flat is IO[int] instead of IO[IO[int]]\n```\n\n---\n\n## Helper Functions (Pointfree)\n\nThe pointfree module provides functions that enable functional composition by reversing the typical method call order.\n\n### map_() Function\n\nLifts regular functions to work with containers, transforming `a -> b` into `Container[a] -> Container[b]`.\n\n**Example 1: Basic Mapping**\n```python\nfrom returns.pointfree import map_\nfrom returns.result import Success, Failure\nfrom returns.maybe import Some, Nothing\n\ndef double(x: int) -> int:\n    return x * 2\n\n# Create a pointfree version\ndouble_in_container = map_(double)\n\n# Apply to different containers\nresult1 = double_in_container(Success(5))   # Success(10)\nresult2 = double_in_container(Failure('e')) # Failure('e')\nmaybe1 = double_in_container(Some(3))       # Some(6)\nmaybe2 = double_in_container(Nothing)       # Nothing\n\nprint(result1)  # <Success: 10>\nprint(maybe1)   # <Some: 6>\n```\n\n**Example 2: Pipeline Composition**\n```python\nfrom returns.pointfree import map_\nfrom returns.result import Success\nfrom returns.pipeline import flow\n\ndef add_one(x: int) -> int:\n    return x + 1\n\ndef to_string(x: int) -> str:\n    return str(x)\n\ndef add_prefix(s: str) -> str:\n    return f'Value: {s}'\n\n# Compose pointfree operations\ntransform = flow(\n    Success(5),\n    map_(add_one),      # Success(6)\n    map_(to_string),    # Success('6')\n    map_(add_prefix),   # Success('Value: 6')\n)\n\nprint(transform)  # <Success: Value: 6>\n```\n\n**Example 3: Reusable Transformations**\n```python\nfrom returns.pointfree import map_\nfrom returns.result import Result, Success, Failure\n\n# Create reusable transformations\nto_upper = map_(str.upper)\nstrip = map_(str.strip)\nlength = map_(len)\n\ndef process_string(result: Result[str, str]) -> Result[int, str]:\n    \"\"\"Chain multiple map operations.\"\"\"\n    return length(to_upper(strip(result)))\n\ninput1 = Success('  hello  ')\noutput1 = process_string(input1)  # Success(5)\n\ninput2 = Failure('error')\noutput2 = process_string(input2)  # Failure('error')\n\nprint(output1)  # <Success: 5>\n```\n\n### bind() Function\n\nHandles functions returning containers, converting `a -> Container[b]` to `Container[a] -> Container[b]`.\n\n**Example 1: Basic Binding**\n```python\nfrom returns.pointfree import bind\nfrom returns.result import Result, Success, Failure\n\ndef safe_divide(x: int) -> Result[float, str]:\n    if x == 0:\n        return Failure('Division by zero')\n    return Success(1.0 / x)\n\n# Create pointfree version\ndivide_in_container = bind(safe_divide)\n\n# Apply to containers\nresult1 = divide_in_container(Success(2))   # Success(0.5)\nresult2 = divide_in_container(Success(0))   # Failure('Division by zero')\nresult3 = divide_in_container(Failure('e')) # Failure('e')\n\nprint(result1)  # <Success: 0.5>\nprint(result2)  # <Failure: Division by zero>\n```\n\n**Example 2: Chaining Operations**\n```python\nfrom returns.pointfree import bind\nfrom returns.result import Result, Success, Failure\nfrom returns.pipeline import flow\n\ndef parse_int(s: str) -> Result[int, str]:\n    try:\n        return Success(int(s))\n    except ValueError:\n        return Failure(f'Cannot parse: {s}')\n\ndef validate_positive(n: int) -> Result[int, str]:\n    if n > 0:\n        return Success(n)\n    return Failure(f'Not positive: {n}')\n\ndef calculate_square(n: int) -> Result[int, str]:\n    return Success(n * n)\n\n# Create pipeline\nprocess = lambda input: flow(\n    input,\n    bind(parse_int),\n    bind(validate_positive),\n    bind(calculate_square),\n)\n\nresult1 = process(Success('5'))    # Success(25)\nresult2 = process(Success('-3'))   # Failure('Not positive: -3')\nresult3 = process(Success('abc'))  # Failure('Cannot parse: abc')\n\nprint(result1)  # <Success: 25>\n```\n\n**Example 3: Complex Bind Chains**\n```python\nfrom returns.pointfree import bind, map_\nfrom returns.result import Result, Success, Failure\n\ndef fetch_user(user_id: int) -> Result[dict, str]:\n    users = {1: {'name': 'Alice', 'email': 'alice@example.com'}}\n    if user_id in users:\n        return Success(users[user_id])\n    return Failure(f'User {user_id} not found')\n\ndef fetch_preferences(user: dict) -> Result[dict, str]:\n    email = user.get('email')\n    prefs = {'alice@example.com': {'theme': 'dark'}}\n    if email in prefs:\n        return Success(prefs[email])\n    return Failure(f'No preferences for {email}')\n\ndef get_theme(prefs: dict) -> Result[str, str]:\n    if 'theme' in prefs:\n        return Success(prefs['theme'])\n    return Failure('No theme set')\n\n# Compose with pointfree\nget_user_theme = lambda user_id: flow(\n    Success(user_id),\n    bind(fetch_user),\n    bind(fetch_preferences),\n    bind(get_theme),\n)\n\nresult = get_user_theme(1)  # Success('dark')\nprint(result)\n```\n\n### alt() Function\n\nOperates on error states, transforming `a -> b` into `Container[_, a] -> Container[_, b]`.\n\n**Example 1: Basic Error Transformation**\n```python\nfrom returns.pointfree import alt\nfrom returns.result import Success, Failure\n\ndef make_error_friendly(error: str) -> str:\n    return f'Oops! {error}'\n\n# Create pointfree version\nfriendly_errors = alt(make_error_friendly)\n\n# Apply to containers\nresult1 = friendly_errors(Success(42))          # Success(42) - unchanged\nresult2 = friendly_errors(Failure('db error'))  # Failure('Oops! db error')\n\nprint(result1)  # <Success: 42>\nprint(result2)  # <Failure: Oops! db error>\n```\n\n**Example 2: Error Message Enhancement**\n```python\nfrom returns.pointfree import alt\nfrom returns.result import Result, Success, Failure\n\ndef add_context(error: str) -> str:\n    return f'[USER_SERVICE] {error}'\n\ndef to_upper_error(error: str) -> str:\n    return error.upper()\n\n# Chain error transformations\nenhance_errors = lambda result: flow(\n    result,\n    alt(add_context),\n    alt(to_upper_error),\n)\n\nfrom returns.pipeline import flow\n\nresult1 = enhance_errors(Failure('connection failed'))\n# Failure('[USER_SERVICE] CONNECTION FAILED')\n\nresult2 = enhance_errors(Success(100))\n# Success(100) - unchanged\n```\n\n**Example 3: Converting Error Types**\n```python\nfrom returns.pointfree import alt\nfrom returns.result import Result, Failure, Success\n\nclass APIError:\n    def __init__(self, message: str, code: int):\n        self.message = message\n        self.code = code\n\n    def __str__(self):\n        return f'APIError({self.code}): {self.message}'\n\ndef exception_to_api_error(e: Exception) -> APIError:\n    return APIError(str(e), 500)\n\n# Create converter\nconvert_errors = alt(exception_to_api_error)\n\n# Apply\nresult1 = convert_errors(Failure(ValueError('Invalid input')))\n# Failure(APIError(500): Invalid input)\n\nresult2 = convert_errors(Success({'data': 'value'}))\n# Success({'data': 'value'})\n```\n\n### lash() Function\n\nLike bind but for failed containers, enabling recovery operations.\n\n**Example 1: Basic Error Recovery**\n```python\nfrom returns.pointfree import lash\nfrom returns.result import Result, Success, Failure\n\ndef fallback_value(error: str) -> Result[int, str]:\n    print(f'Recovering from error: {error}')\n    return Success(0)\n\n# Create pointfree version\nwith_fallback = lash(fallback_value)\n\n# Apply to containers\nresult1 = with_fallback(Success(42))          # Success(42) - unchanged\nresult2 = with_fallback(Failure('db error'))  # Success(0) - recovered\n# Prints: Recovering from error: db error\n\nprint(result1)  # <Success: 42>\nprint(result2)  # <Success: 0>\n```\n\n**Example 2: Cascading Fallbacks**\n```python\nfrom returns.pointfree import lash\nfrom returns.result import Result, Success, Failure\nfrom returns.pipeline import flow\n\ndef try_cache(error: str) -> Result[str, str]:\n    print('Trying cache...')\n    return Failure('Cache miss')\n\ndef try_database(error: str) -> Result[str, str]:\n    print('Trying database...')\n    return Success('Data from database')\n\ndef try_default(error: str) -> Result[str, str]:\n    print('Using default...')\n    return Success('Default data')\n\n# Create cascading fallback\nfetch_with_fallbacks = lambda: flow(\n    Failure('Initial failure'),\n    lash(try_cache),\n    lash(try_database),\n    lash(try_default),\n)\n\nresult = fetch_with_fallbacks()\n# Prints:\n# Trying cache...\n# Trying database...\n# Result: Success('Data from database')\n```\n\n**Example 3: Conditional Recovery**\n```python\nfrom returns.pointfree import lash\nfrom returns.result import Result, Success, Failure\n\nclass NetworkError(Exception):\n    pass\n\nclass ValidationError(Exception):\n    pass\n\ndef recover_network_error(error: Exception) -> Result[dict, Exception]:\n    if isinstance(error, NetworkError):\n        print('Network error detected, using cached data')\n        return Success({'cached': True, 'data': []})\n    return Failure(error)  # Don't recover from other errors\n\n# Create recovery function\nwith_network_recovery = lash(recover_network_error)\n\n# Apply\nresult1 = with_network_recovery(Failure(NetworkError('Timeout')))\n# Success({'cached': True, 'data': []})\n\nresult2 = with_network_recovery(Failure(ValidationError('Invalid input')))\n# Failure(ValidationError('Invalid input'))\n\nresult3 = with_network_recovery(Success({'data': [1, 2, 3]}))\n# Success({'data': [1, 2, 3]})\n```\n\n### apply() Function\n\nEnables using container-wrapped functions as callables.\n\n**Example 1: Basic Apply**\n```python\nfrom returns.pointfree import apply\nfrom returns.result import Success, Failure\n\n# Container with function\ndef add_ten(x: int) -> int:\n    return x + 10\n\nfunc_container = Success(add_ten)\nvalue_container = Success(5)\n\n# Apply the wrapped function\nresult = apply(func_container)(value_container)  # Success(15)\n\nprint(result)  # <Success: 15>\n```\n\n**Example 2: Partial Application Pattern**\n```python\nfrom returns.pointfree import apply\nfrom returns.result import Success, Failure\n\ndef multiply(x: int) -> callable:\n    def _multiply(y: int) -> int:\n        return x * y\n    return _multiply\n\n# Create partially applied function in container\ndouble = Success(multiply(2))\ntriple = Success(multiply(3))\n\n# Apply to values\nresult1 = apply(double)(Success(5))   # Success(10)\nresult2 = apply(triple)(Success(5))   # Success(15)\n\n# Failure propagates\nresult3 = apply(Failure('e'))(Success(5))   # Failure('e')\nresult4 = apply(double)(Failure('e'))       # Failure('e')\n```\n\n**Example 3: Function Composition in Containers**\n```python\nfrom returns.pointfree import apply\nfrom returns.result import Success, Result\n\ndef compose_functions(f, g):\n    \"\"\"Compose two functions.\"\"\"\n    def _composed(x):\n        return f(g(x))\n    return _composed\n\n# Functions in containers\nadd_one = Success(lambda x: x + 1)\ndouble = Success(lambda x: x * 2)\n\n# Compose them\ncomposed = Success(compose_functions).apply(add_one).apply(double)\n\n# Wait, apply doesn't work this way. Let me fix:\n# apply is used differently\n\n# Correct usage with apply\nfunc_in_container = Success(lambda x: x * 2)\nvalue_in_container = Success(21)\n\nresult = apply(func_in_container)(value_in_container)  # Success(42)\nprint(result)\n```\n\n### Specialized Binds\n\n**Example 1: bind_result for Result Types**\n```python\nfrom returns.pointfree import bind_result\nfrom returns.io import IOResult, impure_safe\n\n@impure_safe\ndef read_file(path: str) -> str:\n    with open(path, 'r') as f:\n        return f.read()\n\ndef parse_json(content: str) -> Result[dict, Exception]:\n    import json\n    try:\n        return Success(json.loads(content))\n    except json.JSONDecodeError as e:\n        return Failure(e)\n\n# bind_result works with IOResult\nprocess_file = lambda path: bind_result(parse_json)(read_file(path))\n\n# result = process_file('config.json')\n# IOResult[dict, Exception]\n```\n\n**Example 2: bind_io for IO Types**\n```python\nfrom returns.pointfree import bind_io\nfrom returns.io import IO, impure\n\n@impure\ndef get_timestamp() -> float:\n    import time\n    return time.time()\n\n@impure\ndef format_timestamp(ts: float) -> str:\n    import datetime\n    return datetime.datetime.fromtimestamp(ts).isoformat()\n\n# Compose IO operations\nformatted_time = bind_io(format_timestamp)(get_timestamp())\n\n# Execute\n# print(formatted_time.unwrap())\n```\n\n**Example 3: bind_async for Async Operations**\n```python\nfrom returns.pointfree import bind_async\nfrom returns.future import Future, future\nimport asyncio\n\n@future\nasync def fetch_user_id(email: str) -> int:\n    await asyncio.sleep(0.1)\n    return 123\n\n@future\nasync def fetch_user_data(user_id: int) -> dict:\n    await asyncio.sleep(0.1)\n    return {'id': user_id, 'name': 'Alice'}\n\n# Compose async operations\nget_user_by_email = lambda email: bind_async(fetch_user_data)(fetch_user_id(email))\n\n# Execute\nasync def main():\n    io_result = await get_user_by_email('alice@example.com').awaitable()\n    print(io_result.unwrap())\n\n# asyncio.run(main())\n```\n\n---\n\n## Primitive Types\n\nThe `returns` library provides several composite primitive types that combine multiple effects.\n\n### IOResult\n\nCombines IO effects with Result for impure operations that can fail.\n\n**Example 1: File Operations**\n```python\nfrom returns.io import IOResult, impure_safe\n\n@impure_safe\ndef read_config(path: str) -> dict:\n    import json\n    with open(path, 'r') as f:\n        return json.load(f)\n\n@impure_safe\ndef write_config(path: str, data: dict) -> None:\n    import json\n    with open(path, 'w') as f:\n        json.dump(data, f, indent=2)\n\n# These return IOResult[T, Exception]\nconfig_result = read_config('config.json')\n# IOSuccess({...}) or IOFailure(FileNotFoundError(...))\n\nwrite_result = write_config('config.json', {'key': 'value'})\n# IOSuccess(None) or IOFailure(PermissionError(...))\n\n# Execute and handle\nmatch config_result.unwrap():\n    case Success(data):\n        print(f'Config loaded: {data}')\n    case Failure(error):\n        print(f'Failed to load config: {error}')\n```\n\n**Example 2: Database Operations**\n```python\nfrom returns.io import IOResult, impure_safe\nfrom returns.result import Success, Failure\n\n@impure_safe\ndef query_database(sql: str) -> list[dict]:\n    # Simulated database query\n    if 'SELECT' in sql:\n        return [{'id': 1, 'name': 'Alice'}]\n    raise ValueError('Only SELECT queries allowed')\n\n@impure_safe\ndef insert_record(table: str, data: dict) -> int:\n    # Simulated insert\n    print(f'Inserting into {table}: {data}')\n    return 1  # Return ID\n\n# Compose database operations\ndef fetch_and_update_user(user_id: int) -> IOResult[int, Exception]:\n    return (\n        query_database(f'SELECT * FROM users WHERE id = {user_id}')\n        .map(lambda rows: rows[0] if rows else None)\n        .bind(lambda user: insert_record('audit_log', {'user_id': user['id']}))\n    )\n\n# result = fetch_and_update_user(1)\n```\n\n**Example 3: Network Requests**\n```python\nfrom returns.io import IOResult, impure_safe\nimport requests\n\n@impure_safe\ndef fetch_json(url: str) -> dict:\n    response = requests.get(url, timeout=10)\n    response.raise_for_status()\n    return response.json()\n\n@impure_safe\ndef post_json(url: str, data: dict) -> dict:\n    response = requests.post(url, json=data, timeout=10)\n    response.raise_for_status()\n    return response.json()\n\n# Compose HTTP operations\ndef fetch_and_post(get_url: str, post_url: str) -> IOResult[dict, Exception]:\n    return (\n        fetch_json(get_url)\n        .map(lambda data: {**data, 'processed': True})\n        .bind(lambda processed: post_json(post_url, processed))\n    )\n\n# response = fetch_and_post('https://api.example.com/data', 'https://api.example.com/submit')\n```\n\n### FutureResult\n\nCombines async operations with Result for async operations that can fail.\n\n**Example 1: Async API Calls**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\nimport aiohttp\n\n@future_safe\nasync def async_fetch_user(user_id: int) -> dict:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f'https://api.example.com/users/{user_id}') as response:\n            response.raise_for_status()\n            return await response.json()\n\n@future_safe\nasync def async_fetch_posts(user_id: int) -> list:\n    await asyncio.sleep(0.1)\n    # Simulate API call\n    return [{'id': 1, 'title': 'Post 1'}, {'id': 2, 'title': 'Post 2'}]\n\n# Compose async operations\ndef get_user_with_posts(user_id: int) -> FutureResult[dict, Exception]:\n    def _add_posts(user: dict) -> FutureResult[dict, Exception]:\n        return async_fetch_posts(user_id).map(\n            lambda posts: {**user, 'posts': posts}\n        )\n\n    return async_fetch_user(user_id).bind(_add_posts)\n\n# Execute\nasync def main():\n    io_result = await get_user_with_posts(1).awaitable()\n    match io_result.unwrap():\n        case Success(data):\n            print(f'User data: {data}')\n        case Failure(error):\n            print(f'Error: {error}')\n\n# asyncio.run(main())\n```\n\n**Example 2: Parallel Async Operations**\n```python\nfrom returns.future import FutureResult, future_safe\nimport asyncio\n\n@future_safe\nasync def fetch_weather() -> dict:\n    await asyncio.sleep(0.2)\n    return {'temp': 72, 'conditions': 'Sunny'}\n\n@future_safe\nasync def fetch_news() -> list:\n    await asyncio.sleep(0.15)\n    return ['News 1', 'News 2']\n\n@future_safe\nasync def fetch_stocks() -> dict:\n    await asyncio.sleep(0.1)\n    return {'AAPL': 150.25, 'GOOGL': 2800.50}\n\nasync def fetch_dashboard_data() -> dict:\n    # Launch all in parallel\n    weather_future = fetch_weather().awaitable()\n    news_future = fetch_news().awaitable()\n    stocks_future = fetch_stocks().awaitable()\n\n    # Wait for all\n    weather, news, stocks = await asyncio.gather(\n        weather_future,\n        news_future,\n        stocks_future\n    )\n\n    # Combine results\n    return {\n        'weather': weather.unwrap().unwrap(),\n        'news': news.unwrap().unwrap(),\n        'stocks': stocks.unwrap().unwrap()\n    }\n\n# async def main():\n#     dashboard = await fetch_dashboard_data()\n#     print(dashboard)\n```\n\n**Example 3: Retry Logic with FutureResult**\n```python\nfrom returns.future import FutureResult, future_safe\nfrom returns.result import Success, Failure\nimport asyncio\n\n@future_safe\nasync def unreliable_async_call() -> str:\n    await asyncio.sleep(0.1)\n    import random\n    if random.random() < 0.7:\n        raise Exception('Random failure')\n    return 'Success!'\n\nasync def retry_async(\n    operation: FutureResult,\n    max_retries: int = 3\n) -> IOResult[str, Exception]:\n    for attempt in range(max_retries):\n        result = await operation.awaitable()\n        inner = result.unwrap()\n\n        match inner:\n            case Success(value):\n                return result\n            case Failure(error):\n                if attempt < max_retries - 1:\n                    print(f'Attempt {attempt + 1} failed, retrying...')\n                    await asyncio.sleep(0.5)\n                else:\n                    print('All retries exhausted')\n                    return result\n\n# async def main():\n#     result = await retry_async(unreliable_async_call())\n#     print(result.unwrap())\n```\n\n### RequiresContextResult\n\n**Already covered in detail in [RequiresContext Deep Dive](#requirescontextresult)**\n\n### RequiresContextIOResult\n\n**Already covered in detail in [RequiresContext Deep Dive](#requirescontextioresult)**\n\n### RequiresContextFutureResult\n\n**Already covered in detail in [RequiresContext Deep Dive](#requirescontextfutureresult)**\n\n---\n\n## Conclusion\n\nThis guide covered advanced features of the `returns` library:\n\n- **Methods Module**: Utilities like `cond()`, `partition()`, and `is_successful()`\n- **RequiresContext**: Comprehensive dependency injection patterns\n- **Converters**: Transforming between container types\n- **Pointfree Helpers**: Functional composition tools\n- **Primitive Types**: Composite types combining multiple effects\n\n**Key Takeaways:**\n\n1. Use `methods.cond()` for functional conditionals\n2. Use `partition()` to separate successful and failed results\n3. RequiresContext variants enable typed dependency injection\n4. Converters allow flexible transformation between types\n5. Pointfree style enables cleaner function composition\n6. Primitive types like IOResult and FutureResult combine effects safely\n\n**Next Steps:**\n- Explore the [official documentation](https://returns.readthedocs.io/)\n- Review Part 1 for core types and containers\n- Practice combining these patterns in real applications\n\n**Resources:**\n- [Official Documentation](https://returns.readthedocs.io/)\n- [GitHub Repository](https://github.com/dry-python/returns)\n- [Railway-Oriented Programming](https://fsharpforfunandprofit.com/rop/)\n","structuredPatch":[],"originalFile":null},"sourceToolAssistantUUID":"6c939be0-3fa0-433c-8f2e-1bed7529a3b5"}
{"parentUuid":"123599a4-894d-43ec-8560-ce05c540dd8a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016LT22PhZxj6gP7cZmveBLX","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Perfect! I've created both comprehensive markdown documents. Let me verify they were created successfully and provide a summary to the user.","signature":"ErUCCkYICxgCKkAhaXzkzwn6DjoDUvvYa1zetLxD+lvB96IehJGKANEvv9BOPAlRKEjGPEiyLYd5A7J754kZLOToNlojOUVvcuL7EgxdPBPXoTKwIsRpd3YaDJKazsQy9zzuYOJWXiIwiL368pbF8vGtRdITPVDJIr/1pylbH55soaYUCkj0UdPACI/TBoeaT2Y76UwtMYY/KpwBTzS7wK/Xl8zCTO0xJe5frAx0tye1chJhEixXqEovgfj1iTsefs6PPp9OEYVGb4z7x7erUIlXhD+9XyLMaFVnj7QKFBzsKmhI9xgBTt6R1K88WFJckVtlibI8C67++6GLKqqd/woTrVUidcE1xt4+pM3kg5NnnPU9uYId3+ncwb5hquh5WfZDE2RIiqAIheNRWuKj3rNUpa6NE0oqGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":19345,"cache_read_input_tokens":48617,"cache_creation":{"ephemeral_5m_input_tokens":19345,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMSFz4TuL8evo5yQzw1b","type":"assistant","uuid":"5c427362-8ec3-4f05-bc27-90b8184e3efe","timestamp":"2026-01-22T00:02:52.897Z"}
{"parentUuid":"5c427362-8ec3-4f05-bc27-90b8184e3efe","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016LT22PhZxj6gP7cZmveBLX","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I've created two comprehensive markdown guides for the `returns` library with extensive code examples:\n\n## Documents Created:\n\n### **Document #1**: `returns-part1-core-types.md`\nCovers the fundamental types with multiple examples for each:\n\n- **Maybe Container** - 5 sections with 15+ examples\n- **Result Container** - 5 sections with 15+ examples  \n- **Safe Decorator** - 3 sections with 9 examples\n- **IO Container** - 4 sections with 12 examples\n- **Future Container** - 3 sections with 9 examples\n- **future_safe Decorator** - 2 sections with 9 examples\n- **Context Container** - 3 sections with 9 examples\n- **Pipelines** - 3 sections with 9+ examples\n\n### **Document #2**: `returns-part2-advanced-features.md`\nCovers advanced features with detailed examples:\n\n- **Methods Module** - 4 functions with 12 examples\n- **RequiresContext Deep Dive** - 5 sections with 15+ examples covering all variants\n- **Converters** - 4 sections with 12 examples\n- **Helper Functions (Pointfree)** - 6 sections with 18 examples\n- **Primitive Types** - Detailed coverage of IOResult, FutureResult, and all RequiresContext variants\n\n## Features of Both Documents:\n\n **Complete Table of Contents** with section links  \n **Multiple detailed examples** for each topic (3+ per section)  \n **Real-world use cases** - file operations, API calls, database queries, validation  \n **Progressive complexity** - from basic to advanced patterns  \n **Code comments and explanations**  \n **Pattern matching examples** (Python 3.10+)  \n **Composition and chaining patterns**  \n **Error handling strategies**  \n\nBoth documents are located at:\n- `/docs/python/references/returns-part1-core-types.md`\n- `/docs/python/references/returns-part2-advanced-features.md`\n\nThe guides provide a comprehensive introduction to the `returns` library with over **100 code examples** demonstrating functional programming patterns in Python!"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":19345,"cache_read_input_tokens":48617,"cache_creation":{"ephemeral_5m_input_tokens":19345,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMSFz4TuL8evo5yQzw1b","type":"assistant","uuid":"22bc812d-db34-4d88-be49-f868f1f04040","timestamp":"2026-01-22T00:02:58.888Z"}
{"parentUuid":"22bc812d-db34-4d88-be49-f868f1f04040","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"2b78fdd7-935a-4417-b776-05d6b84cd6f1","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"foamy-moseying-parrot","type":"system","subtype":"turn_duration","durationMs":354719,"timestamp":"2026-01-22T00:02:58.930Z","uuid":"a8527219-4334-438c-88d6-35eabce45dec","isMeta":false}
{"type":"summary","summary":"Returns library comprehensive documentation guide","leafUuid":"22bc812d-db34-4d88-be49-f868f1f04040"}
