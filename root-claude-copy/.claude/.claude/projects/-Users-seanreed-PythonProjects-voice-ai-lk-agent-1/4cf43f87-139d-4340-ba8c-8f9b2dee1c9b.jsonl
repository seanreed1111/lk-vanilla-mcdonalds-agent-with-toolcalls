{"type":"file-history-snapshot","messageId":"d6da4e92-e723-4b3e-9807-73571b5e0d36","snapshot":{"messageId":"d6da4e92-e723-4b3e-9807-73571b5e0d36","trackedFileBackups":{},"timestamp":"2026-01-21T22:59:27.295Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"please add to the plan to update the Item class in the following ways: 1  include a quantity field 2 include an item_id field. 3 ) define addition for items. two items item1 and item2 can be added if and only if the item1 name = item2 name and set(item1 modifiers) = set (item2 modfiers. order doesn't matter. if the item1 and item2 can be added, then can simply add the quantities together."},"uuid":"d6da4e92-e723-4b3e-9807-73571b5e0d36","timestamp":"2026-01-21T22:59:27.286Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"d6da4e92-e723-4b3e-9807-73571b5e0d36","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Te54BmXpeE6dcP795B57oE","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to update the plan file to include modifications to the Item class in the menu models. Let me first read the current plan file to see what's there, then add these new requirements.\n\nThe requirements are:\n1. Add a `quantity` field to the Item class\n2. Add an `item_id` field to the Item class\n3. Define addition for items - two items can be added if:\n   - item1.name == item2.name\n   - set(item1.modifiers) == set(item2.modifiers) (order doesn't matter)\n   - If they can be added, add their quantities together\n\nLet me read the plan file first to see the current structure and where to add this.","signature":"EosGCkYICxgCKkD4a/UNjy6ykqVuZV8fUAXw/8x+pxes3noUBxhMiJ1xzf5Br0TN8YELtbob4hXp8q5X1zAUbMCiRZ1YsQYj4nJAEgw49AITvRt3Dw19Pv8aDFdBDqIC8FqTIn42fCIwR8YIVxaQ0nsUyzSuk8iTqxKQwtxR9fzVYsrVTx/VgcrlUN0kst4db01x1SWeHZ7HKvIEFdqMR/ZdL122q9+bMJQ1wx87qzT1bisjrnGcOBGPEmbS8+LWw62+4I52HMHMYA4mQh4rw8d1KtgWSF9DkotO7l110PVC7nikVue1ImjGEpZcUnSGX1aQnSxSa406w1MKlfk+ex36hVTdZfkWuXRwVn851z2TiC0a/gzLSvQpzYVz0zeV8X+9+bXKiq2pe+znaAXQwFWVVKV8NMwd2Bg7lk83WlTLzXklU8U/Kux+sea9yLqNF5OQFv59T4NBd01vwR4rkg4SKHAH8T4lIVlmf+z66XqBtDH/wGTBjnoVndf044wgyxKM2LWEM2FoiVoWPjQCwDO3jKQfGyhkKx2UiZpGd92a2wwKB+fo7w1vrOOBFF1pcstA5o77RljFgYU3f6maeu+vLsPjA07Bf+25msTkqpX45hI4GvKC6jyvhhBpM6qFBOyQ0Qn9kXgijfXndyvuP9rWFSOcZW3Q3na6OR04LHN9sPWo7RMze35lX4nRhXWhFmUp9DWovkqnrAQYhHRWMeOgFuX15Foqav5f+kOfN3EfPjOU7ZDIOcOgXCt1LNdvwHgFtLCl0iwoT06tc7P+IXraKmHa9LRFONjSKK+v1XZ0LB+DBOqCrLJQRykkXhYwq3TJSKvqkjx0eIwFl7ehosXCzW4Q9jF/+WOFnCd2nU9S678/Jxzf/HV6sybeieCRpXkX6j52sgq77rprAp4ZrHqHgB3/cORdwt3VSHrcNyNz1zDkvQUYQhDDtETPJY1Mbeboka8zpcoHhqLQAl0uq/dvJ8SaCp+Horn0nXlmnki10JHj4KM3AW9DSL8cfP0JaqN2XgPXCOolv2A260IYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25821,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25821,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMMRbwtHKgX8BDL3DkNu","type":"assistant","uuid":"9f35723e-979c-4848-9c4b-af6ffb7aafb9","timestamp":"2026-01-21T22:59:30.216Z"}
{"parentUuid":"9f35723e-979c-4848-9c4b-af6ffb7aafb9","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Te54BmXpeE6dcP795B57oE","type":"message","role":"assistant","content":[{"type":"text","text":"I'll read the current plan file and then update it to include the Item class enhancements."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25821,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25821,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMMRbwtHKgX8BDL3DkNu","type":"assistant","uuid":"1b6bdd20-68bc-4fd6-a3a0-49dfc2f20ac2","timestamp":"2026-01-21T22:59:30.559Z"}
{"parentUuid":"1b6bdd20-68bc-4fd6-a3a0-49dfc2f20ac2","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Te54BmXpeE6dcP795B57oE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Jxz1tSXQEi6xEmR6ijQgGo","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25821,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25821,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMMRbwtHKgX8BDL3DkNu","type":"assistant","uuid":"b002d8d3-5d07-45b1-9593-533365a13cad","timestamp":"2026-01-21T22:59:31.708Z"}
{"parentUuid":"b002d8d3-5d07-45b1-9593-533365a13cad","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Jxz1tSXQEi6xEmR6ijQgGo","type":"tool_result","content":"     1→# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n     2→\n     3→**Created**: 2026-01-21\n     4→**Status**: Planning Phase\n     5→**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n     6→\n     7→---\n     8→\n     9→## Executive Summary\n    10→\n    11→This plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n    12→\n    13→---\n    14→\n    15→## 1. System Architecture\n    16→\n    17→### 1.1 Core Components\n    18→\n    19→```\n    20→Customer Voice Input\n    21→    ↓\n    22→[STT] → AssemblyAI Universal Streaming\n    23→    ↓\n    24→[Custom DriveThruLLM Wrapper]\n    25→    ├─ Menu Context Provider\n    26→    ├─ Order State Manager\n    27→    ├─ Validation Layer\n    28→    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    29→    ↓\n    30→[TTS] → Inworld/Cartesia\n    31→    ↓\n    32→Agent Response\n    33→```\n    34→\n    35→### 1.2 New Components to Build\n    36→\n    37→1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n    38→   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n    39→   - Wraps a base LLM with order-taking capabilities\n    40→   - Manages conversation state and order tracking\n    41→\n    42→2. **MenuProvider** (`src/menu_provider.py`)\n    43→   - Loads and manages menu data using existing Pydantic models\n    44→   - Provides relevant menu context to LLM\n    45→   - Implements fuzzy matching and search\n    46→\n    47→3. **OrderStateManager** (`src/order_state_manager.py`)\n    48→   - Tracks items ordered during conversation\n    49→   - Appends to incremental log file after each turn\n    50→   - Generates final JSON output with timestamp\n    51→\n    52→4. **MenuValidationTools** (`src/menu_validation.py`)\n    53→   - Validates LLM output against menu items\n    54→   - Fuzzy matching for spoken variations\n    55→   - Modifier validation\n    56→\n    57→5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n    58→   - Custom Agent subclass with drive-thru specific instructions\n    59→   - Configures the drive-thru persona\n    60→\n    61→---\n    62→\n    63→## 2. Accuracy-Boosting Strategies\n    64→\n    65→### Priority 1: Core Strategies (Implement First)\n    66→\n    67→#### Strategy 1: LLM Function Calling / Structured Output\n    68→**Approach**: Define tools/functions that the LLM can call to add items to the order.\n    69→\n    70→**Implementation**:\n    71→- Create `add_item_to_order` function with parameters:\n    72→  - `category` (enum from menu categories)\n    73→  - `item_name` (string)\n    74→  - `modifiers` (list of strings)\n    75→  - `quantity` (int, default 1)\n    76→- LLM must use this function instead of free-form text\n    77→- Validates parameters against menu before accepting\n    78→\n    79→**Pros**:\n    80→- Structured, parseable output\n    81→- Forces LLM to think in terms of menu structure\n    82→- Easy to validate\n    83→\n    84→**Cons**:\n    85→- Requires LLM with good function calling support\n    86→- May feel less natural for complex orders\n    87→\n    88→**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n    89→\n    90→---\n    91→\n    92→#### Strategy 2: Menu Context Injection\n    93→**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n    94→\n    95→**Implementation**:\n    96→- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n    97→- Fetch relevant menu items from Menu model\n    98→- Include in system prompt: \"Available items: [filtered list]\"\n    99→- Reduces hallucination by showing exact menu item names\n   100→\n   101→**Example**:\n   102→```\n   103→Customer: \"I'd like a Big Mac\"\n   104→→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n   105→```\n   106→\n   107→**Pros**:\n   108→- Reduces hallucination\n   109→- Helps with exact item name matching\n   110→- Context-aware\n   111→\n   112→**Cons**:\n   113→- Increases token usage\n   114→- May miss items if keyword matching fails\n   115→\n   116→**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n   117→\n   118→---\n   119→\n   120→#### Strategy 3: Explicit Confirmation Loop\n   121→**Approach**: After each item is understood, explicitly confirm with customer.\n   122→\n   123→**Implementation**:\n   124→- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n   125→- Customer can correct if wrong\n   126→- Only write to order file after confirmation\n   127→\n   128→**Example Flow**:\n   129→```\n   130→Customer: \"Big Mac please\"\n   131→Agent: \"One Big Mac - is that correct?\"\n   132→Customer: \"Yes\"\n   133→Agent: \"Great! Anything else?\"\n   134→[Write to order file]\n   135→```\n   136→\n   137→**Pros**:\n   138→- Allows error correction\n   139→- Builds customer confidence\n   140→- Simple to implement\n   141→\n   142→**Cons**:\n   143→- Slower ordering process\n   144→- May annoy customers with simple orders\n   145→\n   146→**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n   147→\n   148→---\n   149→\n   150→#### Strategy 4: Fuzzy String Matching\n   151→**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n   152→\n   153→**Implementation**:\n   154→- Use `rapidfuzz` or `fuzzywuzzy` library\n   155→- When LLM outputs an item name, fuzzy match against menu\n   156→- Accept if confidence > 85%\n   157→- Handle common variations:\n   158→  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n   159→  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n   160→\n   161→**Example**:\n   162→```python\n   163→from rapidfuzz import process, fuzz\n   164→\n   165→def find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n   166→    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n   167→    return result[0], result[1]  # item, confidence_score\n   168→```\n   169→\n   170→**Pros**:\n   171→- Handles STT errors\n   172→- Tolerates variations\n   173→- Fast and deterministic\n   174→\n   175→**Cons**:\n   176→- Can match wrong items if names are similar\n   177→- Requires confidence threshold tuning\n   178→\n   179→**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n   180→\n   181→---\n   182→\n   183→### Priority 2: Advanced Strategies (Implement Later for Optimization)\n   184→\n   185→#### Strategy 5: Semantic Search with Embeddings\n   186→**Approach**: Use embeddings to find semantically similar menu items.\n   187→\n   188→**Implementation**:\n   189→- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n   190→- Store in vector DB or in-memory\n   191→- When customer speaks, embed their utterance\n   192→- Find nearest neighbors in embedding space\n   193→- Use as candidates for LLM to choose from\n   194→\n   195→**Pros**:\n   196→- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n   197→- Semantic understanding\n   198→- Robust to paraphrasing\n   199→\n   200→**Cons**:\n   201→- More complex implementation\n   202→- Requires embedding API calls\n   203→- May introduce latency\n   204→\n   205→**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n   206→\n   207→---\n   208→\n   209→#### Strategy 6: Two-Stage Parsing\n   210→**Approach**: Separate intent extraction from menu item selection.\n   211→\n   212→**Implementation**:\n   213→1. **Stage 1**: Extract customer intent\n   214→   - \"I want a burger with cheese\"\n   215→   - Intent: {type: burger, modifiers: [cheese]}\n   216→2. **Stage 2**: Match intent to menu items\n   217→   - Search menu for burgers with cheese modifier\n   218→   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n   219→3. **Stage 3**: LLM selects best match or asks clarifying question\n   220→\n   221→**Pros**:\n   222→- Cleaner separation of concerns\n   223→- Can optimize each stage separately\n   224→- Better debuggability\n   225→\n   226→**Cons**:\n   227→- More complex\n   228→- Additional latency from multiple stages\n   229→\n   230→**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n   231→\n   232→---\n   233→\n   234→#### Strategy 7: Chain-of-Thought Prompting\n   235→**Approach**: Ask LLM to explain its reasoning before outputting.\n   236→\n   237→**Implementation**:\n   238→```\n   239→System: When a customer orders, think step-by-step:\n   240→1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n   241→2. Which specific item from our menu matches best?\n   242→3. Did they mention any modifiers?\n   243→4. What quantity?\n   244→Then output the structured order.\n   245→```\n   246→\n   247→**Pros**:\n   248→- Improves LLM reasoning\n   249→- More interpretable\n   250→- Can catch logic errors\n   251→\n   252→**Cons**:\n   253→- Increases token usage\n   254→- May add latency\n   255→- Reasoning not always visible to customer\n   256→\n   257→**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n   258→\n   259→---\n   260→\n   261→#### Strategy 8: Constrained Decoding\n   262→**Approach**: Use grammar-based constrained generation (if LLM supports it).\n   263→\n   264→**Implementation**:\n   265→- Define grammar for valid responses\n   266→- LLM can only output strings that match the grammar\n   267→- Grammar includes exact menu item names\n   268→\n   269→**Example Grammar**:\n   270→```\n   271→ORDER := <ITEM> | <ITEM> \"and\" <ORDER>\n   272→ITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\n   273→MENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n   274→```\n   275→\n   276→**Pros**:\n   277→- Guarantees valid output\n   278→- No hallucination possible\n   279→- Perfect accuracy for item names\n   280→\n   281→**Cons**:\n   282→- Very few LLMs support this\n   283→- Complex to implement\n   284→- May be too rigid\n   285→\n   286→**Accuracy Impact**: VERY HIGH (9/10) - If available\n   287→\n   288→---\n   289→\n   290→#### Strategy 9: Post-Processing Validation Layer\n   291→**Approach**: Validate every LLM output against menu before speaking to customer.\n   292→\n   293→**Implementation**:\n   294→```python\n   295→class OrderValidator:\n   296→    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n   297→        # Check item exists in menu\n   298→        # Check modifiers are valid for that item\n   299→        # Return corrected version or error\n   300→```\n   301→\n   302→**Pros**:\n   303→- Last line of defense\n   304→- Can auto-correct minor errors\n   305→- Prevents invalid orders\n   306→\n   307→**Cons**:\n   308→- Reactive, not proactive\n   309→- May reject valid variations\n   310→\n   311→**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n   312→\n   313→---\n   314→\n   315→#### Strategy 10: Context Window Optimization\n   316→**Approach**: Only include relevant portions of menu in context.\n   317→\n   318→**Implementation**:\n   319→- Detect if customer is ordering breakfast, lunch, drinks, etc.\n   320→- Only inject that category's items into prompt\n   321→- Reduces noise and token count\n   322→- Improves focus\n   323→\n   324→**Example**:\n   325→```\n   326→Customer: \"I want breakfast\"\n   327→→ Only include Breakfast category items in context\n   328→```\n   329→\n   330→**Pros**:\n   331→- Reduces token usage\n   332→- Reduces hallucination\n   333→- Faster inference\n   334→\n   335→**Cons**:\n   336→- May miss cross-category orders\n   337→- Requires intent detection\n   338→\n   339→**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n   340→\n   341→---\n   342→\n   343→### Recommended Strategy Combination\n   344→\n   345→**Phase 1 (MVP)**:\n   346→1. Function Calling (Strategy 1) - Core structure\n   347→2. Menu Context Injection (Strategy 2) - Grounding\n   348→3. Fuzzy String Matching (Strategy 4) - STT error handling\n   349→4. Post-Processing Validation (Strategy 9) - Safety net\n   350→\n   351→**Phase 2 (Optimization)**:\n   352→5. Explicit Confirmation Loop (Strategy 3) - User validation\n   353→6. Semantic Search (Strategy 5) - Better matching\n   354→\n   355→**Phase 3 (Advanced)**:\n   356→7. Two-Stage Parsing (Strategy 6) - If needed\n   357→8. Chain-of-Thought (Strategy 7) - If needed\n   358→\n   359→---\n   360→\n   361→## 3. Order State Management\n   362→\n   363→### 3.1 Order State Model\n   364→\n   365→```python\n   366→@dataclass\n   367→class OrderItem:\n   368→    item_name: str\n   369→    category: str\n   370→    modifiers: list[str]\n   371→    quantity: int\n   372→    timestamp: datetime\n   373→    confirmed: bool = False\n   374→\n   375→@dataclass\n   376→class OrderSession:\n   377→    session_id: str\n   378→    start_time: datetime\n   379→    items: list[OrderItem]\n   380→    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n   381→```\n   382→\n   383→### 3.2 Incremental Logging\n   384→\n   385→After each customer turn where an item is added:\n   386→- Append to `orders/{session_id}/incremental_log.jsonl`\n   387→- Each line is a JSON object with:\n   388→  - `timestamp`\n   389→  - `customer_utterance`\n   390→  - `item_parsed`\n   391→  - `agent_response`\n   392→\n   393→### 3.3 Final Output\n   394→\n   395→When customer says \"done\" or \"that's all\":\n   396→- Generate `orders/{session_id}/final_order.json`:\n   397→\n   398→```json\n   399→{\n   400→  \"session_id\": \"uuid-here\",\n   401→  \"timestamp\": \"2026-01-21T14:30:00Z\",\n   402→  \"items\": [\n   403→    {\n   404→      \"item_name\": \"Big Mac\",\n   405→      \"category\": \"Beef & Pork\",\n   406→      \"modifiers\": [],\n   407→      \"quantity\": 1\n   408→    },\n   409→    {\n   410→      \"item_name\": \"Medium Fries\",\n   411→      \"category\": \"Snacks & Sides\",\n   412→      \"modifiers\": [],\n   413→      \"quantity\": 1\n   414→    }\n   415→  ],\n   416→  \"total_items\": 2,\n   417→  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n   418→}\n   419→```\n   420→\n   421→---\n   422→\n   423→## 4. Agent Instructions & Persona\n   424→\n   425→### 4.1 System Prompt\n   426→\n   427→```\n   428→You are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n   429→\n   430→1. Greet the customer warmly\n   431→2. Listen carefully to their order\n   432→3. Use the add_item_to_order function to record each item\n   433→4. Confirm each item with the customer\n   434→5. When they're done, read back their complete order\n   435→6. Thank them and tell them the total\n   436→\n   437→Guidelines:\n   438→- Be concise and natural in your responses\n   439→- If you're unsure about an item, ask for clarification\n   440→- Always confirm items before adding to the order\n   441→- Use the exact menu item names when confirming\n   442→- If a customer mentions an item not on the menu, politely inform them\n   443→\n   444→Menu Structure:\n   445→- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n   446→- 212 total items\n   447→- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n   448→```\n   449→\n   450→### 4.2 Conversation Flow\n   451→\n   452→```\n   453→Agent: \"Welcome to McDonald's! What can I get for you today?\"\n   454→\n   455→Customer: \"I'll have a Big Mac\"\n   456→\n   457→Agent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n   458→      \"Got it, one Big Mac. Anything else?\"\n   459→\n   460→Customer: \"And a medium fries\"\n   461→\n   462→Agent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n   463→      \"One medium fries. Anything else?\"\n   464→\n   465→Customer: \"No, that's all\"\n   466→\n   467→Agent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n   468→       Please pull around to the first window.\"\n   469→       [Writes final order JSON]\n   470→```\n   471→\n   472→---\n   473→\n   474→## 5. Testing Strategy\n   475→\n   476→### 5.1 Test Categories\n   477→\n   478→1. **Single Item Orders**\n   479→   - Simple: \"I want a Big Mac\"\n   480→   - With quantity: \"Two cheeseburgers\"\n   481→   - With modifiers: \"Quarter Pounder with cheese\"\n   482→\n   483→2. **Multi-Item Orders**\n   484→   - \"Big Mac, large fries, and a Coke\"\n   485→   - \"Two Big Macs, one with no pickles\"\n   486→\n   487→3. **Complex Orders**\n   488→   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   489→   - Orders with substitutions\n   490→   - Orders with special requests\n   491→\n   492→4. **Error Handling**\n   493→   - Invalid items: \"I want a Whopper\" (Burger King item)\n   494→   - Unclear requests: \"I want a burger\"\n   495→   - Corrections: \"Actually, make that a McDouble\"\n   496→\n   497→5. **Accuracy Tests**\n   498→   - STT variations: \"Big Mack\" → \"Big Mac\"\n   499→   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   500→   - Modifier accuracy: Did modifiers get applied correctly?\n   501→\n   502→### 5.2 Test Implementation\n   503→\n   504→```python\n   505→@pytest.mark.asyncio\n   506→async def test_single_item_order_accuracy() -> None:\n   507→    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n   508→    async with (\n   509→        _llm() as judge_llm,\n   510→        AgentSession(llm=drive_thru_llm) as session,\n   511→    ):\n   512→        await session.start(DriveThruAgent())\n   513→\n   514→        # Customer orders a Big Mac\n   515→        result = await session.run(user_input=\"I'll have a Big Mac\")\n   516→\n   517→        # Verify the agent called the add_item_to_order function\n   518→        result.expect.next_event().is_function_call(\n   519→            function_name=\"add_item_to_order\",\n   520→            arguments={\n   521→                \"category\": \"Beef & Pork\",\n   522→                \"item_name\": \"Big Mac\",\n   523→                \"quantity\": 1,\n   524→                \"modifiers\": []\n   525→            }\n   526→        )\n   527→\n   528→        # Verify the agent confirmed the item\n   529→        await (\n   530→            result.expect.next_event()\n   531→            .is_message(role=\"assistant\")\n   532→            .judge(\n   533→                judge_llm,\n   534→                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n   535→            )\n   536→        )\n   537→\n   538→        # End the order\n   539→        result = await session.run(user_input=\"That's all\")\n   540→\n   541→        # Verify final order JSON was created correctly\n   542→        assert order_manager.get_final_order() == {\n   543→            \"items\": [\n   544→                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n   545→            ]\n   546→        }\n   547→```\n   548→\n   549→### 5.3 Accuracy Metrics\n   550→\n   551→Track the following metrics:\n   552→- **Item Name Accuracy**: % of items correctly identified\n   553→- **Modifier Accuracy**: % of modifiers correctly applied\n   554→- **Quantity Accuracy**: % of quantities correctly captured\n   555→- **Order Completeness**: % of orders with all items captured\n   556→- **False Positives**: Items added that weren't ordered\n   557→- **False Negatives**: Items ordered but not added\n   558→\n   559→Target: 95%+ accuracy on all metrics\n   560→\n   561→---\n   562→\n   563→## 6. Implementation Phases\n   564→\n   565→### Phase 1: Core Infrastructure (2-3 days)\n   566→- [ ] Create `MenuProvider` class\n   567→- [ ] Create `OrderStateManager` class\n   568→- [ ] Create basic `DriveThruLLM` wrapper\n   569→- [ ] Implement function calling for `add_item_to_order`\n   570→- [ ] Set up order file output (incremental + final)\n   571→- [ ] Write basic unit tests for each component\n   572→\n   573→### Phase 2: Accuracy Strategies - MVP (3-4 days)\n   574→- [ ] Implement Strategy 1: Function Calling\n   575→- [ ] Implement Strategy 2: Menu Context Injection\n   576→- [ ] Implement Strategy 4: Fuzzy String Matching\n   577→- [ ] Implement Strategy 9: Post-Processing Validation\n   578→- [ ] Write tests for each strategy\n   579→- [ ] Measure baseline accuracy\n   580→\n   581→### Phase 3: Agent Integration (2 days)\n   582→- [ ] Create `DriveThruAgent` with proper instructions\n   583→- [ ] Integrate with `VoiceAgentApp`\n   584→- [ ] Add configuration options to `config.py`\n   585→- [ ] Test end-to-end in console mode\n   586→- [ ] Fix bugs and edge cases\n   587→\n   588→### Phase 4: Testing & Refinement (2-3 days)\n   589→- [ ] Write comprehensive test suite (20+ tests)\n   590→- [ ] Test with real voice input (console mode)\n   591→- [ ] Measure accuracy metrics\n   592→- [ ] Identify failure modes\n   593→- [ ] Iterate on prompts and validation logic\n   594→\n   595→### Phase 5: Advanced Strategies (Optional, 2-3 days)\n   596→- [ ] Implement Strategy 3: Explicit Confirmation Loop\n   597→- [ ] Implement Strategy 5: Semantic Search with Embeddings\n   598→- [ ] A/B test different strategy combinations\n   599→- [ ] Optimize for latency and cost\n   600→\n   601→---\n   602→\n   603→## 7. File Structure\n   604→\n   605→```\n   606→src/\n   607→├── drive_thru_agent.py          # DriveThruAgent class\n   608→├── drive_thru_llm.py            # DriveThruLLM wrapper\n   609→├── menu_provider.py             # Menu loading and search\n   610→├── order_state_manager.py       # Order tracking and output\n   611→├── menu_validation.py           # Validation utilities\n   612→└── tools/\n   613→    └── order_tools.py           # LLM function definitions\n   614→\n   615→tests/\n   616→├── test_drive_thru_agent.py     # End-to-end agent tests\n   617→├── test_menu_provider.py        # Menu search tests\n   618→├── test_order_state.py          # Order state management tests\n   619→└── test_accuracy.py             # Accuracy benchmarks\n   620→\n   621→orders/\n   622→├── {session_id}/\n   623→│   ├── incremental_log.jsonl    # Per-turn logging\n   624→│   └── final_order.json         # Final order output\n   625→\n   626→plan/\n   627→└── mcdonalds-drive-thru-agent-plan.md  # This document\n   628→```\n   629→\n   630→---\n   631→\n   632→## 8. Configuration\n   633→\n   634→Add to `src/config.py`:\n   635→\n   636→```python\n   637→class DriveThruConfig(BaseModel):\n   638→    \"\"\"Configuration for drive-thru agent.\"\"\"\n   639→\n   640→    menu_file_path: str = Field(\n   641→        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n   642→        description=\"Path to menu JSON file\"\n   643→    )\n   644→\n   645→    orders_output_dir: str = Field(\n   646→        default=\"orders\",\n   647→        description=\"Directory to save order files\"\n   648→    )\n   649→\n   650→    fuzzy_match_threshold: int = Field(\n   651→        default=85,\n   652→        description=\"Minimum fuzzy match score (0-100)\"\n   653→    )\n   654→\n   655→    enable_confirmation_loop: bool = Field(\n   656→        default=True,\n   657→        description=\"Require confirmation before adding items\"\n   658→    )\n   659→\n   660→    enable_semantic_search: bool = Field(\n   661→        default=False,\n   662→        description=\"Use embeddings for semantic item search\"\n   663→    )\n   664→\n   665→    max_context_items: int = Field(\n   666→        default=50,\n   667→        description=\"Maximum number of menu items to inject into context\"\n   668→    )\n   669→```\n   670→\n   671→---\n   672→\n   673→## 9. Risks & Mitigations\n   674→\n   675→### Risk 1: STT Errors\n   676→**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n   677→**Mitigation**:\n   678→- Fuzzy string matching (Strategy 4)\n   679→- Semantic search (Strategy 5)\n   680→- Confirmation loop (Strategy 3)\n   681→\n   682→### Risk 2: LLM Hallucination\n   683→**Impact**: LLM adds items not on the menu\n   684→**Mitigation**:\n   685→- Function calling with strict validation\n   686→- Menu context injection (Strategy 2)\n   687→- Post-processing validation (Strategy 9)\n   688→\n   689→### Risk 3: Modifier Errors\n   690→**Impact**: Customer wants \"no pickles\" but modifier not captured\n   691→**Mitigation**:\n   692→- Structured modifier field in function calling\n   693→- Validation against available modifiers per item\n   694→- Explicit confirmation\n   695→\n   696→### Risk 4: Latency\n   697→**Impact**: Slow response times frustrate customers\n   698→**Mitigation**:\n   699→- Use faster LLM (GPT-4.1-nano or similar)\n   700→- Optimize context injection (Strategy 10)\n   701→- Precompute embeddings if using Strategy 5\n   702→- Enable preemptive generation\n   703→\n   704→### Risk 5: Multi-Item Order Complexity\n   705→**Impact**: Customer orders 5 items in one utterance, agent misses some\n   706→**Mitigation**:\n   707→- Ask customer to order one item at a time\n   708→- Use two-stage parsing (Strategy 6) if needed\n   709→- Read back full order at end for correction\n   710→\n   711→---\n   712→\n   713→## 10. Success Criteria\n   714→\n   715→The implementation will be considered successful when:\n   716→\n   717→1. **Accuracy**: ≥95% item name accuracy on test suite\n   718→2. **Modifier Accuracy**: ≥90% modifier accuracy\n   719→3. **Completeness**: ≥95% of orders captured completely\n   720→4. **Latency**: <2 seconds per turn (STT → TTS)\n   721→5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n   722→6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n   723→7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n   724→\n   725→---\n   726→\n   727→## 11. Future Enhancements\n   728→\n   729→After initial implementation, consider:\n   730→\n   731→1. **Meal Combos**: Support \"Number 1\" style ordering\n   732→2. **Upselling**: \"Would you like to make that a meal?\"\n   733→3. **Menu Recommendations**: Based on time of day, weather, etc.\n   734→4. **Price Calculation**: Calculate total cost\n   735→5. **Multi-Language Support**: Spanish, etc.\n   736→6. **Voice Biometrics**: Remember repeat customers\n   737→7. **Order History**: \"Same as last time\"\n   738→8. **Integration**: Connect to POS system for real orders\n   739→\n   740→---\n   741→\n   742→## 12. Key Design Decisions\n   743→\n   744→### Why Function Calling?\n   745→Function calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n   746→\n   747→### Why Multiple Strategies?\n   748→No single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n   749→\n   750→### Why Confirmation Loop?\n   751→Voice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n   752→\n   753→### Why Incremental Logging?\n   754→Provides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n   755→\n   756→### Why Focus on Accuracy Over Speed?\n   757→Wrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n   758→\n   759→---\n   760→\n   761→## 13. Experimentation Framework\n   762→\n   763→To determine which strategies work best, implement an experimentation framework:\n   764→\n   765→```python\n   766→class AccuracyExperiment:\n   767→    \"\"\"Framework for testing accuracy strategies.\"\"\"\n   768→\n   769→    def __init__(self, test_cases: list[OrderTestCase]):\n   770→        self.test_cases = test_cases\n   771→\n   772→    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n   773→        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n   774→        results = []\n   775→        for test_case in self.test_cases:\n   776→            result = await self.run_single_test(test_case, strategy_config)\n   777→            results.append(result)\n   778→        return ExperimentResults(results)\n   779→\n   780→    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n   781→        \"\"\"A/B test two strategy configurations.\"\"\"\n   782→        results_a = await self.run_experiment(strategy_a)\n   783→        results_b = await self.run_experiment(strategy_b)\n   784→        return Comparison(results_a, results_b)\n   785→```\n   786→\n   787→Use this to answer questions like:\n   788→- Does semantic search improve accuracy over fuzzy matching?\n   789→- What's the optimal fuzzy match threshold?\n   790→- Does chain-of-thought reduce hallucination?\n   791→- What's the latency vs accuracy tradeoff?\n   792→\n   793→---\n   794→\n   795→## 14. Monitoring & Observability\n   796→\n   797→In production, track:\n   798→- **Per-turn metrics**: Item extraction accuracy, latency\n   799→- **Per-order metrics**: Order completeness, correction rate\n   800→- **LLM metrics**: Token usage, cost per order\n   801→- **Error rates**: Invalid items, failed validations\n   802→- **User satisfaction**: Explicit feedback, order completion rate\n   803→\n   804→Use LiveKit's built-in metrics framework + custom application metrics.\n   805→\n   806→---\n   807→\n   808→## Conclusion\n   809→\n   810→This plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n   811→\n   812→The phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n   813→\n   814→**Next Steps**:\n   815→1. Review and approve this plan\n   816→2. Begin Phase 1 implementation\n   817→3. Set up testing infrastructure\n   818→4. Iterate based on real-world results\n   819→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7a26ec81-028c-4db8-95b1-57c47c0d3bde","timestamp":"2026-01-21T22:59:31.744Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","content":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[Custom DriveThruLLM Wrapper]\n    ├─ Menu Context Provider\n    ├─ Order State Manager\n    ├─ Validation Layer\n    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Response\n```\n\n### 1.2 New Components to Build\n\n1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n   - Wraps a base LLM with order-taking capabilities\n   - Manages conversation state and order tracking\n\n2. **MenuProvider** (`src/menu_provider.py`)\n   - Loads and manages menu data using existing Pydantic models\n   - Provides relevant menu context to LLM\n   - Implements fuzzy matching and search\n\n3. **OrderStateManager** (`src/order_state_manager.py`)\n   - Tracks items ordered during conversation\n   - Appends to incremental log file after each turn\n   - Generates final JSON output with timestamp\n\n4. **MenuValidationTools** (`src/menu_validation.py`)\n   - Validates LLM output against menu items\n   - Fuzzy matching for spoken variations\n   - Modifier validation\n\n5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   - Custom Agent subclass with drive-thru specific instructions\n   - Configures the drive-thru persona\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","numLines":819,"startLine":1,"totalLines":819}},"sourceToolAssistantUUID":"b002d8d3-5d07-45b1-9593-533365a13cad"}
{"parentUuid":"7a26ec81-028c-4db8-95b1-57c47c0d3bde","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01H1g9eYygXxC5wBWs3zD8fw","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I need to update the plan to include the requirements for the Item class modifications. Looking at the plan, I can see there are sections about \"Order State Management\" and the current OrderItem model is defined in section 3.1. I should add a new section or subsection that specifically addresses the changes to the Item class in the menu models.\n\nLet me add a new section that covers:\n1. Adding a `quantity` field to the Item class\n2. Adding an `item_id` field to the Item class  \n3. Defining addition for items where:\n   - Two items can be added if item1.name == item2.name AND set(item1.modifiers) == set(item2.modifiers) (order doesn't matter)\n   - If they can be added, add their quantities together\n\nI'll add this as a new subsection under the Order State Management section or create a new section about Menu Model Enhancements. Let me insert this in an appropriate location in the plan.\n\nI think the best place would be to add a new section right after section 3 (Order State Management) called something like \"Menu Model Enhancements\" or add it as section 3.4.","signature":"EtQJCkYICxgCKkA+LzDnWlr0wSKoq3q8wX2uvLh3nBQTiZdmnVD7KtCt8JT31hON7X+E/JRIe1yCU9HpHI35eI/ReKfeqBk1T8ByEgyo0IUDxh4bj7Y4dB8aDHfBevH7PlaoWD+ykiIwaTBf1X0VgIG0DkoCweHNab2CJ5+IgdUqTtLmjCzIZLPENAkOCEDfP9su2pgZKJheKrsI2tl0Z8xRshuMo1TS7VNY9Rl3mVn+Gaudfa5ItE9/pYafy7ioZ4+HG0g0+MLKHehOSMdDamMsMlljv8Qp+DHo+8usKwE3MugT/DtpDPIwY4nEXr8ZL3phckBmafdVClPMsFMyvba9JjvBdh0a7R4Cf/+7SHUcu9/WtGtXSg1Y8x/BPOwl12sxfE641yFW2xIRdQSyNgbQ+kmACmIB0sruXk7eMVvhshcez8Cfe8Ow+T4EGhViPhx4dnv9J6xiwPpBKCfYAGc4I4U5+ARF20Eq9EPJP0hh9Yw0sszKdYaarIB+EHttfl6JK3+E15P8r/vMwN5jYRBj9IpNmcWRPDG4kX905xBnTg+adVQagvI1v2tehPPQyIITzUIpw2unwbG/41btwNoxPAeTxKKLwPsyAohh5/QcdKc8Mq4wYhuYPDp+O42Nddl2cnXzrEJUJIoqWqNHOdWVMO3H0K1wqvFq5KAdN/UZUo16j3DiPeG9w69IRptPjwXbTllCGSyiHtl09ZBaxSR5wdDSlaPd3kr71olMDrulUPU5dpXRyAIJ0b0pa6Dvs84SXJjRu95piKj9HmPipL+76j1GThXwYjd7RCZeItC3+L0aAIIuMQcKwDcRzP06sC4Y2myXbBuOJVKz7gvxajE+n+3v5si7aWXD9mszlW6xJKzmhjxJmzQdfAeXRRhFW1/IvgVwKOcVHlC8zw/3Ly5mzk7jweVRbx0Opb+0GouzU1whTkbsylU2RNoTJkQe3FErJCRjtcjdVnakiApJ2cz9TWrjnGC7FGytpk5DAmaQAqaoU01K1D4HQgpX5JGQ0hW3caD6bPfPI2rcykAfxQJmTpTX0yit1HwfN5tkcfNOj/e1pc9N9eAXiFdNui3jBs3ACq7L+7jaheYiy5OmoVUJOc2gUt7XAoV4DaEDGfPvajvFcA4lMbBYUji2bDZNrOOlYqWnAvfsbXY0mqMn3XXd+JUm7LSYCGLrlQpAwQlFLUtTp4w6rBs7rw++bRT0I5s9cZdhqzkfHd9Tti3DXgfqB3q/FTEz7jMgPJOE6KPBcqZm0x2MoYAxnthgrMoCQOEnm2n3ylfiYzkIHO1A38OuBXkpPfmG/X/pQM1YFTYcC83/KN/dLw6wNYNR3hJ9sW+feq+499cHRkN2BZJdm3nEslt1K9AOR90Z/59OMC9vhnI18AtvZdSnRNGryesYWBMMPjMzZoS6BfVoY+z2VktEjdXyaXchu4LHI92g/HxvV00CuIFcEIOxqx4qmxYt/imlkXQI3YnnzVZUoX5hkTfMW1H0/mN3IBTfItEXoUrJKvLPruy04gptu0SfJlwuyr/37OrQvELufQ+FLS7TSXREKul4ts++tAVUTg8Vz0n6W8g3yw76xxFtiLB1CmxNWxJMO6V2p3P74sPlKgjBb3SgnuSKu8Y1bRGjqrk/I99hbCDyPrhdGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":9839,"cache_read_input_tokens":25821,"cache_creation":{"ephemeral_5m_input_tokens":9839,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMMRvqSLSS2sra2QHhj9","type":"assistant","uuid":"e374ee22-c0cf-44aa-aab7-422dd54646b4","timestamp":"2026-01-21T22:59:37.217Z"}
{"parentUuid":"e374ee22-c0cf-44aa-aab7-422dd54646b4","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01H1g9eYygXxC5wBWs3zD8fw","type":"message","role":"assistant","content":[{"type":"text","text":"I'll add the Item class enhancements to the plan. Let me update it to include these new requirements."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":9839,"cache_read_input_tokens":25821,"cache_creation":{"ephemeral_5m_input_tokens":9839,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMMRvqSLSS2sra2QHhj9","type":"assistant","uuid":"51c69c77-cce9-4e7b-9870-368f10bbd8f6","timestamp":"2026-01-21T22:59:37.674Z"}
{"parentUuid":"51c69c77-cce9-4e7b-9870-368f10bbd8f6","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01H1g9eYygXxC5wBWs3zD8fw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UAPMJ9V2C3toRPtLFnL6ny","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n---","new_string":"### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":9839,"cache_read_input_tokens":25821,"cache_creation":{"ephemeral_5m_input_tokens":9839,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMMRvqSLSS2sra2QHhj9","type":"assistant","uuid":"caf13bcc-129e-4ad2-aa3d-04fdb6991413","timestamp":"2026-01-21T22:59:48.866Z"}
{"type":"file-history-snapshot","messageId":"caf13bcc-129e-4ad2-aa3d-04fdb6991413","snapshot":{"messageId":"d6da4e92-e723-4b3e-9807-73571b5e0d36","trackedFileBackups":{"plan/mcdonalds-drive-thru-agent-plan.md":{"backupFileName":"7748f9d5e25401ec@v1","version":1,"backupTime":"2026-01-21T23:00:00.153Z"}},"timestamp":"2026-01-21T22:59:27.295Z"},"isSnapshotUpdate":true}
{"parentUuid":"caf13bcc-129e-4ad2-aa3d-04fdb6991413","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UAPMJ9V2C3toRPtLFnL6ny","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"a4522e20-9443-439b-9f3d-245579370ff8","timestamp":"2026-01-21T23:00:00.156Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n---","newString":"### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[Custom DriveThruLLM Wrapper]\n    ├─ Menu Context Provider\n    ├─ Order State Manager\n    ├─ Validation Layer\n    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Response\n```\n\n### 1.2 New Components to Build\n\n1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n   - Wraps a base LLM with order-taking capabilities\n   - Manages conversation state and order tracking\n\n2. **MenuProvider** (`src/menu_provider.py`)\n   - Loads and manages menu data using existing Pydantic models\n   - Provides relevant menu context to LLM\n   - Implements fuzzy matching and search\n\n3. **OrderStateManager** (`src/order_state_manager.py`)\n   - Tracks items ordered during conversation\n   - Appends to incremental log file after each turn\n   - Generates final JSON output with timestamp\n\n4. **MenuValidationTools** (`src/menu_validation.py`)\n   - Validates LLM output against menu items\n   - Fuzzy matching for spoken variations\n   - Modifier validation\n\n5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   - Custom Agent subclass with drive-thru specific instructions\n   - Configures the drive-thru persona\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":418,"oldLines":6,"newStart":418,"newLines":73,"lines":[" }"," ```"," ","+### 3.4 Menu Model Enhancements","+","+To support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:","+","+#### 3.4.1 New Fields","+","+1. **quantity field** (`int`, default=1)","+   - Tracks how many of this item are in the order","+   - Default value is 1 for single items","+   - Used for aggregating duplicate items","+","+2. **item_id field** (`str`)","+   - Unique identifier for each item instance","+   - Auto-generated UUID to distinguish between item instances","+   - Allows tracking individual items even with same name and modifiers","+","+#### 3.4.2 Item Addition (`__add__` method)","+","+Implements addition operator for combining items. Two items can be added if and only if:","+","+**Conditions**:","+- `item1.item_name == item2.item_name` (exact name match)","+- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)","+","+**Behavior**:","+- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`","+- If conditions are not met: Raise `ValueError` with descriptive message","+","+**Example Usage**:","+```python","+# Create two identical Big Macs","+item1 = Item(","+    category_name=\"Beef & Pork\",","+    item_name=\"Big Mac\",","+    available_as_base=True,","+    quantity=1","+)","+","+item2 = Item(","+    category_name=\"Beef & Pork\",","+    item_name=\"Big Mac\",","+    available_as_base=True,","+    quantity=2","+)","+","+# Add them together","+combined = item1 + item2  # quantity=3","+","+# Items with different modifiers cannot be added","+item3 = Item(","+    category_name=\"Beef & Pork\",","+    item_name=\"Big Mac\",","+    available_as_base=True,","+    quantity=1","+)","+item3.add_modifier(\"No Pickles\")","+","+# This will raise ValueError","+combined = item1 + item3  # Error! Different modifiers","+```","+","+**Implementation Notes**:","+- Modifier comparison uses set equality, so order doesn't matter","+- The new combined item gets a new `item_id`","+- Original items remain unchanged","+- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"","+"," ---"," "," ## 4. Agent Instructions & Persona"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"caf13bcc-129e-4ad2-aa3d-04fdb6991413"}
{"parentUuid":"a4522e20-9443-439b-9f3d-245579370ff8","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TeCi1ap867giqP1J72Hbau","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I should also update the implementation phases section to include tasks for implementing these menu model enhancements. Let me add tasks to Phase 1 since these are core infrastructure changes.","signature":"Eu0CCkYICxgCKkCGjCXZgP9aD6HQhesOg+qaV3Oz+Cr2vHLrD07MduwVomogmceDvLTlLRRvizfNnSpXZdQvQ+cLYCnFGdsajSJqEgxvwOlwgY20LCDOrKoaDLeEAdKmsCNzAFKIaiIwVm0qZAi+vtJFvEatexYV0aoubvcdZex1lAbLhRAb70SaEBnx+WY8vSQXamDCzxfcKtQB2wjLfu0BvEqNCtE56qVhYdmRTkPhcHNqIysh6vYfc33qvwGR+7vGfX+6wxZd8R89FqqQsqz3xrm/ML+ZorLlgsp94yFSRIhMAcCdb9+oDI6z2Z4L2Hy51JAr7bcJsf0xAMazQ+TxQsrKKGjMJO5HZ9BXmJvlSbKDBixVN8n2AhLdJ+3aZlq45pXNw43i0kCoXlmam0HRagIwx0/MIRd83VYVfwthIsYxOLv8X8h8SPTnRBy0GcdKDbL4Ig8tX5g1ynU/K62JsZsvnjjN/HBQYV1DsGwYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1522,"cache_read_input_tokens":35660,"cache_creation":{"ephemeral_5m_input_tokens":1522,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMMU2V4sGVoQzxyZfSog","type":"assistant","uuid":"cf48a5aa-1095-475e-a4eb-590751bc8b7b","timestamp":"2026-01-21T23:00:02.067Z"}
{"parentUuid":"cf48a5aa-1095-475e-a4eb-590751bc8b7b","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TeCi1ap867giqP1J72Hbau","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EDixmmhQ5iHj4hTNvZjhgG","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component","new_string":"### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1522,"cache_read_input_tokens":35660,"cache_creation":{"ephemeral_5m_input_tokens":1522,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMMU2V4sGVoQzxyZfSog","type":"assistant","uuid":"16647dff-9624-4572-afe3-105fb18be8a4","timestamp":"2026-01-21T23:00:05.837Z"}
{"parentUuid":"16647dff-9624-4572-afe3-105fb18be8a4","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EDixmmhQ5iHj4hTNvZjhgG","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"057e4ba3-9ef1-4fba-9447-8046fea25c6c","timestamp":"2026-01-21T23:00:05.884Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component","newString":"### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[Custom DriveThruLLM Wrapper]\n    ├─ Menu Context Provider\n    ├─ Order State Manager\n    ├─ Validation Layer\n    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Response\n```\n\n### 1.2 New Components to Build\n\n1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n   - Wraps a base LLM with order-taking capabilities\n   - Manages conversation state and order tracking\n\n2. **MenuProvider** (`src/menu_provider.py`)\n   - Loads and manages menu data using existing Pydantic models\n   - Provides relevant menu context to LLM\n   - Implements fuzzy matching and search\n\n3. **OrderStateManager** (`src/order_state_manager.py`)\n   - Tracks items ordered during conversation\n   - Appends to incremental log file after each turn\n   - Generates final JSON output with timestamp\n\n4. **MenuValidationTools** (`src/menu_validation.py`)\n   - Validates LLM output against menu items\n   - Fuzzy matching for spoken variations\n   - Modifier validation\n\n5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   - Custom Agent subclass with drive-thru specific instructions\n   - Configures the drive-thru persona\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":630,"oldLines":6,"newStart":630,"newLines":10,"lines":[" ## 6. Implementation Phases"," "," ### Phase 1: Core Infrastructure (2-3 days)","+- [ ] Enhance `Item` class with `quantity` field","+- [ ] Enhance `Item` class with `item_id` field","+- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)","+- [ ] Write unit tests for `Item` enhancements (addition, field validation)"," - [ ] Create `MenuProvider` class"," - [ ] Create `OrderStateManager` class"," - [ ] Create basic `DriveThruLLM` wrapper"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"16647dff-9624-4572-afe3-105fb18be8a4"}
{"parentUuid":"057e4ba3-9ef1-4fba-9447-8046fea25c6c","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BvKgpCijRZRmD2EfZa55nL","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Great! I've updated the plan with the Item class enhancements. Let me also update the file structure section to make it clear that these changes will be in the existing menu models file. Actually, looking at the file structure, it already shows the menus directory but doesn't specifically call out the models.py file. Let me check if I should add any reference to that in the relevant sections.\n\nActually, I think what I've added is sufficient. The changes are:\n\n1. Added a new section 3.4 \"Menu Model Enhancements\" that details:\n   - New `quantity` field\n   - New `item_id` field\n   - `__add__` method implementation with clear conditions and examples\n\n2. Updated Phase 1 implementation tasks to include:\n   - Enhancing Item class with quantity field\n   - Enhancing Item class with item_id field\n   - Implementing __add__ method\n   - Writing unit tests for these enhancements\n\nThis should give a clear picture of what needs to be done. Let me now provide a summary to the user.","signature":"EvgICkYICxgCKkAicNwDeF7/W4EhWujjipScyCwoVD81LJPUxJvE3IKlwG8tcDr33RrEVaI2/UchkoFfYWWxSswp3IO+TTznj63tEgxq0CeCV6adNqN9QwsaDP42/eSdtWq8P+WamSIwRzYmt7/8ZNokprQHImOkuIQAOv8LmiOA9FFHWMuqpkuXnnDEW21bF3vVnbspmlGHKt8HfELA9+zSE9r1WWcG2mUyV3oVDk2Eyh8sDSUcKuKlAWmtdxY/HId6PMM09um4Fb45CL5dTn+4XoIHT4B4QwVzDQcIuvziRBWaSOSTyrAGM+JCO5LzYcvCWSUm7Zc408G2mCJhms1/Tt1kKaHPjOQtsx/99+2rYD61Bg9mhrMLBBtPJJsdWHdm7G95u5VzYXnPYIwmVXkFhy4cVI1ZYadwFuyklunU7CLbLAYEyxgn5/P85wiLqthV7rn6zQDSSb0a61/gQcUzqH0IsDh/ay+DiOLc+iBTehnvMkrOUW0fLzmm1cDNCB+tUDnPwAqKNyiqOgM5wHbiO6PQAEl4EmucPpxZ/uivdg11Py9K/vHRNnv9ICnQQuFL4WET8Z23xB+4HxOkHY8vgoQ08sGuzxPoKSlzw53lipty4LAz38GX/86/5jQnFIdhT1Dg/7QwwsrAXHL33prOxzAa5OBFoMXzhNxCOKL2SXXfnZSdp4oCioPIPRHbcXLR0kNcz30r0oHln7KuvitwYfUw9h174SsMuhze2IbgmKtAJeozHhQ0TR0857i/3mBrG9WNRrxUgeL0O/5D4szKQjVBiTzK34FWzl1P2YnQqHVWEF9W/W8rIPaY4DbAq2uWQDuLScnJuyGLDiMRMb+32VAU+nwDaNdLvxu2IHaUs9eqGJGqc84QQAfi8blZM/SeoWaroXLdoK3XNdWGNNNnxreX8reIWPwG0i6PKhJfStct2iLtbWD56OZk+WZ4xaIZ4yu6ZllDPM6nxWyBhetlu1rizMs4KA+YkSOx7i0uv/Ha3qtyvwRtTxRFox8OQUTpFpQpu+Y5NkU8q24KA3C09cIOGV87z6RuXEWzCOCFr826L11nWLKbT1fn4UZrhf6gAEG+nR+eZgs5uikXTsAKoOmL4UmhDxBu9xZeTHgnGOPfSWpfG8ckNvRgQQ2IPPk8fIYHxtmA9zJwrX/SbgZ1KpViWcMNbelOkD7zxUp6Ret0BLxysEEv80fvZgKKZN322GybYMlT6Rfbtnd4yahw9dItNa4SHRnoSr7QLD8CPDiMlhqO8FtQMR/VdmV+RihtCk6YMaqCcOlkHaUi4j6NwaddN1uqJn3cLgmJSQgCs+zmzIu8be5Gp+4026ATc45XwgoI15tzM529OGiGNMlC3He1rMRiE7ok5PDMHYgQjLs3sFtpQ574kDUkvTz205VRMkxpdLLLQklP7kve2oUybHYZcFcstemaT4mAKjCfWtPwxBSA9chKehZRJy4r1mCX0JV5XnzjrAWmJeEaheGe41hITV/KJcJp/iG3dVDo3TRbZxbYSWWDUxgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":528,"cache_read_input_tokens":37182,"cache_creation":{"ephemeral_5m_input_tokens":528,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMMUSnJga8gfcoqtGnzP","type":"assistant","uuid":"a3edbaca-5ba0-4caa-bbf5-04234737bc64","timestamp":"2026-01-21T23:00:10.463Z"}
{"parentUuid":"a3edbaca-5ba0-4caa-bbf5-04234737bc64","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BvKgpCijRZRmD2EfZa55nL","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I've updated the plan to include the `Item` class enhancements. Here's what I added:\n\n## New Section 3.4: Menu Model Enhancements\n\nAdded detailed specifications for three new features:\n\n1. **`quantity` field** - Tracks how many of each item are in the order (default=1)\n\n2. **`item_id` field** - Unique UUID identifier for each item instance\n\n3. **`__add__` method** - Enables adding two items together with specific rules:\n   - **Can add if**: `item_name` matches AND modifiers are identical (order doesn't matter)\n   - **Result**: New item with combined quantities\n   - **Cannot add if**: Different names or different modifier sets → raises `ValueError`\n\nThe section includes example code showing how item addition works and edge cases.\n\n## Updated Phase 1 Tasks\n\nAdded to the implementation checklist:\n- Enhance `Item` class with `quantity` field\n- Enhance `Item` class with `item_id` field  \n- Implement `__add__` method for `Item` class\n- Write unit tests for `Item` enhancements\n\nThese tasks are now at the top of Phase 1 since they're foundational changes to the menu models that other components will depend on.\n\nThe plan now has a complete specification for the Item class modifications you requested at menus/mcdonalds/models.py."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":528,"cache_read_input_tokens":37182,"cache_creation":{"ephemeral_5m_input_tokens":528,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMMUSnJga8gfcoqtGnzP","type":"assistant","uuid":"b3048900-b47e-448c-9d7e-71026a233742","timestamp":"2026-01-21T23:00:14.683Z"}
{"parentUuid":"b3048900-b47e-448c-9d7e-71026a233742","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"system","subtype":"turn_duration","durationMs":36193,"timestamp":"2026-01-21T23:00:14.727Z","uuid":"3c52f2e5-d527-4196-883d-0644ced25392","isMeta":false}
{"type":"file-history-snapshot","messageId":"8ff89095-182a-4b75-a067-4eab61999c23","snapshot":{"messageId":"8ff89095-182a-4b75-a067-4eab61999c23","trackedFileBackups":{"plan/mcdonalds-drive-thru-agent-plan.md":{"backupFileName":"7748f9d5e25401ec@v2","version":2,"backupTime":"2026-01-21T23:30:37.328Z"}},"timestamp":"2026-01-21T23:30:37.328Z"},"isSnapshotUpdate":false}
{"parentUuid":"3c52f2e5-d527-4196-883d-0644ced25392","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":"DriveThruLLM says Manages conversation state and order tracking. I want this done by OrderStateManager. I want you to review the plan and ensure sharp boundaries and separations of concerns. be like Kent Beck and Dave Farley in your planning."},"uuid":"8ff89095-182a-4b75-a067-4eab61999c23","timestamp":"2026-01-21T23:30:37.319Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]},"todos":[]}
{"parentUuid":"8ff89095-182a-4b75-a067-4eab61999c23","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FZZ9698vfUuYNqLocxWx3e","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user is asking me to review the plan and ensure sharp boundaries and separation of concerns. They specifically note that DriveThruLLM says it \"manages conversation state and order tracking\" but they want that done by OrderStateManager instead.\n\nThis is a good catch - there's a mixing of concerns. Let me think about what each component should do following SOLID principles and clean architecture:\n\n1. **DriveThruLLM** - Should be a thin wrapper around the base LLM that:\n   - Intercepts/wraps LLM calls\n   - Maybe injects menu context\n   - But should NOT manage state\n\n2. **OrderStateManager** - Should handle:\n   - Order state (items, quantities, etc.)\n   - Persistence (incremental logs, final JSON)\n   - Order validation/aggregation\n\n3. **MenuProvider** - Should handle:\n   - Loading menu data\n   - Searching/querying menu\n   - Menu validation\n\n4. **MenuValidationTools/menu_validation.py** - Should handle:\n   - Fuzzy matching\n   - Item validation against menu\n   - Modifier validation\n\n5. **DriveThruAgent** - Should handle:\n   - Agent-level orchestration\n   - Instructions/persona\n   - Conversation flow\n\nThe user wants me to be like Kent Beck and Dave Farley - that means:\n- Single Responsibility Principle\n- Clear boundaries\n- Tell, Don't Ask\n- High cohesion, low coupling\n- Test-driven thinking\n- Continuous delivery mindset\n\nLet me read through the plan more carefully and identify all the places where responsibilities are mixed or unclear.","signature":"EsQMCkYICxgCKkCvjloYxQRooIFgXUcJCWvRUyIklIuVTWnLcZhirI6eIEDXsdtLHtW5vLZDxhYf+Ka7AOrJIlqz2KBoc/5xAqptEgy8UJ8k+tUPFFdXB1caDHp6rv/lxnZFUca+6iIw6xt4jX5ZpAXo2J4oSFO8jTqUMMTTJpNjkN89eBpI28hV+/LlMjCQZ6G0T2szL0dQKqsLEh9qGE23mX3KDpjgsltMxmBdd4R9nZJ6qpEln0IQT22ppSIu5epoFwQDe01Xvb82qd9AOYfsLj1ywC4t21zB4S4OFGQtfZHonCywBxbIus5+oV7msGPcsGvveCnBuhu9R9kjHXQdAAY22Trnb5yEI5YBoXwPlZ2jwuHNujNXbO9hATWUsSj1bC1WoX9Mij44/2hFYeWYaMPMYYNNqtDGRs0usWm2oTyT+hYQTEIJ7K1tf6KB4aTv6uR5AGDNdRikW0E7wADEThSSC3ClR9BDaV+YFxeswdMPNBoZjM0OyFBVJW4ehhD2s1HvKpw6Jw5HCIuwRLLILVGUTG5O6oI8+l41Couyau35tsbe5k30Qj9cYvrv8r7DnTnJEqmslkUCB9OD4OLrySgyUEkH8GC0h/FDPK44WkdVefNMWKC96wC9qSXtSYYEXPE5rmzKuxj+c+xEyUdQeCpXxiZwWZX3HuRBDya5Zw6dZymUSM5Duy6LXAIZbNtkFkxHxK3aO3gS6Zg6RJbYe6WC0RIXvTIKDfSvbdxQyfnMwxuHOCcxvTc3ZQgAUjYtOyXIyg6XPYjm2ABNHpXudBq0gfyHpHAW61ildBwKTrMDRUHcp6WUSj4tTfP3SHbKkvbHVgYJQkdhsTIJccJGzlDcRl+hQI6gZyopI1US++9L9VodnL4axS3MKLkVoFNVh6QMYjmp6smF8d0ncLxkLzC34Haut16UnlXs/9jgopro9JtDwZe0G2iasODRYj2xFuMpUscTEptnfTPedT24FPsCof9ey1CgDdU42M1l8aSX/7IodDQaJ3mHye7AGJCu9qI8P2F37fDXL3ULaXzqfYyIxSEcM7nQ+3199aBA6JhLYB5gXnipV9k8UYIJ3ov4RrQRdcrJ9coRb9noI1yoSEAujqfcJkFB6Q4q6cwpY31RodnLccEmRrQhpZDWJAVfRpE8mXvEAoOnEppoLqVlWqSvNCmi8zTLkCvpAm0c9JjtSviem2ZqOGQd9AIB83adJe37xIRRKfwdD5YrB032MBJJtQeJK3pIEY1zhNuyHfNlBjrtDx4tsSugWB1BDqTK+LXf7XOeWuo8OiWutH2LWeD1r3jY8C1x7R3HA8cEtFvdc18cOB7YBi1/YaFl7sgYzRhuYgxHm0jPNr6pZ+46V+mlQyhKuGbRmGsk9YxIA8JOgy6XR+27cDzMVR4grFQ9jd+ztKfGtpBVdufbO+T50wzY12Aqn1P+e/2g1EMx1bQ7UhqXFFAwutS53ZQeQRatj/zZwTwWvyPMvUFMAPjNsj8aEN8tFsUo9v/yyIKrHEBH1mQvmjQibQRLXKMRGIm57fnBNX7pYWA5dB1V54d+iqu3yOzwokjPtG1yz7ZPgATPq2zYsKa8hqrJUvRvFWNMPPG5lQo+vgiV1K6ypIpY7dOhqfjbb2RKOdQP02vcRSSs0DGyYvn8OnnDAembgSfJ/k4eeDIG3cH5TX7pL9mmyhI6Zq7WIxoPI6QJy/WxGWjzR4GoVQNwkUQMkYiHSF8ofDLZcTUciOjG8OnyVkIlW6fUOwJO729NsdlwQfGDT1YP0WBzjm4SjH6WqGH6WPW+GJrRNTLO1ywgXwdpzYJ8YDvoXJMv+VhH5T4O5brSSdN6mkp+KJn4ZPPCm3WGdIxmdA/EM2evPJzmXJ7eJCO+CqRkPgyNZscZEAOqYoCLYdQugmK259Lz2M0gselxaR1POq4z0s//AZCjKbH3HjSW6NtzGQ1PT3ialdglrxWCUfl6HZq7PITm94pd6IiGQ3P0u2EZPHmxRrLLIydvIQ3cNpfMXMSbKaALcXChwc2JvphSF49XW6bVb8BrWXNWsW9MofMTv1JwRl43xthtoKya1pejOrvwYVSJCV3+W3cVHWErmVM9PBrioCuH5lniAlhPQ6BMwwyXDHeTFCOC0V9fqx813UYYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":37664,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37664,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPoTWUaLh2xo7dvM3rr","type":"assistant","uuid":"e0ad56e2-b0cb-463a-aaa6-a0bf4b573c17","timestamp":"2026-01-21T23:30:44.197Z"}
{"parentUuid":"e0ad56e2-b0cb-463a-aaa6-a0bf4b573c17","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FZZ9698vfUuYNqLocxWx3e","type":"message","role":"assistant","content":[{"type":"text","text":"I'll review the plan with a focus on separation of concerns and clean boundaries. Let me read through it carefully and identify where responsibilities are mixed."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":37664,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37664,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPoTWUaLh2xo7dvM3rr","type":"assistant","uuid":"fb7dd650-0eb1-4031-86b1-a71f1487e54f","timestamp":"2026-01-21T23:30:44.618Z"}
{"parentUuid":"fb7dd650-0eb1-4031-86b1-a71f1487e54f","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FZZ9698vfUuYNqLocxWx3e","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01McSHRyfmJSzSKb4hucbTMP","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","offset":35,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":37664,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":37664,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPoTWUaLh2xo7dvM3rr","type":"assistant","uuid":"731132b8-da2b-42e3-a15e-a21094a12e39","timestamp":"2026-01-21T23:30:45.198Z"}
{"parentUuid":"731132b8-da2b-42e3-a15e-a21094a12e39","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01McSHRyfmJSzSKb4hucbTMP","type":"tool_result","content":"    35→### 1.2 New Components to Build\n    36→\n    37→1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n    38→   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n    39→   - Wraps a base LLM with order-taking capabilities\n    40→   - Manages conversation state and order tracking\n    41→\n    42→2. **MenuProvider** (`src/menu_provider.py`)\n    43→   - Loads and manages menu data using existing Pydantic models\n    44→   - Provides relevant menu context to LLM\n    45→   - Implements fuzzy matching and search\n    46→\n    47→3. **OrderStateManager** (`src/order_state_manager.py`)\n    48→   - Tracks items ordered during conversation\n    49→   - Appends to incremental log file after each turn\n    50→   - Generates final JSON output with timestamp\n    51→\n    52→4. **MenuValidationTools** (`src/menu_validation.py`)\n    53→   - Validates LLM output against menu items\n    54→   - Fuzzy matching for spoken variations\n    55→   - Modifier validation\n    56→\n    57→5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n    58→   - Custom Agent subclass with drive-thru specific instructions\n    59→   - Configures the drive-thru persona\n    60→\n    61→---\n    62→\n    63→## 2. Accuracy-Boosting Strategies\n    64→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"238f758a-0cc0-4ffa-b9a2-93ec3b58cb08","timestamp":"2026-01-21T23:30:45.253Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","content":"### 1.2 New Components to Build\n\n1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n   - Wraps a base LLM with order-taking capabilities\n   - Manages conversation state and order tracking\n\n2. **MenuProvider** (`src/menu_provider.py`)\n   - Loads and manages menu data using existing Pydantic models\n   - Provides relevant menu context to LLM\n   - Implements fuzzy matching and search\n\n3. **OrderStateManager** (`src/order_state_manager.py`)\n   - Tracks items ordered during conversation\n   - Appends to incremental log file after each turn\n   - Generates final JSON output with timestamp\n\n4. **MenuValidationTools** (`src/menu_validation.py`)\n   - Validates LLM output against menu items\n   - Fuzzy matching for spoken variations\n   - Modifier validation\n\n5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   - Custom Agent subclass with drive-thru specific instructions\n   - Configures the drive-thru persona\n\n---\n\n## 2. Accuracy-Boosting Strategies\n","numLines":30,"startLine":35,"totalLines":890}},"sourceToolAssistantUUID":"731132b8-da2b-42e3-a15e-a21094a12e39"}
{"parentUuid":"238f758a-0cc0-4ffa-b9a2-93ec3b58cb08","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019g1aqscJ6SjrQapfNf5v9X","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, I can see the issue clearly now. Line 40 says DriveThruLLM \"Manages conversation state and order tracking\" but that should be OrderStateManager's job.\n\nLet me also look at the existing codebase to understand the pattern they're using - specifically the KeywordInterceptLLM mentioned as a reference.","signature":"EtcDCkYICxgCKkAovUO502ZuAI8joEZH5WtMhJ+dlhFAG1twNlzTC5cil6JCe3NBeKKea06ky4FThgqCAk46HCmwpi1Hq+jtkYrUEgz8ZXVXVYxo9HgImsMaDHD60yP+NUaKA5IbdSIwfYml4DnNUySqB4DjeAYqDnhIIWsrCXeVhLAzoHvFpBYynTuuvdVjVxeAW4mDSbOGKr4CP9wZsO9ZUnpbmsz1wCXjIGAXD3WHK7GGgqzvqdWpprWPn2vBgBCyewFhto9fEduAwG+2pWfFgb8cl5f6eEYiVF6M9HE2QzeLWMRuJPyydPF5c+sr8I0qd2dnmWXVHoOteBjWvg0Cn0MHjWNL1DHSrDHEqXKmgQFUfQ0ZjrkbmiRzZfqwL+aPLagw6okZwnvt1DlX7+TSRDhDLVPg1mHOs6qvVpFcg/RBw7mI86e5ipeN3t83QIW/Mqzu42t5XeKW4mUYdpF1HeGA8vwZIYyeJwYNbqfsC8C9wODn9RTtXwOfWtTQXzp+6hJY0IZL+QOaFDXSgODhrCgLqDfISb58PqEXuqhggz/+Bt3hGpyGaquTU90nDlHWAoBFClyGdjd/s4i+rFq291/k7e6HrkVPRxjWfNvJhRsA8AIlbfNQGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":1004,"cache_read_input_tokens":37664,"cache_creation":{"ephemeral_5m_input_tokens":1004,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPp3PvduuwbUnaxeaPw","type":"assistant","uuid":"5ec8932b-f43c-4c2b-8e5f-c76f93e117cf","timestamp":"2026-01-21T23:30:47.765Z"}
{"parentUuid":"5ec8932b-f43c-4c2b-8e5f-c76f93e117cf","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019g1aqscJ6SjrQapfNf5v9X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WVScRRguoKHJP1uWV4uC7t","name":"Glob","input":{"pattern":"**/*keyword*llm*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":1004,"cache_read_input_tokens":37664,"cache_creation":{"ephemeral_5m_input_tokens":1004,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPp3PvduuwbUnaxeaPw","type":"assistant","uuid":"60342a92-ccc9-4201-9bde-7c8720e41d8d","timestamp":"2026-01-21T23:30:48.176Z"}
{"parentUuid":"60342a92-ccc9-4201-9bde-7c8720e41d8d","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WVScRRguoKHJP1uWV4uC7t","type":"tool_result","content":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/keyword_intercept_llm.py"}]},"uuid":"12de276e-05ea-42e2-970e-86bc0ca3793c","timestamp":"2026-01-21T23:30:48.739Z","toolUseResult":{"filenames":["/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/keyword_intercept_llm.py"],"durationMs":520,"numFiles":1,"truncated":false},"sourceToolAssistantUUID":"60342a92-ccc9-4201-9bde-7c8720e41d8d"}
{"parentUuid":"12de276e-05ea-42e2-970e-86bc0ca3793c","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VBVxi3w3AjstHFYeQV4cYv","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, let me read this to understand the pattern being used for LLM wrappers.","signature":"EvUBCkYICxgCKkCcoZm3CaDmNL1jxQIq0E/ITsfyW4U9mT4XI8eTDPwwwzJkZwvbe10LdD7g1g82fFsNnp9mfiU2F6ZvfcY9KN1FEgzIPeXteXA1qrmQQaMaDImAkVykZCky8pWJESIw5qLzxBeya4GALZa8QpVJtDkphz1cYUurnes5DBfrVwUqpLiXnXqmsD1WLyJd3QBrKl1jSiyyQBPzmfuAWykN+R0th52FXq1bvdk9DvWD1AeDktnHYR3g7H6ELtpCorIkBIju9wS6AdTTjOipL6Hm9/p92hNAvSqb0rvjtMmayUblBDFkU2FZNqS7v6dDezEYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":194,"cache_read_input_tokens":38668,"cache_creation":{"ephemeral_5m_input_tokens":194,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPpHms1StZUkhAbNruZ","type":"assistant","uuid":"f0216680-67de-4018-8477-1ec1a6c32088","timestamp":"2026-01-21T23:30:50.186Z"}
{"parentUuid":"f0216680-67de-4018-8477-1ec1a6c32088","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VBVxi3w3AjstHFYeQV4cYv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016geitTbdaXKTrx8gZ31KXa","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/keyword_intercept_llm.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":194,"cache_read_input_tokens":38668,"cache_creation":{"ephemeral_5m_input_tokens":194,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPpHms1StZUkhAbNruZ","type":"assistant","uuid":"90ebb7d1-8f5b-492e-9c1b-64c38248559c","timestamp":"2026-01-21T23:30:50.542Z"}
{"parentUuid":"90ebb7d1-8f5b-492e-9c1b-64c38248559c","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016geitTbdaXKTrx8gZ31KXa","type":"tool_result","content":"     1→\"\"\"Keyword-intercepting LLM wrapper.\n     2→\n     3→This module provides a wrapper LLM that intercepts user input containing\n     4→specific keywords and returns a fixed response instead of calling the\n     5→underlying LLM. For non-keyword input, it delegates to the wrapped LLM.\n     6→\"\"\"\n     7→\n     8→from __future__ import annotations\n     9→\n    10→import asyncio\n    11→from typing import Any\n    12→\n    13→from livekit.agents.llm import (\n    14→    LLM,\n    15→    ChatChunk,\n    16→    ChatContext,\n    17→    ChoiceDelta,\n    18→    LLMStream,\n    19→    Tool,\n    20→    ToolChoice,\n    21→)\n    22→from livekit.agents.types import (\n    23→    DEFAULT_API_CONNECT_OPTIONS,\n    24→    NOT_GIVEN,\n    25→    APIConnectOptions,\n    26→    NotGivenOr,\n    27→)\n    28→from loguru import logger\n    29→\n    30→\n    31→class KeywordInterceptLLM(LLM):\n    32→    \"\"\"LLM wrapper that intercepts input containing specific keywords.\n    33→\n    34→    This wrapper checks user input for specified keywords. When a keyword\n    35→    is detected, it returns a fixed response instead of calling the wrapped\n    36→    LLM. For all other input, it delegates to the wrapped LLM.\n    37→    \"\"\"\n    38→\n    39→    def __init__(\n    40→        self,\n    41→        wrapped_llm: LLM,\n    42→        keywords: list[str] | None = None,\n    43→        response_text: str = \"I don't like fruit\",\n    44→    ) -> None:\n    45→        \"\"\"Initialize the keyword-intercepting LLM wrapper.\n    46→\n    47→        Args:\n    48→            wrapped_llm: The actual LLM to delegate to when keywords are not detected\n    49→            keywords: List of keywords to intercept (case-insensitive).\n    50→                     Defaults to fruit-related keywords.\n    51→            response_text: Text to return when keywords are detected.\n    52→                          Defaults to \"I don't like fruit\".\n    53→        \"\"\"\n    54→        super().__init__()\n    55→        self._wrapped_llm = wrapped_llm\n    56→        self._keywords = keywords or [\"cherries\", \"cherry\", \"banana\", \"apple\", \"fruit\"]\n    57→        self._response_text = response_text\n    58→\n    59→        # Convert keywords to lowercase for case-insensitive matching\n    60→        self._keywords_lower = [kw.lower() for kw in self._keywords]\n    61→\n    62→        logger.info(\n    63→            f\"KeywordInterceptLLM initialized with keywords: {self._keywords}, \"\n    64→            f\"response: '{self._response_text}'\"\n    65→        )\n    66→\n    67→    @property\n    68→    def model(self) -> str:\n    69→        \"\"\"Return the wrapped LLM's model identifier.\"\"\"\n    70→        return self._wrapped_llm.model\n    71→\n    72→    @property\n    73→    def provider(self) -> str:\n    74→        \"\"\"Return the wrapped LLM's provider identifier.\"\"\"\n    75→        return self._wrapped_llm.provider\n    76→\n    77→    def _get_latest_user_message(self, chat_ctx: ChatContext) -> str:\n    78→        \"\"\"Extract the most recent user message from chat context.\n    79→\n    80→        Args:\n    81→            chat_ctx: The chat context containing the conversation history\n    82→\n    83→        Returns:\n    84→            The content of the most recent user message, or empty string if none found\n    85→        \"\"\"\n    86→        for item in reversed(chat_ctx.items):\n    87→            if hasattr(item, \"role\") and item.role == \"user\" and hasattr(item, \"content\"):\n    88→                # Extract text content from the item\n    89→                # Content might be a list of content parts or a string\n    90→                content = item.content\n    91→                if isinstance(content, list):\n    92→                    # Join all text parts\n    93→                    text_parts = []\n    94→                    for part in content:\n    95→                        if hasattr(part, \"text\"):\n    96→                            text_parts.append(part.text)\n    97→                        elif isinstance(part, str):\n    98→                            text_parts.append(part)\n    99→                    return \" \".join(text_parts)\n   100→                elif isinstance(content, str):\n   101→                    return content\n   102→        return \"\"\n   103→\n   104→    def _contains_keyword(self, text: str) -> bool:\n   105→        \"\"\"Check if text contains any of the intercepted keywords.\n   106→\n   107→        Args:\n   108→            text: The text to check for keywords\n   109→\n   110→        Returns:\n   111→            True if any keyword is found (case-insensitive), False otherwise\n   112→        \"\"\"\n   113→        text_lower = text.lower()\n   114→        for keyword in self._keywords_lower:\n   115→            if keyword in text_lower:\n   116→                logger.debug(f\"Keyword '{keyword}' detected in user input\")\n   117→                return True\n   118→        return False\n   119→\n   120→    def chat(\n   121→        self,\n   122→        *,\n   123→        chat_ctx: ChatContext,\n   124→        tools: list[Tool] | None = None,\n   125→        conn_options: APIConnectOptions = DEFAULT_API_CONNECT_OPTIONS,\n   126→        parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,\n   127→        tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,\n   128→        extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN,\n   129→    ) -> LLMStream:\n   130→        \"\"\"Create a chat stream, intercepting keywords if present.\n   131→\n   132→        Args:\n   133→            chat_ctx: The chat context\n   134→            tools: Available tools for the LLM\n   135→            conn_options: API connection options\n   136→            parallel_tool_calls: Whether to allow parallel tool calls\n   137→            tool_choice: Tool choice configuration\n   138→            extra_kwargs: Additional keyword arguments\n   139→\n   140→        Returns:\n   141→            LLMStream that either returns fixed response or delegates to wrapped LLM\n   142→        \"\"\"\n   143→        # Extract latest user message\n   144→        user_message = self._get_latest_user_message(chat_ctx)\n   145→\n   146→        # Check for keywords\n   147→        if self._contains_keyword(user_message):\n   148→            logger.info(\"Keyword detected - returning fixed response\")\n   149→            return KeywordInterceptStream(\n   150→                self,\n   151→                chat_ctx=chat_ctx,\n   152→                tools=tools or [],\n   153→                conn_options=conn_options,\n   154→                response_text=self._response_text,\n   155→            )\n   156→        else:\n   157→            logger.debug(\"No keywords detected - delegating to wrapped LLM\")\n   158→            return self._wrapped_llm.chat(\n   159→                chat_ctx=chat_ctx,\n   160→                tools=tools,\n   161→                conn_options=conn_options,\n   162→                parallel_tool_calls=parallel_tool_calls,\n   163→                tool_choice=tool_choice,\n   164→                extra_kwargs=extra_kwargs,\n   165→            )\n   166→\n   167→\n   168→class KeywordInterceptStream(LLMStream):\n   169→    \"\"\"Stream implementation for keyword-intercepted responses.\"\"\"\n   170→\n   171→    def __init__(\n   172→        self,\n   173→        llm: KeywordInterceptLLM,\n   174→        *,\n   175→        chat_ctx: ChatContext,\n   176→        tools: list[Tool],\n   177→        conn_options: APIConnectOptions,\n   178→        response_text: str,\n   179→    ) -> None:\n   180→        \"\"\"Initialize the keyword intercept stream.\n   181→\n   182→        Args:\n   183→            llm: The parent KeywordInterceptLLM instance\n   184→            chat_ctx: The chat context\n   185→            tools: Available tools\n   186→            conn_options: API connection options\n   187→            response_text: The fixed response text to stream\n   188→        \"\"\"\n   189→        super().__init__(llm, chat_ctx=chat_ctx, tools=tools, conn_options=conn_options)\n   190→        self._response_text = response_text\n   191→\n   192→    async def _run(self) -> None:\n   193→        \"\"\"Generate the fixed response by streaming it.\n   194→\n   195→        This simulates a realistic LLM response with a small delay for\n   196→        time-to-first-token and then streams the complete response.\n   197→        \"\"\"\n   198→        # Simulate a small time-to-first-token delay\n   199→        await asyncio.sleep(0.05)\n   200→\n   201→        # Stream the complete response in one chunk\n   202→        self._send_chunk(delta=self._response_text)\n   203→\n   204→    def _send_chunk(self, *, delta: str | None = None) -> None:\n   205→        \"\"\"Send a chat chunk with the given content delta.\n   206→\n   207→        Args:\n   208→            delta: The text content to send in this chunk\n   209→        \"\"\"\n   210→        self._event_ch.send_nowait(\n   211→            ChatChunk(\n   212→                id=str(id(self)),\n   213→                delta=ChoiceDelta(\n   214→                    role=\"assistant\",\n   215→                    content=delta,\n   216→                    tool_calls=[],\n   217→                ),\n   218→            )\n   219→        )\n   220→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9e3e6aca-31a3-479a-95dd-96b4596d0eee","timestamp":"2026-01-21T23:30:50.593Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/keyword_intercept_llm.py","content":"\"\"\"Keyword-intercepting LLM wrapper.\n\nThis module provides a wrapper LLM that intercepts user input containing\nspecific keywords and returns a fixed response instead of calling the\nunderlying LLM. For non-keyword input, it delegates to the wrapped LLM.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom typing import Any\n\nfrom livekit.agents.llm import (\n    LLM,\n    ChatChunk,\n    ChatContext,\n    ChoiceDelta,\n    LLMStream,\n    Tool,\n    ToolChoice,\n)\nfrom livekit.agents.types import (\n    DEFAULT_API_CONNECT_OPTIONS,\n    NOT_GIVEN,\n    APIConnectOptions,\n    NotGivenOr,\n)\nfrom loguru import logger\n\n\nclass KeywordInterceptLLM(LLM):\n    \"\"\"LLM wrapper that intercepts input containing specific keywords.\n\n    This wrapper checks user input for specified keywords. When a keyword\n    is detected, it returns a fixed response instead of calling the wrapped\n    LLM. For all other input, it delegates to the wrapped LLM.\n    \"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        keywords: list[str] | None = None,\n        response_text: str = \"I don't like fruit\",\n    ) -> None:\n        \"\"\"Initialize the keyword-intercepting LLM wrapper.\n\n        Args:\n            wrapped_llm: The actual LLM to delegate to when keywords are not detected\n            keywords: List of keywords to intercept (case-insensitive).\n                     Defaults to fruit-related keywords.\n            response_text: Text to return when keywords are detected.\n                          Defaults to \"I don't like fruit\".\n        \"\"\"\n        super().__init__()\n        self._wrapped_llm = wrapped_llm\n        self._keywords = keywords or [\"cherries\", \"cherry\", \"banana\", \"apple\", \"fruit\"]\n        self._response_text = response_text\n\n        # Convert keywords to lowercase for case-insensitive matching\n        self._keywords_lower = [kw.lower() for kw in self._keywords]\n\n        logger.info(\n            f\"KeywordInterceptLLM initialized with keywords: {self._keywords}, \"\n            f\"response: '{self._response_text}'\"\n        )\n\n    @property\n    def model(self) -> str:\n        \"\"\"Return the wrapped LLM's model identifier.\"\"\"\n        return self._wrapped_llm.model\n\n    @property\n    def provider(self) -> str:\n        \"\"\"Return the wrapped LLM's provider identifier.\"\"\"\n        return self._wrapped_llm.provider\n\n    def _get_latest_user_message(self, chat_ctx: ChatContext) -> str:\n        \"\"\"Extract the most recent user message from chat context.\n\n        Args:\n            chat_ctx: The chat context containing the conversation history\n\n        Returns:\n            The content of the most recent user message, or empty string if none found\n        \"\"\"\n        for item in reversed(chat_ctx.items):\n            if hasattr(item, \"role\") and item.role == \"user\" and hasattr(item, \"content\"):\n                # Extract text content from the item\n                # Content might be a list of content parts or a string\n                content = item.content\n                if isinstance(content, list):\n                    # Join all text parts\n                    text_parts = []\n                    for part in content:\n                        if hasattr(part, \"text\"):\n                            text_parts.append(part.text)\n                        elif isinstance(part, str):\n                            text_parts.append(part)\n                    return \" \".join(text_parts)\n                elif isinstance(content, str):\n                    return content\n        return \"\"\n\n    def _contains_keyword(self, text: str) -> bool:\n        \"\"\"Check if text contains any of the intercepted keywords.\n\n        Args:\n            text: The text to check for keywords\n\n        Returns:\n            True if any keyword is found (case-insensitive), False otherwise\n        \"\"\"\n        text_lower = text.lower()\n        for keyword in self._keywords_lower:\n            if keyword in text_lower:\n                logger.debug(f\"Keyword '{keyword}' detected in user input\")\n                return True\n        return False\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        conn_options: APIConnectOptions = DEFAULT_API_CONNECT_OPTIONS,\n        parallel_tool_calls: NotGivenOr[bool] = NOT_GIVEN,\n        tool_choice: NotGivenOr[ToolChoice] = NOT_GIVEN,\n        extra_kwargs: NotGivenOr[dict[str, Any]] = NOT_GIVEN,\n    ) -> LLMStream:\n        \"\"\"Create a chat stream, intercepting keywords if present.\n\n        Args:\n            chat_ctx: The chat context\n            tools: Available tools for the LLM\n            conn_options: API connection options\n            parallel_tool_calls: Whether to allow parallel tool calls\n            tool_choice: Tool choice configuration\n            extra_kwargs: Additional keyword arguments\n\n        Returns:\n            LLMStream that either returns fixed response or delegates to wrapped LLM\n        \"\"\"\n        # Extract latest user message\n        user_message = self._get_latest_user_message(chat_ctx)\n\n        # Check for keywords\n        if self._contains_keyword(user_message):\n            logger.info(\"Keyword detected - returning fixed response\")\n            return KeywordInterceptStream(\n                self,\n                chat_ctx=chat_ctx,\n                tools=tools or [],\n                conn_options=conn_options,\n                response_text=self._response_text,\n            )\n        else:\n            logger.debug(\"No keywords detected - delegating to wrapped LLM\")\n            return self._wrapped_llm.chat(\n                chat_ctx=chat_ctx,\n                tools=tools,\n                conn_options=conn_options,\n                parallel_tool_calls=parallel_tool_calls,\n                tool_choice=tool_choice,\n                extra_kwargs=extra_kwargs,\n            )\n\n\nclass KeywordInterceptStream(LLMStream):\n    \"\"\"Stream implementation for keyword-intercepted responses.\"\"\"\n\n    def __init__(\n        self,\n        llm: KeywordInterceptLLM,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool],\n        conn_options: APIConnectOptions,\n        response_text: str,\n    ) -> None:\n        \"\"\"Initialize the keyword intercept stream.\n\n        Args:\n            llm: The parent KeywordInterceptLLM instance\n            chat_ctx: The chat context\n            tools: Available tools\n            conn_options: API connection options\n            response_text: The fixed response text to stream\n        \"\"\"\n        super().__init__(llm, chat_ctx=chat_ctx, tools=tools, conn_options=conn_options)\n        self._response_text = response_text\n\n    async def _run(self) -> None:\n        \"\"\"Generate the fixed response by streaming it.\n\n        This simulates a realistic LLM response with a small delay for\n        time-to-first-token and then streams the complete response.\n        \"\"\"\n        # Simulate a small time-to-first-token delay\n        await asyncio.sleep(0.05)\n\n        # Stream the complete response in one chunk\n        self._send_chunk(delta=self._response_text)\n\n    def _send_chunk(self, *, delta: str | None = None) -> None:\n        \"\"\"Send a chat chunk with the given content delta.\n\n        Args:\n            delta: The text content to send in this chunk\n        \"\"\"\n        self._event_ch.send_nowait(\n            ChatChunk(\n                id=str(id(self)),\n                delta=ChoiceDelta(\n                    role=\"assistant\",\n                    content=delta,\n                    tool_calls=[],\n                ),\n            )\n        )\n","numLines":220,"startLine":1,"totalLines":220}},"sourceToolAssistantUUID":"90ebb7d1-8f5b-492e-9c1b-64c38248559c"}
{"parentUuid":"9e3e6aca-31a3-479a-95dd-96b4596d0eee","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KjSpAa9QYdZp4WnaHTAJcf","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Perfect! Now I see the pattern. The KeywordInterceptLLM is a pure wrapper - it:\n1. Wraps a base LLM\n2. Intercepts certain conditions\n3. Delegates to wrapped LLM or returns custom stream\n4. Does NOT manage state - it's stateless!\n\nThis confirms the user's concern. The DriveThruLLM should follow the same pattern - it should be a thin wrapper that:\n- Injects menu context into prompts\n- Wraps the base LLM\n- Maybe validates outputs\n- But NOT manage conversation state or order tracking\n\nLet me now think through clean boundaries:\n\n**DriveThruLLM**: \n- Wraps base LLM\n- Injects menu context dynamically into chat_ctx\n- That's it! Pure wrapper, no state.\n\n**OrderStateManager**:\n- Owns ALL order state (items, quantities, session info)\n- Handles persistence (incremental logs, final JSON)\n- Provides methods to add/remove/query order items\n- Single source of truth for order state\n\n**MenuProvider**:\n- Loads menu data\n- Searches/queries menu\n- Returns menu items/categories\n- Pure read-only service, no state mutation\n\n**MenuValidationTools** (or just `menu_validation.py`):\n- Pure functions for validation\n- Fuzzy matching\n- No state\n- Just helpers/utilities\n\n**DriveThruAgent**:\n- Orchestrates the conversation\n- Owns the OrderStateManager instance\n- Provides LLM functions/tools that delegate to OrderStateManager\n- Handles conversation flow\n- But doesn't manage state directly - tells OrderStateManager what to do\n\nActually, looking at the architecture more, I need to think about where the tools/functions live. In LiveKit Agents, tools are typically defined and passed to the LLM. Let me look at how the existing agent is structured.","signature":"EvMNCkYICxgCKkBBpDAe7IpGnyg+DdpPceQ7prx/zhUjVkhqx1eXI7ugfhcYbDHiIg4IgM2gWDYTsCQ+An+rh72ZXdsl8cnWJ8R/EgyVT2RT3ZX0LxhGfmwaDJjIXivQJtGfHSb0CSIwP9JLCK0jmCDLINHglBdLL7f/p7ao2BaGCAxLReHCZwjsYrXM0ut+wgnDo76GicmQKtoMBziwMQsBdLha+oF5lcp9ODSeUz3PmsjBb9KiVoCw8CnfnQVj+ZC4RFVII2Eu1IZVQ2h011pfUEDsRjv5xvqouUTsdJpQd1ZRIJl+yIRhZWgKxqK1fuFk8X1JCCYEcP9KJT0nxorQp+9EGcMqjCpuJ3OZXCBS3ljeI+PNpAKZw1cEkpsCOwTd0Tsc0PMIbvQbqSoZ0loGISpQMMOc2qlYELU1WqAi38V9VaNdYN6XIuLv9pGFDC8zIuwm2tanZOEVxOsQJNum/lQ2fMQHCia02nIosHXcSnsCe9/8uqZ9w1Oet16vOcm8+HHJR0jPOj6OiX20wkd56na9nXG8EWGYWqHDlkCDyJyVPf/BGXBNt/k8jQmV0DiGyBcSpuMg68DtR4xG5YlaYQzWyiNDty+/4pVBsnnjwbIHYUB4UtpJeBN53f3zfL75F1dp1oSbkVZaPYNWmASelXk4qEU1Y34LDVnymsngAr7uXunc22Dr+yaCsm1y5TDUhW8uDBSotqMRsZgh+z4n/GqXKaBNXvsvGdNNx3fTooI0j4WLeWxEuJNT8k/8PwaniAHq8IUDadRm/QuQ9yTLPiYpz1l1bv/cUSFREFTJE16D38EPieQLKmzNFi+fajq+oTdJnw0x9Iv8ZZCowW4SwJdt+8RPleV2/8pGu94j5wGeAsvATV2Z4GFjej/CjTstOxO6NDdjSn+0+nFRoTesatOq3XG9tDMAG8crxtTxGrley9v8Gn/ItGbFs2A4zlgYtROLk8pRqBbOlttmzpqfvipySP/gfyfzaUkctIvJYaKMEV1J7WU4Q6uqNkN9BtxsAvp2IvVQab7PABwPuZcukEJpDV1Jsw7zMWw/Zc5S5rJh6n0sbXFQ0xfCR5L6p9blU0Rgyv9xniRFEqa4epeSrJZAuzb/91Tn/SbyaetHLgxlIcAhM2uEy2Dlumpc71wqD/qsv4GFsDJK8DWTAZ9FIPTZocU+kap0bW/qEUc1hcQVvHFuMCtCSpmpiKISBvUymlPPCeX7hAMTXDUIbZGvwXs7lJ+9V/5BrIBURtO1MadFhdLyy1A97zIJwAjSWRE4MHsVTL2zc0etoVH6MIDJalclZWgQMWFnmjIkX9izBw4kTxO6YjweUY5GPEfcjsLbjxaLZ3Ie0ZQa2Fn1y5iwvekdusQV5HV2Kt1qlOOp9/gZv+feETiKquwVf50x3nI0MWCQxCadya8gNVvjltX9H8/IsFAc6a3H2SbqB43mjykgNjRDyCip8FBhGYM/Iy2JQkpX23YZl6vyIxoBe4MKiJuBGmVIzUOfviiCAjySFtfxWFVtYqZO7jaZptH8kYj3/RAePccGLKaaohnxDJM1eT7z4ERuTuk+YQ7uGydjUVbFn8W5WGS3ZQurbMc6HwjOtLlJHyEXyxq5yRGKuubT8GNAzqNdeWsCGsLAxvBom+bz9dyKxz1FkutY942G6n1KdSiNTQdunPCBC6AIAFOwiueqnRyxaBVs6y6iSjQ/gUlOc1fBQ45SD16tZ+CnOZfACPxm2bTwZjnNGUCIc28VP+3gi1BIg7tTrlcupG0wkHL5uHC6buKFMXGh13iNkO5Utzuc2J4AS/D03PBR2hm+OddP9BIUzag1xziYPqM5drhK3PMSPWdQzi8OP5SuXavAMpIxKBLG2UgQIFRauYiNE+JKQHvfh2tAuAKxzy2jTsNQcxj346LaIDVgvffYzlPiIGWf8ZvuAOTSzjMt8PkF3OCOfKYvArB46gzLvI1xZvow1sxAtwDxOt+giQPrQh37QHLnaUx3+XVyGGsMZuRvL3DZOsPYaoFgAIrcjKX1pbGpTQViQhg8alqa9jTwjRdU5PJbDU4cHPNRPLlbLkm2B5gjpkHVD7Pkm3JqIthQD12qjeQGbryrxHznKpgJyGG3NFguEt4OvLWSl6ElL9BZ5zmEVl0BXgCg5lTTDAqX3aJ36vs5vNTDLYCnw0LptGNEsAMJdJxSLP/N9O0Zm6z42GWxN+Dqb687BRpYjFDSEadqWy3sD6vnB1LRcBQHizxfno6aqXMNBEj4FSaFdGCrQKCx/aT61o/bGfdfq2Gj6N1G/kBMn335rAfQ9oOBtaIJ3cLR04qHlfpDm11tP0msrh/oo2dOyjYyKc1gi1j1K6CznvIE13uDrRE54NdriK43xf82GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":2914,"cache_read_input_tokens":38862,"cache_creation":{"ephemeral_5m_input_tokens":2914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPpRkLWtGhGPyqnGe1C","type":"assistant","uuid":"388f386e-a0d0-4793-b900-11d0beb4114a","timestamp":"2026-01-21T23:30:58.946Z"}
{"parentUuid":"388f386e-a0d0-4793-b900-11d0beb4114a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KjSpAa9QYdZp4WnaHTAJcf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KhHTdVGTDLjGnQTf4egmrb","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/agent.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":2914,"cache_read_input_tokens":38862,"cache_creation":{"ephemeral_5m_input_tokens":2914,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPpRkLWtGhGPyqnGe1C","type":"assistant","uuid":"929d2d5f-d3ce-4454-915b-0fdb5bfe2644","timestamp":"2026-01-21T23:30:59.954Z"}
{"parentUuid":"929d2d5f-d3ce-4454-915b-0fdb5bfe2644","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File does not exist.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01KhHTdVGTDLjGnQTf4egmrb"}]},"uuid":"fbe06cdb-0b31-4c18-86a0-6dba143b6cbe","timestamp":"2026-01-21T23:30:59.969Z","toolUseResult":"Error: File does not exist.","sourceToolAssistantUUID":"929d2d5f-d3ce-4454-915b-0fdb5bfe2644"}
{"parentUuid":"fbe06cdb-0b31-4c18-86a0-6dba143b6cbe","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016hg2J5YnGy4UZjb2rg9kHA","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me find the main agent file.","signature":"EsgBCkYICxgCKkDuJCm3n8HCYrr875Eofp5FLPnBuIcdvDxRsvD7z/i0U5z67g1+dc1/KDZ7HjXUVK45DebgAz/QXoHwos/0uZw6EgwZ8HLvvWT8/C0kW0UaDBhw0LPN/bTOYTms8yIw4/gye5PjoOuk876W5uf6SAL2YucNQOeALiesbTROThc0/+ilO9J+LZRI8VDZjeKdKjAnLQZU8k5Fmfdoyvc9DAf+Ovr1vGaaE7Qlk0eeVr9+F3TiXUwCH9vGnWOb1nnkxTQYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":545,"cache_read_input_tokens":41776,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPq7j9W8dJ8BPvyEtQ1","type":"assistant","uuid":"64d677e2-f996-452d-9d30-907a4663acb5","timestamp":"2026-01-21T23:31:01.194Z"}
{"parentUuid":"64d677e2-f996-452d-9d30-907a4663acb5","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016hg2J5YnGy4UZjb2rg9kHA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0127y9fZWLobPRHsCLGv6De5","name":"Glob","input":{"pattern":"src/*.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":545,"cache_read_input_tokens":41776,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPq7j9W8dJ8BPvyEtQ1","type":"assistant","uuid":"6053765a-0f34-4ba2-8cb2-a50fdf528881","timestamp":"2026-01-21T23:31:01.489Z"}
{"parentUuid":"6053765a-0f34-4ba2-8cb2-a50fdf528881","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0127y9fZWLobPRHsCLGv6De5","type":"tool_result","content":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/__init__.py\n/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/session_handler.py\n/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/app.py\n/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/config.py\n/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/factories.py\n/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/keyword_intercept_llm.py\n/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/mock_llm.py"}]},"uuid":"f57b69bb-4a36-4d1c-a124-928c3f08692e","timestamp":"2026-01-21T23:31:01.900Z","toolUseResult":{"filenames":["/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/__init__.py","/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/session_handler.py","/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/app.py","/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/config.py","/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/factories.py","/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/keyword_intercept_llm.py","/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/mock_llm.py"],"durationMs":362,"numFiles":7,"truncated":false},"sourceToolAssistantUUID":"6053765a-0f34-4ba2-8cb2-a50fdf528881"}
{"parentUuid":"f57b69bb-4a36-4d1c-a124-928c3f08692e","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01N5CYpE79c1ZtkM5cNgZgn7","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me read session_handler.py to see how the agent is structured currently.","signature":"EvQBCkYICxgCKkD6TZJ7fI4aLNeJSSEKUYLkV246KXH5DiUN/3Gj/VCHfEBznRjJBRZMgyN1FW7eDgz1axU/3syIAgxJiGIHiAfAEgxEV45tcrmq7a0OwQYaDASASAW76KVGdccTaSIw7oU56h3gz14LgxMpazB6tDAuwPua8NOtl5OvOhtTeF9WGS02+r4bnfAmmUfx15LJKly/LFLY8nT+1kkg9HtySsX4ZQKuzUXWtGo+A0i5A4i0rKEFVVi74iMR+VWNYY6df9+XAHZGNCcyS8+X/7nR202W9llU+SuhJ3GBAanGl8G7RyUumhgBy+z83M2qGBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":316,"cache_read_input_tokens":42321,"cache_creation":{"ephemeral_5m_input_tokens":316,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPqFzEsbRwmDKhUJrF1","type":"assistant","uuid":"46989a4c-b3ec-4f90-91a9-4c144251f759","timestamp":"2026-01-21T23:31:03.059Z"}
{"parentUuid":"46989a4c-b3ec-4f90-91a9-4c144251f759","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01N5CYpE79c1ZtkM5cNgZgn7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KuZeMPkcvAqc4HkW9PPARf","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/session_handler.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":316,"cache_read_input_tokens":42321,"cache_creation":{"ephemeral_5m_input_tokens":316,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPqFzEsbRwmDKhUJrF1","type":"assistant","uuid":"375b0a0b-6acb-48d2-aec8-fe4e438a7863","timestamp":"2026-01-21T23:31:03.382Z"}
{"parentUuid":"375b0a0b-6acb-48d2-aec8-fe4e438a7863","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KuZeMPkcvAqc4HkW9PPARf","type":"tool_result","content":"     1→\"\"\"Session handler for voice agent interactions.\n     2→\n     3→This module contains the SessionHandler class that manages agent sessions\n     4→with dependency-injected STT, LLM, and TTS components.\n     5→\"\"\"\n     6→\n     7→from livekit.agents import NOT_GIVEN, Agent, AgentSession, JobContext, room_io\n     8→from livekit.plugins import noise_cancellation\n     9→from livekit.plugins.turn_detector.multilingual import MultilingualModel\n    10→from loguru import logger\n    11→\n    12→from config import SessionConfig\n    13→\n    14→\n    15→class SessionHandler:\n    16→    \"\"\"Handles agent sessions with dependency-injected voice pipeline components.\n    17→\n    18→    This class encapsulates the session handling logic and receives STT, LLM, and TTS\n    19→    components through constructor injection, enabling testability and flexibility.\n    20→    \"\"\"\n    21→\n    22→    def __init__(\n    23→        self,\n    24→        stt,\n    25→        llm,\n    26→        tts,\n    27→        agent: Agent,\n    28→        session_config: SessionConfig,\n    29→    ):\n    30→        \"\"\"Initialize the session handler.\n    31→\n    32→        Args:\n    33→            stt: Speech-to-text adapter\n    34→            llm: Large language model adapter\n    35→            tts: Text-to-speech adapter\n    36→            agent: The agent instance to use for sessions\n    37→            session_config: Configuration for session management\n    38→        \"\"\"\n    39→        self.stt = stt\n    40→        self.llm = llm\n    41→        self.tts = tts\n    42→        self.agent = agent\n    43→        self.session_config = session_config\n    44→        logger.info(\"SessionHandler initialized\")\n    45→\n    46→    async def handle_session(self, ctx: JobContext) -> None:\n    47→        \"\"\"Handle an RTC session.\n    48→\n    49→        Args:\n    50→            ctx: Job context containing room and connection information\n    51→        \"\"\"\n    52→        # Logging setup\n    53→        ctx.log_context_fields = {\n    54→            \"room\": ctx.room.name,\n    55→        }\n    56→\n    57→        logger.info(f\"Starting session for room: {ctx.room.name}\")\n    58→\n    59→        logger.debug(\n    60→            f\"Using STT: {type(self.stt).__name__}, LLM: {type(self.llm).__name__}, TTS: {type(self.tts).__name__}\"\n    61→        )\n    62→\n    63→        # Set up the voice AI pipeline with injected components\n    64→        turn_detection = (\n    65→            MultilingualModel()\n    66→            if self.session_config.use_multilingual_turn_detector\n    67→            else NOT_GIVEN\n    68→        )\n    69→        vad = ctx.proc.userdata.get(\"vad\") or NOT_GIVEN\n    70→\n    71→        session = AgentSession(\n    72→            stt=self.stt,\n    73→            llm=self.llm,\n    74→            tts=self.tts,\n    75→            turn_detection=turn_detection,\n    76→            vad=vad,\n    77→            preemptive_generation=self.session_config.preemptive_generation,\n    78→        )\n    79→\n    80→        # Configure room options\n    81→        room_options = room_io.RoomOptions()\n    82→        if self.session_config.enable_noise_cancellation:\n    83→            room_options = room_io.RoomOptions(\n    84→                audio_input=room_io.AudioInputOptions(\n    85→                    noise_cancellation=noise_cancellation.BVC(),\n    86→                ),\n    87→            )\n    88→\n    89→        # Start the session\n    90→        await session.start(\n    91→            agent=self.agent,\n    92→            room=ctx.room,\n    93→            room_options=room_options,\n    94→        )\n    95→\n    96→        logger.info(\"Session started, connecting to room\")\n    97→\n    98→        # Join the room and connect to the user\n    99→        await ctx.connect()\n   100→\n   101→        logger.info(\"Connected to room successfully\")\n   102→\n   103→        # Greet the user when they join\n   104→        await session.say(\"Hello! How can I help you today?\")\n   105→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"6385e18f-6ed0-4edf-bf0f-6e3ad581916c","timestamp":"2026-01-21T23:31:03.429Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/session_handler.py","content":"\"\"\"Session handler for voice agent interactions.\n\nThis module contains the SessionHandler class that manages agent sessions\nwith dependency-injected STT, LLM, and TTS components.\n\"\"\"\n\nfrom livekit.agents import NOT_GIVEN, Agent, AgentSession, JobContext, room_io\nfrom livekit.plugins import noise_cancellation\nfrom livekit.plugins.turn_detector.multilingual import MultilingualModel\nfrom loguru import logger\n\nfrom config import SessionConfig\n\n\nclass SessionHandler:\n    \"\"\"Handles agent sessions with dependency-injected voice pipeline components.\n\n    This class encapsulates the session handling logic and receives STT, LLM, and TTS\n    components through constructor injection, enabling testability and flexibility.\n    \"\"\"\n\n    def __init__(\n        self,\n        stt,\n        llm,\n        tts,\n        agent: Agent,\n        session_config: SessionConfig,\n    ):\n        \"\"\"Initialize the session handler.\n\n        Args:\n            stt: Speech-to-text adapter\n            llm: Large language model adapter\n            tts: Text-to-speech adapter\n            agent: The agent instance to use for sessions\n            session_config: Configuration for session management\n        \"\"\"\n        self.stt = stt\n        self.llm = llm\n        self.tts = tts\n        self.agent = agent\n        self.session_config = session_config\n        logger.info(\"SessionHandler initialized\")\n\n    async def handle_session(self, ctx: JobContext) -> None:\n        \"\"\"Handle an RTC session.\n\n        Args:\n            ctx: Job context containing room and connection information\n        \"\"\"\n        # Logging setup\n        ctx.log_context_fields = {\n            \"room\": ctx.room.name,\n        }\n\n        logger.info(f\"Starting session for room: {ctx.room.name}\")\n\n        logger.debug(\n            f\"Using STT: {type(self.stt).__name__}, LLM: {type(self.llm).__name__}, TTS: {type(self.tts).__name__}\"\n        )\n\n        # Set up the voice AI pipeline with injected components\n        turn_detection = (\n            MultilingualModel()\n            if self.session_config.use_multilingual_turn_detector\n            else NOT_GIVEN\n        )\n        vad = ctx.proc.userdata.get(\"vad\") or NOT_GIVEN\n\n        session = AgentSession(\n            stt=self.stt,\n            llm=self.llm,\n            tts=self.tts,\n            turn_detection=turn_detection,\n            vad=vad,\n            preemptive_generation=self.session_config.preemptive_generation,\n        )\n\n        # Configure room options\n        room_options = room_io.RoomOptions()\n        if self.session_config.enable_noise_cancellation:\n            room_options = room_io.RoomOptions(\n                audio_input=room_io.AudioInputOptions(\n                    noise_cancellation=noise_cancellation.BVC(),\n                ),\n            )\n\n        # Start the session\n        await session.start(\n            agent=self.agent,\n            room=ctx.room,\n            room_options=room_options,\n        )\n\n        logger.info(\"Session started, connecting to room\")\n\n        # Join the room and connect to the user\n        await ctx.connect()\n\n        logger.info(\"Connected to room successfully\")\n\n        # Greet the user when they join\n        await session.say(\"Hello! How can I help you today?\")\n","numLines":105,"startLine":1,"totalLines":105}},"sourceToolAssistantUUID":"375b0a0b-6acb-48d2-aec8-fe4e438a7863"}
{"parentUuid":"6385e18f-6ed0-4edf-bf0f-6e3ad581916c","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SKvjA3xTvZ6LHRRdXeD9iL","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, now let me check if there's an Agent definition somewhere to see how tools are typically defined.","signature":"Eo8CCkYICxgCKkCpyqVFz+ZwEk/DYHUiNZvfshcY1ewZbyKaF7YNYRbEykSfuN73IOIMSp9aLXGQuK1eAygxmGKgmL6SJnarbkhdEgxd9IkVWbxt590QoL0aDHVZaoHr2mYE17OxICIw8mpawBn/RiMQernF9QROVANK3aJibO84ho9scPCMrbPG8oSMDG5VHVaigIpiuB1yKncgnIU9j5UH20VC0noGjYVe4K8G/9o6E5zRUgz9mKG+SwFi0mLWICX20EhecQFyNG952/h2MMHkccjr8XNiH56/9wrIC9vswfOZSE5oMeWM/bOycD6LXN0kxxG9m1F4Lih7vC8B5914kj7C02h4ZjOjZhSmwL9W3RgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1385,"cache_read_input_tokens":42637,"cache_creation":{"ephemeral_5m_input_tokens":1385,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPqNYdXYqbZp1si6MpU","type":"assistant","uuid":"ae894585-86a1-4cc1-ad64-0db0a6d05aad","timestamp":"2026-01-21T23:31:05.206Z"}
{"parentUuid":"ae894585-86a1-4cc1-ad64-0db0a6d05aad","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SKvjA3xTvZ6LHRRdXeD9iL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WXngV8QgfCHjhBxYkGVTNZ","name":"Grep","input":{"pattern":"class.*Agent","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1385,"cache_read_input_tokens":42637,"cache_creation":{"ephemeral_5m_input_tokens":1385,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPqNYdXYqbZp1si6MpU","type":"assistant","uuid":"5c479f98-bca1-455d-a164-fd650980e54a","timestamp":"2026-01-21T23:31:05.789Z"}
{"parentUuid":"5c479f98-bca1-455d-a164-fd650980e54a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WXngV8QgfCHjhBxYkGVTNZ","type":"tool_result","content":"Found 2 files\nsrc/app.py\nsrc/config.py"}]},"uuid":"80980403-9e9c-411d-a18f-e10fda5e15c2","timestamp":"2026-01-21T23:31:06.173Z","toolUseResult":{"mode":"files_with_matches","filenames":["src/app.py","src/config.py"],"numFiles":2},"sourceToolAssistantUUID":"5c479f98-bca1-455d-a164-fd650980e54a"}
{"parentUuid":"80980403-9e9c-411d-a18f-e10fda5e15c2","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Ec6zCTCA7fZPH6T8a9gRCs","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me check app.py to see how the agent is defined.","signature":"EtwBCkYICxgCKkDFXTOyXJzxZmy54lv6l07VvlUSNM+kMt+PrLkiNeN7s8iMQ9heLlhItWjp+75BHeQ1A912jDuMWihkEBpZ73/tEgwYBrFuIBywfxUXf0saDHRxBba6PWIcMWy+/SIwt8/PR3I1LGceYhJxMrqfBSDgFv3KXAbaFQX5gU29rrFZwxHJpS5JbBQDEhIxBE9eKkRXGyOejpFH63oWSTRm+J/Dt0W4JyxROnuZ9096k/feiD6onep64cTBQR38Cy9qExfHj4VrsBzzWmAuzMN6Ovunfzng6xgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":142,"cache_read_input_tokens":44022,"cache_creation":{"ephemeral_5m_input_tokens":142,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPqaFLLgwkdfFNELh8Y","type":"assistant","uuid":"ea9d2193-97c0-4253-b359-1e26dc731064","timestamp":"2026-01-21T23:31:07.525Z"}
{"parentUuid":"ea9d2193-97c0-4253-b359-1e26dc731064","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Ec6zCTCA7fZPH6T8a9gRCs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016jofUqProEVkAhVAtLDS37","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/app.py"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":142,"cache_read_input_tokens":44022,"cache_creation":{"ephemeral_5m_input_tokens":142,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPqaFLLgwkdfFNELh8Y","type":"assistant","uuid":"4c38cfaa-96c0-4aa6-a456-e3a9eb9a2ad8","timestamp":"2026-01-21T23:31:08.452Z"}
{"parentUuid":"4c38cfaa-96c0-4aa6-a456-e3a9eb9a2ad8","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016jofUqProEVkAhVAtLDS37","type":"tool_result","content":"     1→\"\"\"Voice agent application with dependency injection.\n     2→\n     3→This module contains the main application class and agent implementation,\n     4→refactored to use dependency injection for STT, LLM, and TTS components.\n     5→\"\"\"\n     6→\n     7→from dotenv import load_dotenv\n     8→from livekit.agents import Agent, AgentServer, JobProcess, cli\n     9→from livekit.plugins import silero\n    10→from loguru import logger\n    11→\n    12→from config import AppConfig, PipelineConfig\n    13→from factories import create_llm, create_stt, create_tts\n    14→from session_handler import SessionHandler\n    15→\n    16→load_dotenv(\".env.local\")\n    17→\n    18→\n    19→class Assistant(Agent):\n    20→    \"\"\"The voice AI assistant agent.\"\"\"\n    21→\n    22→    def __init__(self, instructions: str | None = None) -> None:\n    23→        \"\"\"Initialize the assistant.\n    24→\n    25→        Args:\n    26→            instructions: System instructions for the agent. If None, uses default instructions.\n    27→        \"\"\"\n    28→        default_instructions = \"\"\"You are a helpful voice AI assistant. The user is interacting with you via voice, even if you perceive the conversation as text.\n    29→You eagerly assist users with their questions by providing information from your extensive knowledge.\n    30→Your responses are concise, to the point, and without any complex formatting or punctuation including emojis, asterisks, or other symbols.\n    31→You are curious, friendly, and have a sense of humor.\"\"\"\n    32→\n    33→        super().__init__(\n    34→            instructions=instructions or default_instructions,\n    35→        )\n    36→\n    37→\n    38→class VoiceAgentApp:\n    39→    \"\"\"Voice agent application with dependency injection.\n    40→\n    41→    This class encapsulates the voice agent application and uses dependency injection\n    42→    to provide STT, LLM, and TTS components, enabling testability and flexibility.\n    43→    \"\"\"\n    44→\n    45→    def __init__(self, config: AppConfig | None = None):\n    46→        \"\"\"Initialize the voice agent application.\n    47→\n    48→        Args:\n    49→            config: Application configuration. If None, loads from environment.\n    50→        \"\"\"\n    51→        # Load configuration\n    52→        self.config = config or AppConfig()\n    53→\n    54→        self.stt = create_stt(self.config.pipeline)\n    55→        self.llm = create_llm(self.config.pipeline)\n    56→        self.tts = create_tts(self.config.pipeline)\n    57→\n    58→        # Create agent\n    59→        self.agent = Assistant(instructions=self.config.agent.instructions)\n    60→\n    61→        # Create session handler with injected dependencies\n    62→        self.session_handler = SessionHandler(\n    63→            stt=self.stt,\n    64→            llm=self.llm,\n    65→            tts=self.tts,\n    66→            agent=self.agent,\n    67→            session_config=self.config.session,\n    68→        )\n    69→\n    70→        # Set up server\n    71→        self.server = AgentServer()\n    72→        self._setup_server()\n    73→\n    74→        logger.info(\"VoiceAgentApp initialized\")\n    75→\n    76→    def _setup_server(self):\n    77→        \"\"\"Configure the server with prewarm and session handler.\"\"\"\n    78→        self.server.setup_fnc = self._prewarm\n    79→        self.server.rtc_session()(self.session_handler.handle_session)\n    80→\n    81→    @staticmethod\n    82→    def _prewarm(proc: JobProcess):\n    83→        \"\"\"Prewarm function for loading VAD model.\"\"\"\n    84→        proc.userdata[\"vad\"] = silero.VAD.load()\n    85→\n    86→    def run(self):\n    87→        \"\"\"Run the application.\"\"\"\n    88→        logger.info(\"Starting voice agent application\")\n    89→        cli.run_app(self.server)\n    90→\n    91→\n    92→if __name__ == \"__main__\":\n    93→    config = AppConfig(\n    94→        pipeline=PipelineConfig(\n    95→            llm_model=\"mock\",\n    96→            enable_keyword_intercept=True,\n    97→        )\n    98→    )\n    99→    app = VoiceAgentApp(config=config)\n   100→    app.run()\n   101→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7e17a681-788d-41c7-a218-8df140c7e754","timestamp":"2026-01-21T23:31:08.501Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/src/app.py","content":"\"\"\"Voice agent application with dependency injection.\n\nThis module contains the main application class and agent implementation,\nrefactored to use dependency injection for STT, LLM, and TTS components.\n\"\"\"\n\nfrom dotenv import load_dotenv\nfrom livekit.agents import Agent, AgentServer, JobProcess, cli\nfrom livekit.plugins import silero\nfrom loguru import logger\n\nfrom config import AppConfig, PipelineConfig\nfrom factories import create_llm, create_stt, create_tts\nfrom session_handler import SessionHandler\n\nload_dotenv(\".env.local\")\n\n\nclass Assistant(Agent):\n    \"\"\"The voice AI assistant agent.\"\"\"\n\n    def __init__(self, instructions: str | None = None) -> None:\n        \"\"\"Initialize the assistant.\n\n        Args:\n            instructions: System instructions for the agent. If None, uses default instructions.\n        \"\"\"\n        default_instructions = \"\"\"You are a helpful voice AI assistant. The user is interacting with you via voice, even if you perceive the conversation as text.\nYou eagerly assist users with their questions by providing information from your extensive knowledge.\nYour responses are concise, to the point, and without any complex formatting or punctuation including emojis, asterisks, or other symbols.\nYou are curious, friendly, and have a sense of humor.\"\"\"\n\n        super().__init__(\n            instructions=instructions or default_instructions,\n        )\n\n\nclass VoiceAgentApp:\n    \"\"\"Voice agent application with dependency injection.\n\n    This class encapsulates the voice agent application and uses dependency injection\n    to provide STT, LLM, and TTS components, enabling testability and flexibility.\n    \"\"\"\n\n    def __init__(self, config: AppConfig | None = None):\n        \"\"\"Initialize the voice agent application.\n\n        Args:\n            config: Application configuration. If None, loads from environment.\n        \"\"\"\n        # Load configuration\n        self.config = config or AppConfig()\n\n        self.stt = create_stt(self.config.pipeline)\n        self.llm = create_llm(self.config.pipeline)\n        self.tts = create_tts(self.config.pipeline)\n\n        # Create agent\n        self.agent = Assistant(instructions=self.config.agent.instructions)\n\n        # Create session handler with injected dependencies\n        self.session_handler = SessionHandler(\n            stt=self.stt,\n            llm=self.llm,\n            tts=self.tts,\n            agent=self.agent,\n            session_config=self.config.session,\n        )\n\n        # Set up server\n        self.server = AgentServer()\n        self._setup_server()\n\n        logger.info(\"VoiceAgentApp initialized\")\n\n    def _setup_server(self):\n        \"\"\"Configure the server with prewarm and session handler.\"\"\"\n        self.server.setup_fnc = self._prewarm\n        self.server.rtc_session()(self.session_handler.handle_session)\n\n    @staticmethod\n    def _prewarm(proc: JobProcess):\n        \"\"\"Prewarm function for loading VAD model.\"\"\"\n        proc.userdata[\"vad\"] = silero.VAD.load()\n\n    def run(self):\n        \"\"\"Run the application.\"\"\"\n        logger.info(\"Starting voice agent application\")\n        cli.run_app(self.server)\n\n\nif __name__ == \"__main__\":\n    config = AppConfig(\n        pipeline=PipelineConfig(\n            llm_model=\"mock\",\n            enable_keyword_intercept=True,\n        )\n    )\n    app = VoiceAgentApp(config=config)\n    app.run()\n","numLines":101,"startLine":1,"totalLines":101}},"sourceToolAssistantUUID":"4c38cfaa-96c0-4aa6-a456-e3a9eb9a2ad8"}
{"parentUuid":"7e17a681-788d-41c7-a218-8df140c7e754","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Gc3iFDBpiGntQaHp7Bv4Lx","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Perfect! Now I have a good understanding of the architecture. The Agent class is where instructions live, and it can have tools defined. Let me now create a comprehensive revision of the plan with sharp boundaries.\n\nBased on what I've learned:\n\n1. **DriveThruLLM** should be like KeywordInterceptLLM - a pure, stateless wrapper that:\n   - Intercepts chat() calls\n   - Injects menu context into chat_ctx dynamically\n   - Delegates to wrapped LLM\n   - NO STATE MANAGEMENT\n\n2. **OrderStateManager** should be the ONLY owner of order state:\n   - Owns order items\n   - Handles persistence\n   - Provides query/modification methods\n   - Single source of truth\n\n3. **MenuProvider** should be a pure read-only service:\n   - Loads menu data\n   - Searches/queries menu\n   - No state (or immutable state)\n   - Just a menu database\n\n4. **MenuValidationTools** should be pure functions:\n   - Fuzzy matching\n   - Validation logic\n   - No state\n   - Utility helpers\n\n5. **DriveThruAgent** should:\n   - Define instructions/persona\n   - Define tools that delegate to OrderStateManager\n   - Orchestrate conversation flow\n   - Own the OrderStateManager instance (via composition)\n\n6. **OrderTools** (new concept):\n   - LiveKit Tool definitions\n   - Thin wrappers that call OrderStateManager methods\n   - Function schemas for LLM function calling\n\nLet me now write a comprehensive revision of the plan, making sure to be like Kent Beck and Dave Farley - clear responsibilities, testable boundaries, simple design.","signature":"EuIMCkYICxgCKkDCxr2ity3lKEBdwJzv9bPiEgVd/cJlfbeIpJ49PtG5jgm7J9/48swb7j3zsAtaRT7bmckNVCdoCaqR0dIflPOcEgzwnOR7fcxIXjmRSQ0aDMg52sSpXOsHre20tCIwMZFoUa1QXh5dDwLLAYQ78RsCewt20mPKR55TjfZ/IILfyC2PNDf56k69ISspgbREKskL8xTgUcWmJnKMfqYzn61bKous3dzp3nhG+0RPbExZK0w2RRipOUzIinl93hYHplP/6rw4RE2rdze5xZ51wbkkG+E7aDKy0QjIm+n7E+A262kaNLSyjTYzOn4/Qk1TGYLN8umJN/U62Y/kXCS/4Hd3Q9Br3+ZQoz3yBbVuYYyV8TI9JqnOXtwk7hqawiKMgsLDvpFTDOCD/iy4zzFKKyT8TjZy8xohj/o3rddOEQ3XQs4PF55FeQO5iuIDQDJJfph1rSxf3eR9Tj8iZZXqWma3rVart1m6Rx603A8sUW5XFHOAxz7vWFLTgqrBx3fDSc+A4xH5PqgBAmPMrbD//mXo8FOVxubE2gUcZ76RvrZ9D6QMy4A7SkckUl/mCQFA9hHjpP0GS6yTlKJgn9Qr6+QTK6uKB8I539tCkZWT4CppHuBiKAx5ZlqkQnoawtvZMpMAX7K6c5s8KYt18oOQPQ88b9jkqCWQ/onXeqQG+IfIbgA38hiZ7yGv+b1gGA9Is3/JJJyOmeze8pKxVqhZN3xD5C7dZjyF/f9J1ALNwX7gn9LT3h3Qcp9N/TSgEhLbwRGTYmXgZgXet9cRCWv1+qpMXUyVoApf8Cxb2AxBVwdHvp3aV9GKlFggvVyIyOZLxL5V0M6o8zxOI1S+lGSNan2OjUeOFTZ4iibBzDvgv2HMiD+aFY33Ex5foMM1E0UbXLXArvF0ER80a173omOHizg0Vpfor8n3zkW1pTm9NzNPQrNORmV3oyr5k0B2RVsmd/r4X3mtMhyWQH48jGkxHkeISiwEQVZ8r7LtpEezl/Dh8kAMMYMY2DFRoWFaeYKyO7lkywX9muJ4JjGwvykDkl8aaSE2Dl7kSLD0+X/AdRFp5YsXiWgiPr+mmXERDQl++lbi4x9AXdUCJ4ic+dd+KIXJRZe9PK0DOlJsLRuR7DjJ9YgNokMdHwj1NuJ1cpDKTkRLvNrW2gP4v1iBuMW4b6i0LsRNJaR098CBr9IAQoR3BetXLHT7CvDwLTh2WUJWgERssN9oe7njEHUTKssJIl3bwsENYLOJdU4dtbpq+vxXLGDYnu4VeBkBG8b6XRVy6+TQP6dlPHYjTeJBiQeQeH+wsXn7YNxSDnR4qHT7sNQ/Ug4EMy+5ZyyPWBCTlWP8emYrw0+RkeA2kKiWr+926dW0wZqjaLhaEUhiyFg1tc2BXLTKkDuVKWm5vQc21XY3ItyeOsF0Ef8YGxbvRjN3Y63O7ZO9RtwFsOodgtSlo6FtowNT1LT3v3nRHGWQvHRct4yQp6sj417nenIGgScfkgE5nD5mV/Lbp36KJ8uBP+LQmgc1Pmex8ah/eldKG6lQC4Ad/K7qdCJETnc+vPeAc12DpazZ0f7YV2oOR5ftweU15XMTuSOSxZvBJ3EQ4/fYLvf+cAXznac4kvguXJmgLPE02m71ZBAcdvcGtrr6xtFNLvZte+5UQv6AoOcvW6DoDnAGlq8uwUm+MHSQPqL6zmHz6tIdJve8UO9UkSwioPo0oqotwdeE0tP6W4RHQLF7IJdDfirTyul69XlUlhhqA0Fr66Daxw5H+2pEKMWV3heOVl94Uri2Xl/4pzw95GOQJR05BAf4WfI4FB+wpwAGkMLJFRE4JVynpi2LgMYzGaDB15wDUv8ieH2CZe4lxboD6Lg/cys1ii0f3W5dvc035ydL2/YA3ZpYt+oPumcetbQIJUvUtdBaCT1sMtoL60Lwf4gkm1Kp6PgGRB+9taAiEDxJsHGzyJ/3uDi/7bHYhyEDQpfed4qYxlCDacrEnQZJ7pfRbYSg3LXmkyGmPD1bvdbjo3Uw4wGDtxtp6i59sJZVRz5quYWyrRxjdYIwbfqwt7voRzjcsDW9Arm9S0ntfE5DSLbQC/H81GBDpHzAOmLvJipGyNslbz/ODTZb3Bpjl9T3Jt18cm6Pe6xdpnlsEL/YnmT1kQ78KSkbzydVkvcgWGiE8gwatxrEZIsYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1381,"cache_read_input_tokens":44164,"cache_creation":{"ephemeral_5m_input_tokens":1381,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPqkErTQJQjYvsY4yCA","type":"assistant","uuid":"ee7294db-5660-4378-bf6f-a2e1d11ad24e","timestamp":"2026-01-21T23:31:16.176Z"}
{"parentUuid":"ee7294db-5660-4378-bf6f-a2e1d11ad24e","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Gc3iFDBpiGntQaHp7Bv4Lx","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll analyze the plan through the lens of Kent Beck (Simple Design, XP) and Dave Farley (Continuous Delivery, modularity). Let me create a todo list and then revise the plan with sharp boundaries."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1381,"cache_read_input_tokens":44164,"cache_creation":{"ephemeral_5m_input_tokens":1381,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPqkErTQJQjYvsY4yCA","type":"assistant","uuid":"5efe046f-0fc9-49c9-9bb4-08cecb3c157e","timestamp":"2026-01-21T23:31:16.991Z"}
{"parentUuid":"5efe046f-0fc9-49c9-9bb4-08cecb3c157e","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Gc3iFDBpiGntQaHp7Bv4Lx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LN2Ty62V1Ms3BUnFz2g1km","name":"TodoWrite","input":{"todos":[{"content":"Review plan for separation of concerns violations","activeForm":"Reviewing plan for separation of concerns violations","status":"in_progress"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","activeForm":"Redefining DriveThruLLM as pure wrapper","status":"pending"},{"content":"Clarify OrderStateManager as single source of truth for state","activeForm":"Clarifying OrderStateManager responsibilities","status":"pending"},{"content":"Define MenuProvider as pure read-only service","activeForm":"Defining MenuProvider responsibilities","status":"pending"},{"content":"Separate menu_validation.py into pure functions","activeForm":"Separating menu_validation into pure functions","status":"pending"},{"content":"Update architecture diagram with clean boundaries","activeForm":"Updating architecture diagram","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":1381,"cache_read_input_tokens":44164,"cache_creation":{"ephemeral_5m_input_tokens":1381,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPqkErTQJQjYvsY4yCA","type":"assistant","uuid":"a16ba3d8-42db-4343-b032-81809c14d71f","timestamp":"2026-01-21T23:31:19.719Z"}
{"parentUuid":"a16ba3d8-42db-4343-b032-81809c14d71f","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LN2Ty62V1Ms3BUnFz2g1km","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"16a68428-724c-4455-ac42-22bd0df163fe","timestamp":"2026-01-21T23:31:19.765Z","toolUseResult":{"oldTodos":[],"newTodos":[{"content":"Review plan for separation of concerns violations","status":"in_progress","activeForm":"Reviewing plan for separation of concerns violations"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","status":"pending","activeForm":"Redefining DriveThruLLM as pure wrapper"},{"content":"Clarify OrderStateManager as single source of truth for state","status":"pending","activeForm":"Clarifying OrderStateManager responsibilities"},{"content":"Define MenuProvider as pure read-only service","status":"pending","activeForm":"Defining MenuProvider responsibilities"},{"content":"Separate menu_validation.py into pure functions","status":"pending","activeForm":"Separating menu_validation into pure functions"},{"content":"Update architecture diagram with clean boundaries","status":"pending","activeForm":"Updating architecture diagram"}]},"sourceToolAssistantUUID":"a16ba3d8-42db-4343-b032-81809c14d71f"}
{"parentUuid":"16a68428-724c-4455-ac42-22bd0df163fe","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BhKLe9j2LrZ8eqmkashsVg","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, now let me write a comprehensive revision. I'll be very clear about what each component does and doesn't do, following these principles:1. Single Responsibility Principle (SRP)\n2. Tell, Don't Ask\n3. High cohesion, low coupling\n4. Each component should have one reason to change\n5. Clear contracts/interfaces6. Testability in isolation\n\nLet me now edit the plan systematically.","signature":"EqMECkYICxgCKkAJbs37V8XlcZDpO3kGLJar2orKOQyUt7ZLz4EPluDlAwuy9HQ3O/LNpOHlHdc25o/hulmUaC7fHzV+DRZWNVu8Egyr2qXOUtkKdHBHYYcaDBR4Mspxdmi/nPJmkSIwwtFy5fOAaVyuKF3MOflZl1ZD0k8ICskn7Q6MBpa0YWXI/f2pZb7FnfVFaAe2zZVQKooD4TNdSBsXvCbANS/mTqCiQRn+8WjYmGo7adsXI0IDKA7btMPdQFoLtzTSe2ZkqZvgaeq/HNCBXAND8wkO+SVQSLvDuSEV1UpXg375tGseI3pDhe9flgcDd7kBsZ2NAUaipQzR+TupcugnZ9FVJGxWmQdb6q3fVQ1rn30gD25xeud9Oq91uC7CHNpyyyIvHtESH8RfwWySFJXyeJECoS/vLO6DaCotwHvjg0ooxbYoZttYmO65cjAcoznQJ44m+vm6NKIjxtaJhsmAAvFYeZzxpGdPDNTB9R/FWmqvDo3l7EzU5pnH4lmfW2fxZTHI+xZPIeR9lUDkGitZzqOHEyaHGDDpmnlunP0uV6MJUWEvjd1G3yAeZywL2+6WU8fMjat9AK7B+07lACSxHkDlaesdziRn0fdPQArXA+N12me3DSCfHONrY+fehm1w+8c4C6rQQ8OrQzEKE3PNaS9rlRm87LWhuK01+CSiqLb/oAVFLckoOXOYk4kKNEChbe89pSyCZG3YwLkUOVP2XRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":742,"cache_read_input_tokens":45545,"cache_creation":{"ephemeral_5m_input_tokens":742,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPraQYMU5NGKVnSUQzr","type":"assistant","uuid":"04d7219b-fa46-4890-870c-c07eef0177dd","timestamp":"2026-01-21T23:31:22.245Z"}
{"parentUuid":"04d7219b-fa46-4890-870c-c07eef0177dd","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BhKLe9j2LrZ8eqmkashsVg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UN7v9hVgYwGTcjfCYee22P","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### 1.2 New Components to Build\n\n1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n   - Wraps a base LLM with order-taking capabilities\n   - Manages conversation state and order tracking\n\n2. **MenuProvider** (`src/menu_provider.py`)\n   - Loads and manages menu data using existing Pydantic models\n   - Provides relevant menu context to LLM\n   - Implements fuzzy matching and search\n\n3. **OrderStateManager** (`src/order_state_manager.py`)\n   - Tracks items ordered during conversation\n   - Appends to incremental log file after each turn\n   - Generates final JSON output with timestamp\n\n4. **MenuValidationTools** (`src/menu_validation.py`)\n   - Validates LLM output against menu items\n   - Fuzzy matching for spoken variations\n   - Modifier validation\n\n5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   - Custom Agent subclass with drive-thru specific instructions\n   - Configures the drive-thru persona","new_string":"### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":12,"cache_creation_input_tokens":742,"cache_read_input_tokens":45545,"cache_creation":{"ephemeral_5m_input_tokens":742,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPraQYMU5NGKVnSUQzr","type":"assistant","uuid":"2de6f954-3daf-4d89-a70d-0eb69df3e5ba","timestamp":"2026-01-21T23:31:39.778Z"}
{"parentUuid":"2de6f954-3daf-4d89-a70d-0eb69df3e5ba","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UN7v9hVgYwGTcjfCYee22P","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"794b54eb-7f22-4a0b-8afa-e19f8d21eb40","timestamp":"2026-01-21T23:31:39.830Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### 1.2 New Components to Build\n\n1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n   - Wraps a base LLM with order-taking capabilities\n   - Manages conversation state and order tracking\n\n2. **MenuProvider** (`src/menu_provider.py`)\n   - Loads and manages menu data using existing Pydantic models\n   - Provides relevant menu context to LLM\n   - Implements fuzzy matching and search\n\n3. **OrderStateManager** (`src/order_state_manager.py`)\n   - Tracks items ordered during conversation\n   - Appends to incremental log file after each turn\n   - Generates final JSON output with timestamp\n\n4. **MenuValidationTools** (`src/menu_validation.py`)\n   - Validates LLM output against menu items\n   - Fuzzy matching for spoken variations\n   - Modifier validation\n\n5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   - Custom Agent subclass with drive-thru specific instructions\n   - Configures the drive-thru persona","newString":"### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[Custom DriveThruLLM Wrapper]\n    ├─ Menu Context Provider\n    ├─ Order State Manager\n    ├─ Validation Layer\n    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Response\n```\n\n### 1.2 New Components to Build\n\n1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)\n   - Wraps a base LLM with order-taking capabilities\n   - Manages conversation state and order tracking\n\n2. **MenuProvider** (`src/menu_provider.py`)\n   - Loads and manages menu data using existing Pydantic models\n   - Provides relevant menu context to LLM\n   - Implements fuzzy matching and search\n\n3. **OrderStateManager** (`src/order_state_manager.py`)\n   - Tracks items ordered during conversation\n   - Appends to incremental log file after each turn\n   - Generates final JSON output with timestamp\n\n4. **MenuValidationTools** (`src/menu_validation.py`)\n   - Validates LLM output against menu items\n   - Fuzzy matching for spoken variations\n   - Modifier validation\n\n5. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   - Custom Agent subclass with drive-thru specific instructions\n   - Configures the drive-thru persona\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":34,"oldLines":32,"newStart":34,"newLines":110,"lines":[" "," ### 1.2 New Components to Build"," ","-1. **DriveThruLLM** (`src/drive_thru_llm.py`)","-   - Custom LLM wrapper (similar to `KeywordInterceptLLM`)","-   - Wraps a base LLM with order-taking capabilities","-   - Manages conversation state and order tracking","+Each component has a single, well-defined responsibility following the Single Responsibility Principle."," ","-2. **MenuProvider** (`src/menu_provider.py`)","-   - Loads and manages menu data using existing Pydantic models","-   - Provides relevant menu context to LLM","-   - Implements fuzzy matching and search","+#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)","+**Responsibility**: Pure LLM wrapper - context injection only","+**Does**:","+- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)","+- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`","+- Delegates to wrapped LLM","+- Returns LLM stream"," ","-3. **OrderStateManager** (`src/order_state_manager.py`)","-   - Tracks items ordered during conversation","-   - Appends to incremental log file after each turn","-   - Generates final JSON output with timestamp","+**Does NOT**:","+- Manage order state (that's `OrderStateManager`)","+- Store any state (stateless wrapper)","+- Validate menu items (that's `menu_validation.py`)","+- Perform searches (that's `MenuProvider`)"," ","-4. **MenuValidationTools** (`src/menu_validation.py`)","-   - Validates LLM output against menu items","-   - Fuzzy matching for spoken variations","-   - Modifier validation","+**Why**: Separation of concerns - LLM wrapping is orthogonal to state management"," ","-5. **DriveThruAgent** (`src/drive_thru_agent.py`)","-   - Custom Agent subclass with drive-thru specific instructions","-   - Configures the drive-thru persona","+---"," ","+#### 2. **MenuProvider** (`src/menu_provider.py`)","+**Responsibility**: Read-only menu data access","+**Does**:","+- Loads menu data from JSON using existing Pydantic models","+- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`","+- Returns menu data structures (immutable)","+","+**Does NOT**:","+- Modify menu data (read-only)","+- Validate orders (that's `menu_validation.py`)","+- Manage order state (that's `OrderStateManager`)","+- Fuzzy match (that's `menu_validation.py`)","+","+**Why**: Single source of truth for menu data, but purely a data provider","+"," ---"," ","+#### 3. **OrderStateManager** (`src/order_state_manager.py`)","+**Responsibility**: Single source of truth for order state and persistence","+**Does**:","+- Owns ALL order state (items, quantities, session info)","+- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`","+- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`","+- Handles persistence: incremental log (append after each operation), final JSON (on complete)","+- Manages session lifecycle","+","+**Does NOT**:","+- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)","+- Search menu (that's `MenuProvider`)","+- Make decisions (it's told what to do)","+","+**Why**: All state changes go through one place - testable, debuggable, single source of truth","+","+---","+","+#### 4. **menu_validation.py** (`src/menu_validation.py`)","+**Responsibility**: Pure validation and matching functions","+**Does**:","+- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`","+- Fuzzy string matching using `rapidfuzz`","+- Returns validation results (success/failure with details)","+","+**Does NOT**:","+- Store state (pure functions only)","+- Load menu data (receives menu data as parameter)","+- Modify orders (just validates, doesn't change state)","+","+**Why**: Pure functions are maximally testable and reusable","+","+---","+","+#### 5. **OrderTools** (`src/tools/order_tools.py`)","+**Responsibility**: LiveKit Tool definitions for LLM function calling","+**Does**:","+- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)","+- Defines `complete_order` tool","+- Thin wrappers that orchestrate: validate → add to order state → return result","+- Receives `OrderStateManager` and `MenuProvider` as dependencies","+","+**Does NOT**:","+- Own state (receives OrderStateManager)","+- Implement validation logic (calls menu_validation.py)","+","+**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic","+","+---","+","+#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)","+**Responsibility**: Agent orchestration and configuration","+**Does**:","+- Defines agent instructions/persona (system prompt)","+- Owns `OrderStateManager` instance (via composition)","+- Registers tools with agent (passing OrderStateManager as dependency)","+- Coordinates conversation flow","+","+**Does NOT**:","+- Manage state directly (delegates to OrderStateManager)","+- Validate items (delegates to validation layer via tools)","+- Load menu (receives MenuProvider as dependency)","+","+**Why**: Agent is the conductor - it orchestrates but delegates actual work","+","+---","+"," ## 2. Accuracy-Boosting Strategies"," "," ### Priority 1: Core Strategies (Implement First)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"2de6f954-3daf-4d89-a70d-0eb69df3e5ba"}
{"parentUuid":"794b54eb-7f22-4a0b-8afa-e19f8d21eb40","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017fq6LZ5aFKi8TUdbFHS9gg","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good! Now let me update the architecture diagram to reflect these clean boundaries.","signature":"EvsBCkYICxgCKkBPAj3vCUELh09NG0+XUvpX2JSTRW6iaivtv6f0qHF1ArRb9vAmIgsmE30A+ANsWF587QHyk47TIFlu/KTf4a0bEgyTQEHth2MCDrFWom4aDECHlISjoWP1sdaRuSIw6EmG9n/HYNqWZ9WzGMqkn50ANJnrkKVE8v4f1bj2fcbVk4dZoiJ+Ntg1+XhEcCybKmNhYCDrAjcfdKZtEaDT0YhPYsasptLGBRw+i4vwMFz1BPBb47Dr9+qZDHCKP/60RCuALz9Z5YGzIsnhrKdA7wDaxQZTelae6r1ptd1zdulmYxqE/WP6Jsbr5xLY4zmLGxLWw1AYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1674,"cache_read_input_tokens":46287,"cache_creation":{"ephemeral_5m_input_tokens":1674,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPt4H7my197mgqQkuLg","type":"assistant","uuid":"0531992c-b1dd-485e-8ac4-b821ddf15b0a","timestamp":"2026-01-21T23:31:41.328Z"}
{"parentUuid":"0531992c-b1dd-485e-8ac4-b821ddf15b0a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017fq6LZ5aFKi8TUdbFHS9gg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nh8vJUkXxCTNGreNGrLDD5","name":"TodoWrite","input":{"todos":[{"content":"Review plan for separation of concerns violations","activeForm":"Reviewing plan for separation of concerns violations","status":"completed"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","activeForm":"Redefining DriveThruLLM as pure wrapper","status":"completed"},{"content":"Clarify OrderStateManager as single source of truth for state","activeForm":"Clarifying OrderStateManager responsibilities","status":"completed"},{"content":"Define MenuProvider as pure read-only service","activeForm":"Defining MenuProvider responsibilities","status":"completed"},{"content":"Separate menu_validation.py into pure functions","activeForm":"Separating menu_validation into pure functions","status":"completed"},{"content":"Update architecture diagram with clean boundaries","activeForm":"Updating architecture diagram","status":"in_progress"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":1674,"cache_read_input_tokens":46287,"cache_creation":{"ephemeral_5m_input_tokens":1674,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPt4H7my197mgqQkuLg","type":"assistant","uuid":"dcecda4d-4b4b-4ed1-9ace-7ed5d9ba88d9","timestamp":"2026-01-21T23:31:43.783Z"}
{"parentUuid":"dcecda4d-4b4b-4ed1-9ace-7ed5d9ba88d9","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nh8vJUkXxCTNGreNGrLDD5","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"6f604000-0744-430e-8a4e-fb74cf8b3bdd","timestamp":"2026-01-21T23:31:43.842Z","toolUseResult":{"oldTodos":[{"content":"Review plan for separation of concerns violations","status":"in_progress","activeForm":"Reviewing plan for separation of concerns violations"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","status":"pending","activeForm":"Redefining DriveThruLLM as pure wrapper"},{"content":"Clarify OrderStateManager as single source of truth for state","status":"pending","activeForm":"Clarifying OrderStateManager responsibilities"},{"content":"Define MenuProvider as pure read-only service","status":"pending","activeForm":"Defining MenuProvider responsibilities"},{"content":"Separate menu_validation.py into pure functions","status":"pending","activeForm":"Separating menu_validation into pure functions"},{"content":"Update architecture diagram with clean boundaries","status":"pending","activeForm":"Updating architecture diagram"}],"newTodos":[{"content":"Review plan for separation of concerns violations","status":"completed","activeForm":"Reviewing plan for separation of concerns violations"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","status":"completed","activeForm":"Redefining DriveThruLLM as pure wrapper"},{"content":"Clarify OrderStateManager as single source of truth for state","status":"completed","activeForm":"Clarifying OrderStateManager responsibilities"},{"content":"Define MenuProvider as pure read-only service","status":"completed","activeForm":"Defining MenuProvider responsibilities"},{"content":"Separate menu_validation.py into pure functions","status":"completed","activeForm":"Separating menu_validation into pure functions"},{"content":"Update architecture diagram with clean boundaries","status":"in_progress","activeForm":"Updating architecture diagram"}]},"sourceToolAssistantUUID":"dcecda4d-4b4b-4ed1-9ace-7ed5d9ba88d9"}
{"parentUuid":"6f604000-0744-430e-8a4e-fb74cf8b3bdd","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Tu7t7N9TZgr8KC2sUErcoQ","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now let me update the architecture diagram to show the clean flow and boundaries.","signature":"EvkBCkYICxgCKkB5TLbux+MFuztDhQdcbdIGrC2vNOsG/v1vfdPo+KfSzMyDvpZG94tz+CgQDSAZe1zf1dJYXSIusHBd1W4ZRa2lEgyo8UXJ9NHJNFhsnGkaDCWfKJ7fONAdlOZ5oCIw99bqiAsOj3tQmyT0qb4SrjZjjOCnzHsLtodfZE9e8e2oiTFkY0THV5fyoJ7ytuRVKmF8YlM8Nr7h55/9LdW+YqD70qHekOquCcVn7mk1xwA0RdnzcUF5sDA9kYXfIj7+yY9htLavjxnhMjJE0Nu8DoSJaQW1QDZiGj8TV90pUhDkoYXg9XOcgva3ugkNy3J+W4yUGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":343,"cache_read_input_tokens":47961,"cache_creation":{"ephemeral_5m_input_tokens":343,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPtMQkdJYTRzjRm5fra","type":"assistant","uuid":"05ae5858-120c-4b90-966a-5a7259ba88d0","timestamp":"2026-01-21T23:31:45.206Z"}
{"parentUuid":"05ae5858-120c-4b90-966a-5a7259ba88d0","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Tu7t7N9TZgr8KC2sUErcoQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0152rH2beT78XqTVNmn8ppax","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### 1.1 Core Components\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[Custom DriveThruLLM Wrapper]\n    ├─ Menu Context Provider\n    ├─ Order State Manager\n    ├─ Validation Layer\n    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Response\n```","new_string":"### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":11,"cache_creation_input_tokens":343,"cache_read_input_tokens":47961,"cache_creation":{"ephemeral_5m_input_tokens":343,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPtMQkdJYTRzjRm5fra","type":"assistant","uuid":"65f9f84d-5d08-4a2b-a2d2-905a15ce0891","timestamp":"2026-01-21T23:31:55.484Z"}
{"parentUuid":"65f9f84d-5d08-4a2b-a2d2-905a15ce0891","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0152rH2beT78XqTVNmn8ppax","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"9a0d6067-9eee-4f5d-8081-55033c3194c5","timestamp":"2026-01-21T23:31:55.570Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### 1.1 Core Components\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[Custom DriveThruLLM Wrapper]\n    ├─ Menu Context Provider\n    ├─ Order State Manager\n    ├─ Validation Layer\n    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Response\n```","newString":"### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[Custom DriveThruLLM Wrapper]\n    ├─ Menu Context Provider\n    ├─ Order State Manager\n    ├─ Validation Layer\n    └─ Base LLM (OpenAI GPT-4.1 or similar)\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Response\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":14,"oldLines":22,"newStart":14,"newLines":68,"lines":[" "," ## 1. System Architecture"," ","-### 1.1 Core Components","+### 1.1 Core Components & Data Flow"," "," ```"," Customer Voice Input","     ↓"," [STT] → AssemblyAI Universal Streaming","     ↓","-[Custom DriveThruLLM Wrapper]","-    ├─ Menu Context Provider","-    ├─ Order State Manager","-    ├─ Validation Layer","-    └─ Base LLM (OpenAI GPT-4.1 or similar)","+[AgentSession with DriveThruLLM wrapper]","+    │","+    ├─> DriveThruLLM.chat()","+    │   ├─ Queries MenuProvider for context","+    │   ├─ Injects menu context into chat_ctx","+    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)","+    │","+    ├─> Base LLM outputs function call → add_item_to_order(...)","+    │","+    ├─> OrderTools.add_item_to_order()","+    │   ├─ Calls menu_validation.validate_item() [pure function]","+    │   ├─ If valid: OrderStateManager.add_item() [state mutation]","+    │   │   └─ OrderStateManager appends to incremental log","+    │   └─ Returns result to LLM","+    │","+    └─> LLM generates response text","     ↓"," [TTS] → Inworld/Cartesia","     ↓","-Agent Response","+Agent Voice Response","+","+","+┌─────────────────────────────────────────────────────┐","+│ Dependency Diagram (Composition, not inheritance)  │","+└─────────────────────────────────────────────────────┘","+","+VoiceAgentApp","+    │","+    ├─> Creates: DriveThruAgent (owns conversation)","+    │        │","+    │        ├─> Owns: OrderStateManager (mutable state)","+    │        │","+    │        ├─> Receives: MenuProvider (read-only data)","+    │        │","+    │        └─> Registers: OrderTools (coordination layer)","+    │                  │","+    │                  ├─> Uses: menu_validation.py (pure functions)","+    │                  │","+    │                  ├─> Calls: OrderStateManager (state mutations)","+    │                  │","+    │                  └─> Queries: MenuProvider (data access)","+    │","+    ├─> Creates: DriveThruLLM (wraps base LLM)","+    │        │","+    │        └─> Queries: MenuProvider (for context injection)","+    │","+    └─> Loads: MenuProvider (singleton, immutable)","+","+","+Key Principles:","+- MenuProvider: Read-only, queried by many","+- OrderStateManager: Write-heavy, single owner (DriveThruAgent)","+- menu_validation.py: Pure functions, no dependencies","+- DriveThruLLM: Stateless wrapper, delegates to base LLM","+- OrderTools: Thin coordination layer, receives dependencies"," ```"," "," ### 1.2 New Components to Build"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"65f9f84d-5d08-4a2b-a2d2-905a15ce0891"}
{"parentUuid":"9a0d6067-9eee-4f5d-8081-55033c3194c5","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KjLzzg1KiRTwqatDfeExpY","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Great! Now let me update the file structure section to reflect these clean boundaries and add the OrderTools component.","signature":"EqACCkYICxgCKkDDgHKjUcqBkkN1uhjff2OPGYPr0Fgha86e5dGZgR1g5OQ9S+vfXO1OyKZ4jSSHwwQ852dbySRvlcDnnw2SS/RAEgylUMvDamYMLwF0VV0aDCnJnNsZOKlSLCOGNiIwcDLdHh9AjXTS5DKZmpPERKmYSeHrc9Y9hPZnYpP8WFX70nU4Dzhl+zO0hux15/DYKocB5vrnLjEztbgh8sn/FmC1ConpbAdc5MiLpzwd29JvC5L/heOlWSRaLObCUfhyx3h8HnLS5sNYFuefw3ZMAX1Qqs9wUazFK3LxWKmSb2thA6m6GaqRI3v3DMAqI/0unNu+/sH1fDTKdOlzA5C9apmIBk4wpGMjm38wPcagUu5Bt3Xc8y4uM5VdGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1038,"cache_read_input_tokens":48304,"cache_creation":{"ephemeral_5m_input_tokens":1038,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPuDbjUt4m6yR8nLP8i","type":"assistant","uuid":"00f78166-a0ed-42af-ac3e-e1d3a0374822","timestamp":"2026-01-21T23:31:57.487Z"}
{"parentUuid":"00f78166-a0ed-42af-ac3e-e1d3a0374822","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KjLzzg1KiRTwqatDfeExpY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JSz6PDZUXWoLsujUwWKGUU","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```","new_string":"## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":1038,"cache_read_input_tokens":48304,"cache_creation":{"ephemeral_5m_input_tokens":1038,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMPuDbjUt4m6yR8nLP8i","type":"assistant","uuid":"943a0548-3f84-4b57-bf4c-de6753392ad8","timestamp":"2026-01-21T23:32:08.594Z"}
{"parentUuid":"943a0548-3f84-4b57-bf4c-de6753392ad8","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JSz6PDZUXWoLsujUwWKGUU","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"1f280733-bee7-4faa-9f1b-a7609f760fec","timestamp":"2026-01-21T23:32:08.668Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```","newString":"## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # DriveThruAgent class\n├── drive_thru_llm.py            # DriveThruLLM wrapper\n├── menu_provider.py             # Menu loading and search\n├── order_state_manager.py       # Order tracking and output\n├── menu_validation.py           # Validation utilities\n└── tools/\n    └── order_tools.py           # LLM function definitions\n\ntests/\n├── test_drive_thru_agent.py     # End-to-end agent tests\n├── test_menu_provider.py        # Menu search tests\n├── test_order_state.py          # Order state management tests\n└── test_accuracy.py             # Accuracy benchmarks\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":799,"oldLines":27,"newStart":799,"newLines":61,"lines":[" "," ```"," src/","-├── drive_thru_agent.py          # DriveThruAgent class","-├── drive_thru_llm.py            # DriveThruLLM wrapper","-├── menu_provider.py             # Menu loading and search","-├── order_state_manager.py       # Order tracking and output","-├── menu_validation.py           # Validation utilities","+├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)","+├── drive_thru_llm.py            # LLM wrapper (stateless context injection)","+├── menu_provider.py             # Menu data provider (read-only)","+├── order_state_manager.py       # Order state + persistence (single source of truth)","+├── menu_validation.py           # Pure validation functions"," └── tools/","-    └── order_tools.py           # LLM function definitions","+    ├── __init__.py","+    └── order_tools.py           # LiveKit Tool definitions (coordination layer)"," "," tests/","-├── test_drive_thru_agent.py     # End-to-end agent tests","-├── test_menu_provider.py        # Menu search tests","-├── test_order_state.py          # Order state management tests","-└── test_accuracy.py             # Accuracy benchmarks","+├── test_menu_validation.py      # Unit tests for pure functions (fast)","+├── test_menu_provider.py        # Unit tests for menu queries (fast)","+├── test_order_state.py          # Unit tests for state management (fast)","+├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)","+├── test_order_tools.py          # Integration tests for tools (medium)","+├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)","+└── test_accuracy.py             # Accuracy benchmarks (slow)"," "," orders/"," ├── {session_id}/"," │   ├── incremental_log.jsonl    # Per-turn logging"," │   └── final_order.json         # Final order output"," ","+menus/","+└── mcdonalds/","+    ├── models.py                # Pydantic models (Item, Modifier, Menu)","+    └── transformed-data/","+        └── menu-structure-2026-01-21.json","+"," plan/"," └── mcdonalds-drive-thru-agent-plan.md  # This document","+","+","+Test Pyramid (following best practices):","+┌─────────────┐","+│  E2E Tests  │  ← Few, slow, test full agent behavior","+├─────────────┤","+│ Integration │  ← Some, medium, test component interactions","+├─────────────┤","+│ Unit Tests  │  ← Many, fast, test isolated components","+└─────────────┘","+","+Unit tests should be:","+- Fast (no I/O, no real LLM calls)","+- Isolated (test one component at a time)","+- Deterministic (no randomness, no flakiness)","+","+Integration tests should:","+- Use real components but mock expensive dependencies (e.g., mock LLM)","+- Test interactions between 2-3 components","+","+E2E tests should:","+- Use judge-based evaluation for natural language","+- Cover critical user paths","+- Be fewer in number (expensive to run)"," ```"," "," ---"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"943a0548-3f84-4b57-bf4c-de6753392ad8"}
{"parentUuid":"1f280733-bee7-4faa-9f1b-a7609f760fec","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DB2AYrFYK77Y5w5SYKGzD2","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Excellent! Now let me add a new section that explicitly defines the interfaces/contracts for each component. This is very much in the spirit of Kent Beck and Dave Farley - explicit contracts make code testable and maintainable.","signature":"EowDCkYICxgCKkA7d5xKG7nlyo+VXg91ww0K1gCna7UNcnoBRS+xQebbX2OvKguu8x5vDme2sbq2zEv0G1RIx5vQ9f17mlKUzRhyEgwqw2YJdOxmqowcrmQaDKKQkQ+XaH6q9F+hMiIwgbeZqblV4ZJT+rA8G7tjoeaVQG9Q0oeWtczeboiHTEsYztJnyhTjcvFikK7n4Wb3KvMBcrcKelY58l8rfwSmPOiCMgDVyaT2Qf67Fcu9gTKIIrPWVmPElwEWz1Ithdq8cHcjJAZOgw3JE7UUauHvCkdooBH8btcCvYqKDfCLUOPHpTkU/GPfre7AOtt0wyw8XZb9sfcX/+D9djChlQ9CyLQk/raPxjhqlXVwmTuvXQsZdV8cqnBvHa+XeS7DuDL7BgEKIArewqM0+NJvHmjTK2MRjYBEncqEElwJXURXESE0cMhOY8UVeDKsoZGPW2QhtotpVS1jGDU6xt48N8WiIruJbO8lUZpz1HYodfNtGyR50M++vBIUyoL3gU+pMt0AAwv+mtg3GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":1155,"cache_read_input_tokens":49342,"cache_creation":{"ephemeral_5m_input_tokens":1155,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXMPvBkde4dTj9KVRvWgX","type":"assistant","uuid":"8363a868-d754-4251-9c32-9552318fe1c1","timestamp":"2026-01-21T23:32:10.716Z"}
{"parentUuid":"8363a868-d754-4251-9c32-9552318fe1c1","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DB2AYrFYK77Y5w5SYKGzD2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HH7HE4aNhxkJ4zjN3o3HmF","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"---\n\n## 2. Accuracy-Boosting Strategies","new_string":"---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":9,"cache_creation_input_tokens":1155,"cache_read_input_tokens":49342,"cache_creation":{"ephemeral_5m_input_tokens":1155,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXMPvBkde4dTj9KVRvWgX","type":"assistant","uuid":"0aebe48b-c1a9-4bb9-8cd6-d991d0b7fbf9","timestamp":"2026-01-21T23:32:28.313Z"}
{"parentUuid":"0aebe48b-c1a9-4bb9-8cd6-d991d0b7fbf9","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HH7HE4aNhxkJ4zjN3o3HmF","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"e41cb07c-b99f-4ba4-91b9-147a34247a46","timestamp":"2026-01-21T23:32:28.395Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"---\n\n## 2. Accuracy-Boosting Strategies","newString":"---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":184,"oldLines":6,"newStart":184,"newLines":201,"lines":[" "," ---"," ","+## 1.3 Component Contracts (Interfaces)","+","+Following the Interface Segregation Principle, here are the explicit contracts for each component.","+","+### MenuProvider Interface","+```python","+class MenuProvider:","+    \"\"\"Read-only menu data provider.\"\"\"","+","+    def __init__(self, menu_file_path: str) -> None:","+        \"\"\"Load menu from JSON file.\"\"\"","+","+    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:","+        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"","+","+    def get_category(self, category_name: str) -> list[Item]:","+        \"\"\"Get all items in a category.\"\"\"","+","+    def get_item(self, category_name: str, item_name: str) -> Item | None:","+        \"\"\"Get a specific item by category and name.\"\"\"","+","+    def get_all_categories(self) -> list[str]:","+        \"\"\"Get list of all category names.\"\"\"","+","+    def get_menu(self) -> Menu:","+        \"\"\"Get the complete menu (immutable).\"\"\"","+```","+","+### OrderStateManager Interface","+```python","+@dataclass","+class OrderItem:","+    \"\"\"A single item in an order.\"\"\"","+    item_name: str","+    category: str","+    modifiers: list[str]","+    quantity: int","+    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))","+    timestamp: datetime = field(default_factory=datetime.now)","+","+","+class OrderStateManager:","+    \"\"\"Single source of truth for order state and persistence.\"\"\"","+","+    def __init__(self, session_id: str, output_dir: str) -> None:","+        \"\"\"Initialize order state for a session.\"\"\"","+","+    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:","+        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"","+","+    def remove_item(self, item_id: str) -> bool:","+        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"","+","+    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:","+        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"","+","+    def get_items(self) -> list[OrderItem]:","+        \"\"\"Get all items in current order (read-only copy).\"\"\"","+","+    def get_total_count(self) -> int:","+        \"\"\"Get total number of items (accounting for quantities).\"\"\"","+","+    def get_order_summary(self) -> str:","+        \"\"\"Get human-readable order summary.\"\"\"","+","+    def complete_order(self) -> dict:","+        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"","+","+    def clear_order(self) -> None:","+        \"\"\"Clear all items (for cancellation/restart).\"\"\"","+```","+","+### menu_validation Module (Pure Functions)","+```python","+@dataclass","+class ValidationResult:","+    \"\"\"Result of a validation operation.\"\"\"","+    is_valid: bool","+    matched_item: Item | None = None","+    confidence_score: float = 0.0","+    error_message: str | None = None","+","+","+def fuzzy_match_item(","+    item_name: str,","+    menu_items: list[Item],","+    threshold: int = 85","+) -> ValidationResult:","+    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"","+","+","+def validate_item_exists(","+    item_name: str,","+    category: str,","+    menu_provider: MenuProvider","+) -> ValidationResult:","+    \"\"\"Validate that an item exists in the specified category.\"\"\"","+","+","+def validate_modifiers(","+    item: Item,","+    requested_modifiers: list[str],","+    fuzzy_threshold: int = 85","+) -> ValidationResult:","+    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"","+","+","+def validate_order_item(","+    item_name: str,","+    category: str,","+    modifiers: list[str],","+    menu_provider: MenuProvider,","+    fuzzy_threshold: int = 85","+) -> ValidationResult:","+    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"","+```","+","+### OrderTools (LiveKit Tool Definitions)","+```python","+def create_order_tools(","+    order_state: OrderStateManager,","+    menu_provider: MenuProvider,","+    config: DriveThruConfig","+) -> list[Tool]:","+    \"\"\"Create LiveKit Tool instances with dependencies injected.","+","+    Returns:","+        List of Tool objects that can be registered with an Agent","+    \"\"\"","+","+    # Tool 1: add_item_to_order","+    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}","+    # Behavior: validate → add to state → return confirmation","+","+    # Tool 2: complete_order","+    # Schema: {}","+    # Behavior: complete order → return summary","+```","+","+### DriveThruLLM Interface","+```python","+class DriveThruLLM(LLM):","+    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"","+","+    def __init__(","+        self,","+        wrapped_llm: LLM,","+        menu_provider: MenuProvider,","+        config: DriveThruConfig","+    ) -> None:","+        \"\"\"Initialize wrapper with dependencies.\"\"\"","+","+    def chat(","+        self,","+        *,","+        chat_ctx: ChatContext,","+        tools: list[Tool] | None = None,","+        **kwargs","+    ) -> LLMStream:","+        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"","+        # 1. Extract keywords from latest user message","+        # 2. Query MenuProvider for relevant items","+        # 3. Inject into chat_ctx as system message or augment existing prompt","+        # 4. Delegate to wrapped_llm.chat()","+```","+","+### DriveThruAgent","+```python","+class DriveThruAgent(Agent):","+    \"\"\"Drive-thru order taking agent.\"\"\"","+","+    def __init__(","+        self,","+        order_state: OrderStateManager,","+        menu_provider: MenuProvider,","+        config: DriveThruConfig","+    ) -> None:","+        \"\"\"Initialize agent with dependencies.","+","+        - Sets instructions/persona","+        - Registers order tools","+        - Owns OrderStateManager","+        \"\"\"","+```","+","+**Design Principles Applied**:","+1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them","+2. **Interface Segregation**: Each interface is minimal and focused","+3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator","+4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable","+5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate","+6. **Single Source of Truth**: All order state lives in OrderStateManager","+","+---","+"," ## 2. Accuracy-Boosting Strategies"," "," ### Priority 1: Core Strategies (Implement First)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0aebe48b-c1a9-4bb9-8cd6-d991d0b7fbf9"}
{"parentUuid":"e41cb07c-b99f-4ba4-91b9-147a34247a46","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JUoUGYJSuHDgkB9pWoYUe8","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Excellent! Now let me update the Implementation Phases section to reflect the clean boundaries and add explicit notes about testability and boundaries.","signature":"EsACCkYICxgCKkCbcHIvIAXz0l89yKsqObEUsFiBtlLNQr1qHrcpf2JumzW2VsUVB/bXFvR0f2XwGPV+QFnRVp6/7G0yNcQhwliIEgwGevTeKGVjBVUJS4IaDHs7zI+AWroLkdGgRiIwurBthuWPrlxMAGM2HbbDSYcbJFQV0aqa5xx6kMz/+pZp+8myy1PgMho0L1whK95ZKqcBu2dDszjEF7nDmMzfiTQlyofre4c2EQ0dQ2L5aA2g3CwS/Mvy6Uiz8ZiOKH0G0VhFT/0k4PICFfQp+mb7wzwAo4iNuriKGNu6f1vfUC1TIojQecWZrn3topG4qdCiWKSL14dnX9s7qlGe7+tmQwgg7Qg9LJJKzhVRVqXlzOO7Ip5eWzQLKvxtiQjPdfvbk2sAQtjGEMBRBybjXqJFxK26ResDUKJBowwYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":1923,"cache_read_input_tokens":50497,"cache_creation":{"ephemeral_5m_input_tokens":1923,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXMPweLZn93N1kXDspSAs","type":"assistant","uuid":"0b115370-2673-448d-9917-fda08d035512","timestamp":"2026-01-21T23:32:30.247Z"}
{"parentUuid":"0b115370-2673-448d-9917-fda08d035512","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JUoUGYJSuHDgkB9pWoYUe8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q8S6C9i3Xsbhvvadkeua8U","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component","new_string":"### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":8,"cache_creation_input_tokens":1923,"cache_read_input_tokens":50497,"cache_creation":{"ephemeral_5m_input_tokens":1923,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CXMPweLZn93N1kXDspSAs","type":"assistant","uuid":"b1522e40-d7b6-48d2-b2b6-24d24ad0e65e","timestamp":"2026-01-21T23:32:41.335Z"}
{"parentUuid":"b1522e40-d7b6-48d2-b2b6-24d24ad0e65e","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q8S6C9i3Xsbhvvadkeua8U","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"555858c1-bd7b-430c-9644-4dc49400ecf6","timestamp":"2026-01-21T23:32:41.438Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component","newString":"### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (2-3 days)\n- [ ] Enhance `Item` class with `quantity` field\n- [ ] Enhance `Item` class with `item_id` field\n- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)\n- [ ] Write unit tests for `Item` enhancements (addition, field validation)\n- [ ] Create `MenuProvider` class\n- [ ] Create `OrderStateManager` class\n- [ ] Create basic `DriveThruLLM` wrapper\n- [ ] Implement function calling for `add_item_to_order`\n- [ ] Set up order file output (incremental + final)\n- [ ] Write basic unit tests for each component\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":948,"oldLines":18,"newStart":948,"newLines":59,"lines":[" "," ## 6. Implementation Phases"," ","-### Phase 1: Core Infrastructure (2-3 days)","-- [ ] Enhance `Item` class with `quantity` field","-- [ ] Enhance `Item` class with `item_id` field","-- [ ] Implement `__add__` method for `Item` class (item addition/aggregation)","-- [ ] Write unit tests for `Item` enhancements (addition, field validation)","-- [ ] Create `MenuProvider` class","-- [ ] Create `OrderStateManager` class","-- [ ] Create basic `DriveThruLLM` wrapper","-- [ ] Implement function calling for `add_item_to_order`","-- [ ] Set up order file output (incremental + final)","-- [ ] Write basic unit tests for each component","+### Phase 1: Core Infrastructure (Build from bottom up, test-first)"," ","+**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.","+","+#### Step 1.1: Menu Models & Validation (No dependencies)","+- [ ] Enhance `Item` class with `quantity` field (default=1)","+- [ ] Enhance `Item` class with `item_id` field (UUID)","+- [ ] Implement `__add__` method for `Item` class","+- [ ] Write unit tests for `Item` enhancements","+  - Test addition with same modifiers","+  - Test addition failure with different modifiers","+  - Test quantity field defaults","+","+#### Step 1.2: Pure Functions (No dependencies)","+- [ ] Implement `menu_validation.py` with pure functions","+  - `fuzzy_match_item()`","+  - `validate_item_exists()`","+  - `validate_modifiers()`","+  - `validate_order_item()`","+- [ ] Write comprehensive unit tests for validation functions","+  - Fast, deterministic, no I/O","+  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches","+","+#### Step 1.3: Read-Only Data Provider (Depends on: Item models)","+- [ ] Implement `MenuProvider` class","+  - Constructor loads JSON","+  - `search_items()`, `get_category()`, `get_item()`","+  - All methods return immutable data","+- [ ] Write unit tests for MenuProvider","+  - Use fixture JSON file","+  - Test search, category queries, item lookups","+  - Verify immutability (mutations don't affect provider)","+","+#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)","+- [ ] Define `OrderItem` dataclass","+- [ ] Implement `OrderStateManager` class","+  - `add_item()`, `remove_item()`, `update_item_quantity()`","+  - `get_items()`, `get_total_count()`, `get_order_summary()`","+  - `complete_order()`, `clear_order()`","+  - Incremental logging (append to JSONL after each mutation)","+  - Final JSON generation","+- [ ] Write unit tests for OrderStateManager","+  - Test in-memory state operations (fast)","+  - Test file I/O separately (use temp directory)","+  - Verify incremental log appends correctly","+  - Verify final JSON structure","+","+#### Step 1.5: Verify Boundaries","+- [ ] Ensure MenuProvider has no mutable state","+- [ ] Ensure OrderStateManager is single source of truth","+- [ ] Ensure validation functions are pure (no I/O, no side effects)","+- [ ] Run all unit tests - should be fast (<1 second total)","+"," ### Phase 2: Accuracy Strategies - MVP (3-4 days)"," - [ ] Implement Strategy 1: Function Calling"," - [ ] Implement Strategy 2: Menu Context Injection"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b1522e40-d7b6-48d2-b2b6-24d24ad0e65e"}
{"parentUuid":"555858c1-bd7b-430c-9644-4dc49400ecf6","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01RCkNe93jNTyogS2SKCWWTV","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good! Now let me update Phase 2 to reflect the clean separation and proper ordering of dependencies.","signature":"EowCCkYICxgCKkDGY/LkyyNv4/TUxXr9GAWRUtc0Mp0jJM1MmNY0nvwiBuN0h7+2Pux9s0bqnWBbw7dC3cJuEwFFJgx7fwt34b80EgwVQCn7Lk0INW4flnIaDNFxGMrifar1J0UBRyIwLStTadPOrqpMvdBv1OVK5q4toosXJkHDi/S82UMgGY51rARDoJHyTgxZaurJrAfeKnQYrRijEHZXtMBB9IPBZB5NJj+BTD/VhCI0MpTLhts99oWtn1Z5hQAzgSkKDuCydd3r2rwdOS9AUYL6HpXGIfuqnioTY6NfIV6PVDGqBDVWg6seQr7TrM5WkUeB8/LGRRoEbPB/38nCZQjtxaJSjc42dD7taRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1070,"cache_read_input_tokens":52420,"cache_creation":{"ephemeral_5m_input_tokens":1070,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPxbyi7ZLDGiDJ6XCci","type":"assistant","uuid":"ef17c93e-c7b3-408b-96f1-b100248cfd8e","timestamp":"2026-01-21T23:32:43.406Z"}
{"parentUuid":"ef17c93e-c7b3-408b-96f1-b100248cfd8e","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01RCkNe93jNTyogS2SKCWWTV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PGLxbHsUJrZFM52fXHy5Jz","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy","new_string":"### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1070,"cache_read_input_tokens":52420,"cache_creation":{"ephemeral_5m_input_tokens":1070,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPxbyi7ZLDGiDJ6XCci","type":"assistant","uuid":"d138f519-cf6f-44a2-9a2b-b7bf2a887046","timestamp":"2026-01-21T23:32:52.958Z"}
{"parentUuid":"d138f519-cf6f-44a2-9a2b-b7bf2a887046","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PGLxbHsUJrZFM52fXHy5Jz","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"61304f1b-0bbb-4226-af2d-fc0d5562124d","timestamp":"2026-01-21T23:32:53.090Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy","newString":"### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)\n\n### Phase 2: Accuracy Strategies - MVP (3-4 days)\n- [ ] Implement Strategy 1: Function Calling\n- [ ] Implement Strategy 2: Menu Context Injection\n- [ ] Implement Strategy 4: Fuzzy String Matching\n- [ ] Implement Strategy 9: Post-Processing Validation\n- [ ] Write tests for each strategy\n- [ ] Measure baseline accuracy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":1001,"oldLines":14,"newStart":1001,"newLines":54,"lines":[" - [ ] Ensure validation functions are pure (no I/O, no side effects)"," - [ ] Run all unit tests - should be fast (<1 second total)"," ","-### Phase 2: Accuracy Strategies - MVP (3-4 days)","-- [ ] Implement Strategy 1: Function Calling","-- [ ] Implement Strategy 2: Menu Context Injection","-- [ ] Implement Strategy 4: Fuzzy String Matching","-- [ ] Implement Strategy 9: Post-Processing Validation","-- [ ] Write tests for each strategy","-- [ ] Measure baseline accuracy","+### Phase 2: Coordination Layer (Build tools and wrappers)"," ","+**Principle**: Now that we have testable components, build the coordination layer that wires them together.","+","+#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)","+- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`","+  - Define `add_item_to_order` tool schema","+    - Parameters: category, item_name, modifiers, quantity","+    - Description optimized for LLM understanding","+  - Implement tool function:","+    ```python","+    # 1. Validate using menu_validation.validate_order_item()","+    # 2. If valid: order_state.add_item()","+    # 3. Return structured confirmation","+    ```","+  - Define `complete_order` tool schema","+  - Implement tool function: calls order_state.complete_order()","+- [ ] Write integration tests for order_tools","+  - Mock OrderStateManager, real MenuProvider","+  - Verify validation is called before state mutation","+  - Verify tool returns proper schema","+  - Test invalid inputs (should not mutate state)","+","+#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)","+- [ ] Implement `DriveThruLLM` wrapper","+  - Constructor: receives wrapped_llm, menu_provider, config","+  - `chat()` method:","+    ```python","+    # 1. Extract keywords from latest user message","+    # 2. Query menu_provider.search_items(keyword)","+    # 3. Inject relevant items into chat_ctx (augment system message)","+    # 4. Delegate to wrapped_llm.chat()","+    ```","+  - Keep wrapper STATELESS","+- [ ] Write unit tests for DriveThruLLM","+  - Mock wrapped LLM","+  - Verify menu context is injected into chat_ctx","+  - Verify delegation to wrapped LLM","+  - No state stored in wrapper","+","+#### Step 2.3: Accuracy Strategies (Implement within existing components)","+- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓","+- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM","+- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py","+- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)","+- [ ] Verify all strategies are in place","+- [ ] Document which component owns which strategy","+"," ### Phase 3: Agent Integration (2 days)"," - [ ] Create `DriveThruAgent` with proper instructions"," - [ ] Integrate with `VoiceAgentApp`"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d138f519-cf6f-44a2-9a2b-b7bf2a887046"}
{"parentUuid":"61304f1b-0bbb-4226-af2d-fc0d5562124d","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01U9BxTomEzJEqPjwnBHcpiU","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Great! Now let me update Phase 3 to reflect the agent integration with proper dependency injection.","signature":"EosCCkYICxgCKkBH3vcDHQhl29uXU4XHSmzXLcJ7WUKF8zK+xVcZxuxbtMpSwrVOoQR5PJOc5UVgyowURb6LR0/Xt9y/TwcsAMdwEgycKF898cgCklKJHAIaDGDJ9leCkiS/ejAn/SIwDmtVksxRUe5zz2WIW4Gsa0JLIA36hLsu1PVykxjgrzS2jLf9zkEyTjIseVSEH+IqKnMYBOqs3WVCyCR1NE1RBs9qcNJ1bXqlm6g2Y2+Itq/fTZeQe6S7zCJgsXsKZgvjmFADd4z1bOEwDTVrRry4f4hYrORCa6HNKyE1R0HQOiyDUDoLTUATLQKJksC8ZB+ggaUMHkaIrrFP9exNI3niRPxjF+psGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":944,"cache_read_input_tokens":53490,"cache_creation":{"ephemeral_5m_input_tokens":944,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPyTocb8cTqp5czvyA9","type":"assistant","uuid":"4d00b7e1-2f6e-4c36-8584-ec185e5c705d","timestamp":"2026-01-21T23:32:54.683Z"}
{"parentUuid":"4d00b7e1-2f6e-4c36-8584-ec185e5c705d","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01U9BxTomEzJEqPjwnBHcpiU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01H8CwYoRm57hCgrnnuGbjut","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases","new_string":"### Phase 3: Agent Integration (Wire everything together)\n\n**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n\n#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n- [ ] Implement `DriveThruAgent` class\n  - Constructor receives: order_state, menu_provider, config\n  - Sets drive-thru specific instructions (system prompt)\n  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  - Agent OWNS OrderStateManager (composition)\n  - Agent RECEIVES MenuProvider (dependency injection)\n- [ ] Define agent instructions/persona\n  - Concise, friendly, efficient\n  - Clear about when to use tools\n  - Handles confirmation flow\n\n#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n- [ ] Add `DriveThruConfig` to `src/config.py`\n  - menu_file_path, orders_output_dir\n  - fuzzy_match_threshold, max_context_items\n  - enable_confirmation_loop, enable_semantic_search\n- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  - Instantiate MenuProvider (singleton, loaded once)\n  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  - Create OrderStateManager for each session (session_handler)\n  - Create DriveThruAgent (injecting order_state and menu_provider)\n  - Wire to SessionHandler\n- [ ] Verify dependency flow:\n  ```\n  App creates MenuProvider (singleton)\n     ├─> Injects into DriveThruLLM wrapper\n     ├─> Injects into DriveThruAgent\n     └─> Injects into OrderTools\n\n  App creates OrderStateManager per session\n     ├─> Owned by DriveThruAgent\n     └─> Passed to OrderTools\n  ```\n\n#### Step 3.3: Integration Testing\n- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  - No mocked components, real coordination\n  - Verify end-to-end flow: validate → add → log\n- [ ] Test console mode end-to-end\n  - Use mock LLM or real LLM with simple prompts\n  - Verify order state is persisted correctly\n  - Verify incremental logs and final JSON"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":944,"cache_read_input_tokens":53490,"cache_creation":{"ephemeral_5m_input_tokens":944,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMPyTocb8cTqp5czvyA9","type":"assistant","uuid":"1644c7a8-b66a-4328-a094-a45334ee14d8","timestamp":"2026-01-21T23:33:04.186Z"}
{"parentUuid":"1644c7a8-b66a-4328-a094-a45334ee14d8","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01H8CwYoRm57hCgrnnuGbjut","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"fa84962d-138f-4f1e-9b10-380fc31066c6","timestamp":"2026-01-21T23:33:04.336Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases","newString":"### Phase 3: Agent Integration (Wire everything together)\n\n**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n\n#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n- [ ] Implement `DriveThruAgent` class\n  - Constructor receives: order_state, menu_provider, config\n  - Sets drive-thru specific instructions (system prompt)\n  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  - Agent OWNS OrderStateManager (composition)\n  - Agent RECEIVES MenuProvider (dependency injection)\n- [ ] Define agent instructions/persona\n  - Concise, friendly, efficient\n  - Clear about when to use tools\n  - Handles confirmation flow\n\n#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n- [ ] Add `DriveThruConfig` to `src/config.py`\n  - menu_file_path, orders_output_dir\n  - fuzzy_match_threshold, max_context_items\n  - enable_confirmation_loop, enable_semantic_search\n- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  - Instantiate MenuProvider (singleton, loaded once)\n  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  - Create OrderStateManager for each session (session_handler)\n  - Create DriveThruAgent (injecting order_state and menu_provider)\n  - Wire to SessionHandler\n- [ ] Verify dependency flow:\n  ```\n  App creates MenuProvider (singleton)\n     ├─> Injects into DriveThruLLM wrapper\n     ├─> Injects into DriveThruAgent\n     └─> Injects into OrderTools\n\n  App creates OrderStateManager per session\n     ├─> Owned by DriveThruAgent\n     └─> Passed to OrderTools\n  ```\n\n#### Step 3.3: Integration Testing\n- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  - No mocked components, real coordination\n  - Verify end-to-end flow: validate → add → log\n- [ ] Test console mode end-to-end\n  - Use mock LLM or real LLM with simple prompts\n  - Verify order state is persisted correctly\n  - Verify incremental logs and final JSON","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)\n\n### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy\n\n### Phase 3: Agent Integration (2 days)\n- [ ] Create `DriveThruAgent` with proper instructions\n- [ ] Integrate with `VoiceAgentApp`\n- [ ] Add configuration options to `config.py`\n- [ ] Test end-to-end in console mode\n- [ ] Fix bugs and edge cases\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":1049,"oldLines":13,"newStart":1049,"newLines":54,"lines":[" - [ ] Verify all strategies are in place"," - [ ] Document which component owns which strategy"," ","-### Phase 3: Agent Integration (2 days)","-- [ ] Create `DriveThruAgent` with proper instructions","-- [ ] Integrate with `VoiceAgentApp`","-- [ ] Add configuration options to `config.py`","-- [ ] Test end-to-end in console mode","-- [ ] Fix bugs and edge cases","+### Phase 3: Agent Integration (Wire everything together)"," ","+**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.","+","+#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)","+- [ ] Implement `DriveThruAgent` class","+  - Constructor receives: order_state, menu_provider, config","+  - Sets drive-thru specific instructions (system prompt)","+  - Registers tools: `create_order_tools(order_state, menu_provider, config)`","+  - Agent OWNS OrderStateManager (composition)","+  - Agent RECEIVES MenuProvider (dependency injection)","+- [ ] Define agent instructions/persona","+  - Concise, friendly, efficient","+  - Clear about when to use tools","+  - Handles confirmation flow","+","+#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)","+- [ ] Add `DriveThruConfig` to `src/config.py`","+  - menu_file_path, orders_output_dir","+  - fuzzy_match_threshold, max_context_items","+  - enable_confirmation_loop, enable_semantic_search","+- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)","+  - Instantiate MenuProvider (singleton, loaded once)","+  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)","+  - Create OrderStateManager for each session (session_handler)","+  - Create DriveThruAgent (injecting order_state and menu_provider)","+  - Wire to SessionHandler","+- [ ] Verify dependency flow:","+  ```","+  App creates MenuProvider (singleton)","+     ├─> Injects into DriveThruLLM wrapper","+     ├─> Injects into DriveThruAgent","+     └─> Injects into OrderTools","+","+  App creates OrderStateManager per session","+     ├─> Owned by DriveThruAgent","+     └─> Passed to OrderTools","+  ```","+","+#### Step 3.3: Integration Testing","+- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider","+  - No mocked components, real coordination","+  - Verify end-to-end flow: validate → add → log","+- [ ] Test console mode end-to-end","+  - Use mock LLM or real LLM with simple prompts","+  - Verify order state is persisted correctly","+  - Verify incremental logs and final JSON","+"," ### Phase 4: Testing & Refinement (2-3 days)"," - [ ] Write comprehensive test suite (20+ tests)"," - [ ] Test with real voice input (console mode)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"1644c7a8-b66a-4328-a094-a45334ee14d8"}
{"parentUuid":"fa84962d-138f-4f1e-9b10-380fc31066c6","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016kzVAjfJoqQ3UuMCEeEjKP","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Perfect! Now let me add a new section that explicitly describes the key design decisions from a Kent Beck / Dave Farley perspective.","signature":"Eq0CCkYICxgCKkDIE/Xg5wZnaIbWUx0y8DbnDVOiyxliLB40+2q0JsnU9fEB+fyQqLXuPvaFvgthIimpWkWHKZiFD1TZAyH1ST8wEgxclSaKQxPOE7127akaDO51lJAd8mesg9qwvCIwIYfQj1pwBicdpo0S7497ZQYeygF3ndYvMYjh7gCm1tkQoCtFF1zRuRyrfGh+pscjKpQBu4Zo31lOjPoZuWVXv/XWOrrjeneSoly/nAwGWHUBzug9ZB5j+dYHNQFV4mAYCY5DeEn1oNNTUOE1AqdLT5b9dFVsxLdvlEFBDLPb+TJXZs8K+VaUTCgu6TmNHJu4KrVQPNphjEXMECipt2XzM6RjNgsRleO5j2dGL9kmMdthoqGX/bzIh5Ea3vCxlL9zlB2Tb+Q9NBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":915,"cache_read_input_tokens":54434,"cache_creation":{"ephemeral_5m_input_tokens":915,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"requestId":"req_011CXMPzHy3otRxc9HqASRdy","type":"assistant","uuid":"8a8fa4d1-c565-49a3-b7d4-adde26f5aa93","timestamp":"2026-01-21T23:33:05.942Z"}
{"parentUuid":"8a8fa4d1-c565-49a3-b7d4-adde26f5aa93","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_016kzVAjfJoqQ3UuMCEeEjKP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GtCDjD6vSpkZRF6ZxyPZ8E","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.","new_string":"## 12. Key Design Decisions\n\n### Why Separate DriveThruLLM from OrderStateManager?\n**Principle**: Single Responsibility Principle (SRP)\n\nLLM wrapping (context injection) is orthogonal to state management. By separating:\n- DriveThruLLM can be tested with mock LLM (fast unit tests)\n- OrderStateManager can be tested without LLM (fast unit tests)\n- Each component has one reason to change\n- Components can be swapped independently (e.g., try different context injection strategies)\n\n### Why Pure Functions for Validation?\n**Principle**: Functional Core, Imperative Shell\n\nPure functions are maximally testable:\n- No I/O, no side effects\n- Deterministic outputs for same inputs\n- Fast to execute (no database, no API calls)\n- Easy to reason about\n- Can be reused anywhere\n\nThis enables Test-Driven Development: write test first, implement function, iterate quickly.\n\n### Why MenuProvider Returns Immutable Data?\n**Principle**: Immutability Reduces Bugs\n\nIf MenuProvider returned mutable references:\n- Callers could accidentally modify menu data\n- Hard to track down where menu was corrupted\n- Thread safety issues in concurrent sessions\n\nBy returning immutable copies:\n- Menu data is protected from accidental mutation\n- Single source of truth guaranteed\n- Easier to reason about data flow\n\n### Why OrderStateManager is the Only State Owner?\n**Principle**: Single Source of Truth (SSOT)\n\nAll order mutations flow through one place:\n- Easy to add logging/auditing\n- Persistence logic centralized\n- Impossible to have inconsistent state\n- Debugging is straightforward: check one component\n- Testing is simple: verify state before/after\n\nContrast with diffused state (anti-pattern):\n- State scattered across DriveThruLLM, tools, agent\n- Hard to debug: \"Where did this item come from?\"\n- Hard to test: need to set up multiple components\n- Brittle: changes ripple across multiple components\n\n### Why Tools are Thin Coordination Layer?\n**Principle**: Tell, Don't Ask\n\nTools coordinate but don't implement logic:\n```python\n# Good (coordination)\ndef add_item_to_order_tool(...):\n    result = validate_order_item(...)  # Ask validation layer\n    if result.is_valid:\n        order_state.add_item(...)      # Tell state manager\n    return confirmation\n\n# Bad (implementation leaking into tool)\ndef add_item_to_order_tool(...):\n    # Fuzzy matching logic here\n    # Modifier validation logic here\n    # File I/O logic here\n    # Now tool is hard to test and has multiple responsibilities\n```\n\n### Why Function Calling?\n**Principle**: Make Invalid States Unrepresentable\n\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\nSchema enforcement means: \"If it parses, it's valid\" (or close to it).\n\n### Why Multiple Strategies?\n**Principle**: Defense in Depth\n\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.\n\n### Why Confirmation Loop?\n**Principle**: Human-in-the-Loop\n\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.\n\n### Why Incremental Logging?\n**Principle**: Observability & Debuggability\n\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.\n\nEnables data-driven improvement: analyze logs to find common error patterns.\n\n### Why Focus on Accuracy Over Speed?\n**Principle**: Correctness First, Optimization Second\n\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\nPremature optimization is the root of all evil. Get it working, get it right, then make it fast.\n\n### Why Test Pyramid (Many Unit, Few E2E)?\n**Principle**: Fast Feedback Loops (Continuous Delivery)\n\nUnit tests:\n- Run in milliseconds\n- Give instant feedback\n- Pinpoint exact failure\n- Enable rapid iteration\n\nE2E tests:\n- Run in seconds/minutes\n- Slow feedback\n- Hard to debug failures\n- Necessary but expensive\n\nBuild on solid foundation of fast unit tests, use E2E tests for critical paths only.\n\n### Why Dependency Injection?\n**Principle**: Inversion of Control (IoC)\n\nComponents receive dependencies rather than creating them:\n- Easy to substitute mocks for testing\n- Easy to swap implementations (e.g., different LLM, different storage)\n- Explicit dependencies (no hidden coupling)\n- Testable in isolation\n\n```python\n# Good (DI)\nclass DriveThruAgent:\n    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):\n        self.order_state = order_state  # Injected\n        self.menu = menu                # Injected\n\n# Bad (hidden dependencies)\nclass DriveThruAgent:\n    def __init__(self):\n        self.order_state = OrderStateManager()  # Hard-coded\n        self.menu = MenuProvider()              # Hard-coded\n        # Now can't test with mocks, can't swap implementations\n```"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":915,"cache_read_input_tokens":54434,"cache_creation":{"ephemeral_5m_input_tokens":915,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"}},"requestId":"req_011CXMPzHy3otRxc9HqASRdy","type":"assistant","uuid":"3884d1a9-0441-4c3c-b635-c7730dbb8b33","timestamp":"2026-01-21T23:33:26.728Z"}
{"parentUuid":"3884d1a9-0441-4c3c-b635-c7730dbb8b33","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GtCDjD6vSpkZRF6ZxyPZ8E","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"476c2a22-9010-4d98-ae71-d4a92264ac96","timestamp":"2026-01-21T23:33:26.878Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.","newString":"## 12. Key Design Decisions\n\n### Why Separate DriveThruLLM from OrderStateManager?\n**Principle**: Single Responsibility Principle (SRP)\n\nLLM wrapping (context injection) is orthogonal to state management. By separating:\n- DriveThruLLM can be tested with mock LLM (fast unit tests)\n- OrderStateManager can be tested without LLM (fast unit tests)\n- Each component has one reason to change\n- Components can be swapped independently (e.g., try different context injection strategies)\n\n### Why Pure Functions for Validation?\n**Principle**: Functional Core, Imperative Shell\n\nPure functions are maximally testable:\n- No I/O, no side effects\n- Deterministic outputs for same inputs\n- Fast to execute (no database, no API calls)\n- Easy to reason about\n- Can be reused anywhere\n\nThis enables Test-Driven Development: write test first, implement function, iterate quickly.\n\n### Why MenuProvider Returns Immutable Data?\n**Principle**: Immutability Reduces Bugs\n\nIf MenuProvider returned mutable references:\n- Callers could accidentally modify menu data\n- Hard to track down where menu was corrupted\n- Thread safety issues in concurrent sessions\n\nBy returning immutable copies:\n- Menu data is protected from accidental mutation\n- Single source of truth guaranteed\n- Easier to reason about data flow\n\n### Why OrderStateManager is the Only State Owner?\n**Principle**: Single Source of Truth (SSOT)\n\nAll order mutations flow through one place:\n- Easy to add logging/auditing\n- Persistence logic centralized\n- Impossible to have inconsistent state\n- Debugging is straightforward: check one component\n- Testing is simple: verify state before/after\n\nContrast with diffused state (anti-pattern):\n- State scattered across DriveThruLLM, tools, agent\n- Hard to debug: \"Where did this item come from?\"\n- Hard to test: need to set up multiple components\n- Brittle: changes ripple across multiple components\n\n### Why Tools are Thin Coordination Layer?\n**Principle**: Tell, Don't Ask\n\nTools coordinate but don't implement logic:\n```python\n# Good (coordination)\ndef add_item_to_order_tool(...):\n    result = validate_order_item(...)  # Ask validation layer\n    if result.is_valid:\n        order_state.add_item(...)      # Tell state manager\n    return confirmation\n\n# Bad (implementation leaking into tool)\ndef add_item_to_order_tool(...):\n    # Fuzzy matching logic here\n    # Modifier validation logic here\n    # File I/O logic here\n    # Now tool is hard to test and has multiple responsibilities\n```\n\n### Why Function Calling?\n**Principle**: Make Invalid States Unrepresentable\n\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\nSchema enforcement means: \"If it parses, it's valid\" (or close to it).\n\n### Why Multiple Strategies?\n**Principle**: Defense in Depth\n\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.\n\n### Why Confirmation Loop?\n**Principle**: Human-in-the-Loop\n\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.\n\n### Why Incremental Logging?\n**Principle**: Observability & Debuggability\n\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.\n\nEnables data-driven improvement: analyze logs to find common error patterns.\n\n### Why Focus on Accuracy Over Speed?\n**Principle**: Correctness First, Optimization Second\n\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\nPremature optimization is the root of all evil. Get it working, get it right, then make it fast.\n\n### Why Test Pyramid (Many Unit, Few E2E)?\n**Principle**: Fast Feedback Loops (Continuous Delivery)\n\nUnit tests:\n- Run in milliseconds\n- Give instant feedback\n- Pinpoint exact failure\n- Enable rapid iteration\n\nE2E tests:\n- Run in seconds/minutes\n- Slow feedback\n- Hard to debug failures\n- Necessary but expensive\n\nBuild on solid foundation of fast unit tests, use E2E tests for critical paths only.\n\n### Why Dependency Injection?\n**Principle**: Inversion of Control (IoC)\n\nComponents receive dependencies rather than creating them:\n- Easy to substitute mocks for testing\n- Easy to swap implementations (e.g., different LLM, different storage)\n- Explicit dependencies (no hidden coupling)\n- Testable in isolation\n\n```python\n# Good (DI)\nclass DriveThruAgent:\n    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):\n        self.order_state = order_state  # Injected\n        self.menu = menu                # Injected\n\n# Bad (hidden dependencies)\nclass DriveThruAgent:\n    def __init__(self):\n        self.order_state = OrderStateManager()  # Hard-coded\n        self.menu = MenuProvider()              # Hard-coded\n        # Now can't test with mocks, can't swap implementations\n```","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)\n\n### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy\n\n### Phase 3: Agent Integration (Wire everything together)\n\n**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n\n#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n- [ ] Implement `DriveThruAgent` class\n  - Constructor receives: order_state, menu_provider, config\n  - Sets drive-thru specific instructions (system prompt)\n  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  - Agent OWNS OrderStateManager (composition)\n  - Agent RECEIVES MenuProvider (dependency injection)\n- [ ] Define agent instructions/persona\n  - Concise, friendly, efficient\n  - Clear about when to use tools\n  - Handles confirmation flow\n\n#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n- [ ] Add `DriveThruConfig` to `src/config.py`\n  - menu_file_path, orders_output_dir\n  - fuzzy_match_threshold, max_context_items\n  - enable_confirmation_loop, enable_semantic_search\n- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  - Instantiate MenuProvider (singleton, loaded once)\n  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  - Create OrderStateManager for each session (session_handler)\n  - Create DriveThruAgent (injecting order_state and menu_provider)\n  - Wire to SessionHandler\n- [ ] Verify dependency flow:\n  ```\n  App creates MenuProvider (singleton)\n     ├─> Injects into DriveThruLLM wrapper\n     ├─> Injects into DriveThruAgent\n     └─> Injects into OrderTools\n\n  App creates OrderStateManager per session\n     ├─> Owned by DriveThruAgent\n     └─> Passed to OrderTools\n  ```\n\n#### Step 3.3: Integration Testing\n- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  - No mocked components, real coordination\n  - Verify end-to-end flow: validate → add → log\n- [ ] Test console mode end-to-end\n  - Use mock LLM or real LLM with simple prompts\n  - Verify order state is persisted correctly\n  - Verify incremental logs and final JSON\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Function Calling?\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\n### Why Multiple Strategies?\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.\n\n### Why Confirmation Loop?\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.\n\n### Why Incremental Logging?\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.\n\n### Why Focus on Accuracy Over Speed?\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":1287,"oldLines":21,"newStart":1287,"newLines":148,"lines":[" "," ## 12. Key Design Decisions"," ","+### Why Separate DriveThruLLM from OrderStateManager?","+**Principle**: Single Responsibility Principle (SRP)","+","+LLM wrapping (context injection) is orthogonal to state management. By separating:","+- DriveThruLLM can be tested with mock LLM (fast unit tests)","+- OrderStateManager can be tested without LLM (fast unit tests)","+- Each component has one reason to change","+- Components can be swapped independently (e.g., try different context injection strategies)","+","+### Why Pure Functions for Validation?","+**Principle**: Functional Core, Imperative Shell","+","+Pure functions are maximally testable:","+- No I/O, no side effects","+- Deterministic outputs for same inputs","+- Fast to execute (no database, no API calls)","+- Easy to reason about","+- Can be reused anywhere","+","+This enables Test-Driven Development: write test first, implement function, iterate quickly.","+","+### Why MenuProvider Returns Immutable Data?","+**Principle**: Immutability Reduces Bugs","+","+If MenuProvider returned mutable references:","+- Callers could accidentally modify menu data","+- Hard to track down where menu was corrupted","+- Thread safety issues in concurrent sessions","+","+By returning immutable copies:","+- Menu data is protected from accidental mutation","+- Single source of truth guaranteed","+- Easier to reason about data flow","+","+### Why OrderStateManager is the Only State Owner?","+**Principle**: Single Source of Truth (SSOT)","+","+All order mutations flow through one place:","+- Easy to add logging/auditing","+- Persistence logic centralized","+- Impossible to have inconsistent state","+- Debugging is straightforward: check one component","+- Testing is simple: verify state before/after","+","+Contrast with diffused state (anti-pattern):","+- State scattered across DriveThruLLM, tools, agent","+- Hard to debug: \"Where did this item come from?\"","+- Hard to test: need to set up multiple components","+- Brittle: changes ripple across multiple components","+","+### Why Tools are Thin Coordination Layer?","+**Principle**: Tell, Don't Ask","+","+Tools coordinate but don't implement logic:","+```python","+# Good (coordination)","+def add_item_to_order_tool(...):","+    result = validate_order_item(...)  # Ask validation layer","+    if result.is_valid:","+        order_state.add_item(...)      # Tell state manager","+    return confirmation","+","+# Bad (implementation leaking into tool)","+def add_item_to_order_tool(...):","+    # Fuzzy matching logic here","+    # Modifier validation logic here","+    # File I/O logic here","+    # Now tool is hard to test and has multiple responsibilities","+```","+"," ### Why Function Calling?","+**Principle**: Make Invalid States Unrepresentable","+"," Function calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity."," ","+Schema enforcement means: \"If it parses, it's valid\" (or close to it).","+"," ### Why Multiple Strategies?","-No single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system.","+**Principle**: Defense in Depth"," ","+No single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.","+"," ### Why Confirmation Loop?","-Voice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound.","+**Principle**: Human-in-the-Loop"," ","+Voice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.","+"," ### Why Incremental Logging?","-Provides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation.","+**Principle**: Observability & Debuggability"," ","+Provides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.","+","+Enables data-driven improvement: analyze logs to find common error patterns.","+"," ### Why Focus on Accuracy Over Speed?","+**Principle**: Correctness First, Optimization Second","+"," Wrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency."," ","+Premature optimization is the root of all evil. Get it working, get it right, then make it fast.","+","+### Why Test Pyramid (Many Unit, Few E2E)?","+**Principle**: Fast Feedback Loops (Continuous Delivery)","+","+Unit tests:","+- Run in milliseconds","+- Give instant feedback","+- Pinpoint exact failure","+- Enable rapid iteration","+","+E2E tests:","+- Run in seconds/minutes","+- Slow feedback","+- Hard to debug failures","+- Necessary but expensive","+","+Build on solid foundation of fast unit tests, use E2E tests for critical paths only.","+","+### Why Dependency Injection?","+**Principle**: Inversion of Control (IoC)","+","+Components receive dependencies rather than creating them:","+- Easy to substitute mocks for testing","+- Easy to swap implementations (e.g., different LLM, different storage)","+- Explicit dependencies (no hidden coupling)","+- Testable in isolation","+","+```python","+# Good (DI)","+class DriveThruAgent:","+    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):","+        self.order_state = order_state  # Injected","+        self.menu = menu                # Injected","+","+# Bad (hidden dependencies)","+class DriveThruAgent:","+    def __init__(self):","+        self.order_state = OrderStateManager()  # Hard-coded","+        self.menu = MenuProvider()              # Hard-coded","+        # Now can't test with mocks, can't swap implementations","+```","+"," ---"," "," ## 13. Experimentation Framework"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"3884d1a9-0441-4c3c-b635-c7730dbb8b33"}
{"parentUuid":"476c2a22-9010-4d98-ae71-d4a92264ac96","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Q6NHqDdSm419S8Avw9HXgd","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Excellent! Now let me add a summary/checklist at the beginning of the document that serves as a quick reference for the clean architecture principles.","signature":"Er8CCkYICxgCKkAO1f5EYwdIRKMFFPB/uvOx90hqLL6pQxeYMDJlI7LKoMIEXGBE6dfHDN3VvWlUYSu74pZlHVcKWogZfkjUtX0sEgyU7fm6HNhrWFqAIGkaDNi0pb7YZAbzR++2bCIwdNo9zXBJzPkEVdRP93avBRKmfeMtvV50iQF70/7StztMLV0JRx5Dx6YGXI8FIxSVKqYBsjsL4+RmB+8e72ax12euxeDSlpSY/3jPmPFQrW9u4OlSgKud0nS2VBfy9Zn/YUu94HI7iv2WUy0a0dF4+g7ubw3/kMv+NC4vlTKGAl1MRTvNCqOmT49j4zZ/7WGOHjo4WKmhrtO8QA68pxICcUOoMbcDMPPZccEGsKdn5ZNFwbgG3ILT1tJqJHqyxfqnBHJYH6Gp/QgGbVK3cJr0/1fKbGeYEDKWMhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1726,"cache_read_input_tokens":55349,"cache_creation":{"ephemeral_5m_input_tokens":1726,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CXMQ1xSrGcnpvadEQkKoh","type":"assistant","uuid":"e3325252-831f-4415-9290-30ac4f29e4c6","timestamp":"2026-01-21T23:33:28.954Z"}
{"parentUuid":"e3325252-831f-4415-9290-30ac4f29e4c6","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Q6NHqDdSm419S8Avw9HXgd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012vx2MqWZyzCEAtCBY9fDDk","name":"TodoWrite","input":{"todos":[{"content":"Review plan for separation of concerns violations","activeForm":"Reviewing plan for separation of concerns violations","status":"completed"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","activeForm":"Redefining DriveThruLLM as pure wrapper","status":"completed"},{"content":"Clarify OrderStateManager as single source of truth for state","activeForm":"Clarifying OrderStateManager responsibilities","status":"completed"},{"content":"Define MenuProvider as pure read-only service","activeForm":"Defining MenuProvider responsibilities","status":"completed"},{"content":"Separate menu_validation.py into pure functions","activeForm":"Separating menu_validation into pure functions","status":"completed"},{"content":"Update architecture diagram with clean boundaries","activeForm":"Updating architecture diagram","status":"completed"},{"content":"Add clean architecture summary section","activeForm":"Adding clean architecture summary section","status":"in_progress"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":1726,"cache_read_input_tokens":55349,"cache_creation":{"ephemeral_5m_input_tokens":1726,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"}},"requestId":"req_011CXMQ1xSrGcnpvadEQkKoh","type":"assistant","uuid":"5561a4cf-c9e8-4896-bbea-a3bf640d4662","timestamp":"2026-01-21T23:33:31.966Z"}
{"parentUuid":"5561a4cf-c9e8-4896-bbea-a3bf640d4662","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012vx2MqWZyzCEAtCBY9fDDk","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"1fbfbd38-b92b-4979-9ab9-c9f418dd4e9e","timestamp":"2026-01-21T23:33:32.127Z","toolUseResult":{"oldTodos":[{"content":"Review plan for separation of concerns violations","status":"completed","activeForm":"Reviewing plan for separation of concerns violations"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","status":"completed","activeForm":"Redefining DriveThruLLM as pure wrapper"},{"content":"Clarify OrderStateManager as single source of truth for state","status":"completed","activeForm":"Clarifying OrderStateManager responsibilities"},{"content":"Define MenuProvider as pure read-only service","status":"completed","activeForm":"Defining MenuProvider responsibilities"},{"content":"Separate menu_validation.py into pure functions","status":"completed","activeForm":"Separating menu_validation into pure functions"},{"content":"Update architecture diagram with clean boundaries","status":"in_progress","activeForm":"Updating architecture diagram"}],"newTodos":[{"content":"Review plan for separation of concerns violations","status":"completed","activeForm":"Reviewing plan for separation of concerns violations"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","status":"completed","activeForm":"Redefining DriveThruLLM as pure wrapper"},{"content":"Clarify OrderStateManager as single source of truth for state","status":"completed","activeForm":"Clarifying OrderStateManager responsibilities"},{"content":"Define MenuProvider as pure read-only service","status":"completed","activeForm":"Defining MenuProvider responsibilities"},{"content":"Separate menu_validation.py into pure functions","status":"completed","activeForm":"Separating menu_validation into pure functions"},{"content":"Update architecture diagram with clean boundaries","status":"completed","activeForm":"Updating architecture diagram"},{"content":"Add clean architecture summary section","status":"in_progress","activeForm":"Adding clean architecture summary section"}]},"sourceToolAssistantUUID":"5561a4cf-c9e8-4896-bbea-a3bf640d4662"}
{"parentUuid":"1fbfbd38-b92b-4979-9ab9-c9f418dd4e9e","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FSnZD3NRpsvUeXUYp5LeaF","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me add a clean architecture principles section right after the Executive Summary.","signature":"Ev0BCkYICxgCKkBrNTZCY9EVq7Eyeput8LNuhzqs/1bWUHXtPNRgpjM3A94NiX26qdpFn9ks93saq+dXaEGUDBa/l66v8ynCzqRFEgyysdTKlMLI9oHnlhMaDOsD1bqXlTEj7fu7cyIwRJjTdON2+u1JoPu+qU7V8SxWK/SjE615mrKAiLdBQAN4XAabGrCyZBASp5+Gsl/KKmWI629wNAG/MzF3juwa0QIfobcR+AD4aXtTOHcS4uuMO3S6to0YkAuPgGLWpAJMUIqSfGszziWQSdfHwAQMWnpK1wQ94qGoxDnGcFZd16TcO5cVy+wyP2UWaqA/rxgB/XnVGH6w5hgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":386,"cache_read_input_tokens":57075,"cache_creation":{"ephemeral_5m_input_tokens":386,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ2MbPZioAb8aPvmSxV","type":"assistant","uuid":"635116a4-596c-4674-994c-5b95cadbe23a","timestamp":"2026-01-21T23:33:33.917Z"}
{"parentUuid":"635116a4-596c-4674-994c-5b95cadbe23a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01FSnZD3NRpsvUeXUYp5LeaF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016NwME9ss2jcf8vwdUtXwVL","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"---\n\n## 1. System Architecture","new_string":"---\n\n## 0. Clean Architecture Principles (Kent Beck + Dave Farley)\n\nThis implementation follows clean architecture principles for maintainability, testability, and continuous delivery.\n\n### Core Principles Checklist\n\n**✓ Single Responsibility Principle (SRP)**\n- Each component has one reason to change\n- DriveThruLLM: Context injection only (no state)\n- OrderStateManager: State + persistence only\n- MenuProvider: Read-only data access only\n- menu_validation.py: Pure validation functions only\n\n**✓ Dependency Inversion**\n- Components receive dependencies via constructor (DI)\n- High-level components don't depend on low-level details\n- Easy to mock, easy to test, easy to swap\n\n**✓ Pure Functions Where Possible**\n- menu_validation.py: 100% pure functions\n- No I/O, no side effects, fully deterministic\n- Fast, testable, reusable\n\n**✓ Immutability Reduces Bugs**\n- MenuProvider returns immutable data\n- Menu cannot be accidentally corrupted\n- Thread-safe by design\n\n**✓ Single Source of Truth**\n- OrderStateManager is ONLY owner of order state\n- All mutations flow through one place\n- Easy to debug, easy to audit, easy to test\n\n**✓ Tell, Don't Ask**\n- Tools tell OrderStateManager what to do\n- Don't query state, mutate it, then write back\n- Reduces coupling, increases cohesion\n\n**✓ Test Pyramid**\n- Many fast unit tests (milliseconds)\n- Some integration tests (seconds)\n- Few E2E tests (minutes)\n- Fast feedback loops enable TDD\n\n**✓ Make Invalid States Unrepresentable**\n- Use type system + schemas to prevent errors\n- Function calling enforces structure\n- Validation happens before state mutation\n\n### Boundary Rules\n\n| Component | Can Access | Cannot Access |\n|-----------|-----------|---------------|\n| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |\n| `MenuProvider` | Menu JSON file | Order state, LLM |\n| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |\n| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |\n| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |\n| `DriveThruAgent` | Everything (orchestrator) | N/A |\n\n**Dependency Flow** (always downward, never circular):\n```\nDriveThruAgent\n    ├─> OrderStateManager\n    ├─> MenuProvider\n    ├─> OrderTools\n    │       ├─> menu_validation.py\n    │       ├─> OrderStateManager\n    │       └─> MenuProvider\n    └─> DriveThruLLM\n            └─> MenuProvider\n```\n\n### Testing Strategy\n\n**Unit Tests** (Fast, isolated, many)\n- `test_menu_validation.py`: Pure functions, no mocks needed\n- `test_menu_provider.py`: Test with fixture JSON\n- `test_order_state.py`: In-memory state, temp file I/O\n- `test_drive_thru_llm.py`: Mock wrapped LLM\n\n**Integration Tests** (Medium speed, some mocks)\n- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager\n\n**E2E Tests** (Slow, real components, few)\n- `test_drive_thru_agent.py`: Full agent with judge-based evaluation\n- `test_accuracy.py`: Accuracy benchmarks\n\n**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.\n\n---\n\n## 1. System Architecture"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":386,"cache_read_input_tokens":57075,"cache_creation":{"ephemeral_5m_input_tokens":386,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ2MbPZioAb8aPvmSxV","type":"assistant","uuid":"be87b125-4789-4ea7-afac-5bac44361146","timestamp":"2026-01-21T23:33:46.369Z"}
{"parentUuid":"be87b125-4789-4ea7-afac-5bac44361146","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016NwME9ss2jcf8vwdUtXwVL","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"d6465c47-706e-4fe1-ae91-aa8fe8a2f777","timestamp":"2026-01-21T23:33:46.656Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"---\n\n## 1. System Architecture","newString":"---\n\n## 0. Clean Architecture Principles (Kent Beck + Dave Farley)\n\nThis implementation follows clean architecture principles for maintainability, testability, and continuous delivery.\n\n### Core Principles Checklist\n\n**✓ Single Responsibility Principle (SRP)**\n- Each component has one reason to change\n- DriveThruLLM: Context injection only (no state)\n- OrderStateManager: State + persistence only\n- MenuProvider: Read-only data access only\n- menu_validation.py: Pure validation functions only\n\n**✓ Dependency Inversion**\n- Components receive dependencies via constructor (DI)\n- High-level components don't depend on low-level details\n- Easy to mock, easy to test, easy to swap\n\n**✓ Pure Functions Where Possible**\n- menu_validation.py: 100% pure functions\n- No I/O, no side effects, fully deterministic\n- Fast, testable, reusable\n\n**✓ Immutability Reduces Bugs**\n- MenuProvider returns immutable data\n- Menu cannot be accidentally corrupted\n- Thread-safe by design\n\n**✓ Single Source of Truth**\n- OrderStateManager is ONLY owner of order state\n- All mutations flow through one place\n- Easy to debug, easy to audit, easy to test\n\n**✓ Tell, Don't Ask**\n- Tools tell OrderStateManager what to do\n- Don't query state, mutate it, then write back\n- Reduces coupling, increases cohesion\n\n**✓ Test Pyramid**\n- Many fast unit tests (milliseconds)\n- Some integration tests (seconds)\n- Few E2E tests (minutes)\n- Fast feedback loops enable TDD\n\n**✓ Make Invalid States Unrepresentable**\n- Use type system + schemas to prevent errors\n- Function calling enforces structure\n- Validation happens before state mutation\n\n### Boundary Rules\n\n| Component | Can Access | Cannot Access |\n|-----------|-----------|---------------|\n| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |\n| `MenuProvider` | Menu JSON file | Order state, LLM |\n| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |\n| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |\n| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |\n| `DriveThruAgent` | Everything (orchestrator) | N/A |\n\n**Dependency Flow** (always downward, never circular):\n```\nDriveThruAgent\n    ├─> OrderStateManager\n    ├─> MenuProvider\n    ├─> OrderTools\n    │       ├─> menu_validation.py\n    │       ├─> OrderStateManager\n    │       └─> MenuProvider\n    └─> DriveThruLLM\n            └─> MenuProvider\n```\n\n### Testing Strategy\n\n**Unit Tests** (Fast, isolated, many)\n- `test_menu_validation.py`: Pure functions, no mocks needed\n- `test_menu_provider.py`: Test with fixture JSON\n- `test_order_state.py`: In-memory state, temp file I/O\n- `test_drive_thru_llm.py`: Mock wrapped LLM\n\n**Integration Tests** (Medium speed, some mocks)\n- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager\n\n**E2E Tests** (Slow, real components, few)\n- `test_drive_thru_agent.py`: Full agent with judge-based evaluation\n- `test_accuracy.py`: Accuracy benchmarks\n\n**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.\n\n---\n\n## 1. System Architecture","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)\n\n### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy\n\n### Phase 3: Agent Integration (Wire everything together)\n\n**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n\n#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n- [ ] Implement `DriveThruAgent` class\n  - Constructor receives: order_state, menu_provider, config\n  - Sets drive-thru specific instructions (system prompt)\n  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  - Agent OWNS OrderStateManager (composition)\n  - Agent RECEIVES MenuProvider (dependency injection)\n- [ ] Define agent instructions/persona\n  - Concise, friendly, efficient\n  - Clear about when to use tools\n  - Handles confirmation flow\n\n#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n- [ ] Add `DriveThruConfig` to `src/config.py`\n  - menu_file_path, orders_output_dir\n  - fuzzy_match_threshold, max_context_items\n  - enable_confirmation_loop, enable_semantic_search\n- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  - Instantiate MenuProvider (singleton, loaded once)\n  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  - Create OrderStateManager for each session (session_handler)\n  - Create DriveThruAgent (injecting order_state and menu_provider)\n  - Wire to SessionHandler\n- [ ] Verify dependency flow:\n  ```\n  App creates MenuProvider (singleton)\n     ├─> Injects into DriveThruLLM wrapper\n     ├─> Injects into DriveThruAgent\n     └─> Injects into OrderTools\n\n  App creates OrderStateManager per session\n     ├─> Owned by DriveThruAgent\n     └─> Passed to OrderTools\n  ```\n\n#### Step 3.3: Integration Testing\n- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  - No mocked components, real coordination\n  - Verify end-to-end flow: validate → add → log\n- [ ] Test console mode end-to-end\n  - Use mock LLM or real LLM with simple prompts\n  - Verify order state is persisted correctly\n  - Verify incremental logs and final JSON\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Separate DriveThruLLM from OrderStateManager?\n**Principle**: Single Responsibility Principle (SRP)\n\nLLM wrapping (context injection) is orthogonal to state management. By separating:\n- DriveThruLLM can be tested with mock LLM (fast unit tests)\n- OrderStateManager can be tested without LLM (fast unit tests)\n- Each component has one reason to change\n- Components can be swapped independently (e.g., try different context injection strategies)\n\n### Why Pure Functions for Validation?\n**Principle**: Functional Core, Imperative Shell\n\nPure functions are maximally testable:\n- No I/O, no side effects\n- Deterministic outputs for same inputs\n- Fast to execute (no database, no API calls)\n- Easy to reason about\n- Can be reused anywhere\n\nThis enables Test-Driven Development: write test first, implement function, iterate quickly.\n\n### Why MenuProvider Returns Immutable Data?\n**Principle**: Immutability Reduces Bugs\n\nIf MenuProvider returned mutable references:\n- Callers could accidentally modify menu data\n- Hard to track down where menu was corrupted\n- Thread safety issues in concurrent sessions\n\nBy returning immutable copies:\n- Menu data is protected from accidental mutation\n- Single source of truth guaranteed\n- Easier to reason about data flow\n\n### Why OrderStateManager is the Only State Owner?\n**Principle**: Single Source of Truth (SSOT)\n\nAll order mutations flow through one place:\n- Easy to add logging/auditing\n- Persistence logic centralized\n- Impossible to have inconsistent state\n- Debugging is straightforward: check one component\n- Testing is simple: verify state before/after\n\nContrast with diffused state (anti-pattern):\n- State scattered across DriveThruLLM, tools, agent\n- Hard to debug: \"Where did this item come from?\"\n- Hard to test: need to set up multiple components\n- Brittle: changes ripple across multiple components\n\n### Why Tools are Thin Coordination Layer?\n**Principle**: Tell, Don't Ask\n\nTools coordinate but don't implement logic:\n```python\n# Good (coordination)\ndef add_item_to_order_tool(...):\n    result = validate_order_item(...)  # Ask validation layer\n    if result.is_valid:\n        order_state.add_item(...)      # Tell state manager\n    return confirmation\n\n# Bad (implementation leaking into tool)\ndef add_item_to_order_tool(...):\n    # Fuzzy matching logic here\n    # Modifier validation logic here\n    # File I/O logic here\n    # Now tool is hard to test and has multiple responsibilities\n```\n\n### Why Function Calling?\n**Principle**: Make Invalid States Unrepresentable\n\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\nSchema enforcement means: \"If it parses, it's valid\" (or close to it).\n\n### Why Multiple Strategies?\n**Principle**: Defense in Depth\n\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.\n\n### Why Confirmation Loop?\n**Principle**: Human-in-the-Loop\n\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.\n\n### Why Incremental Logging?\n**Principle**: Observability & Debuggability\n\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.\n\nEnables data-driven improvement: analyze logs to find common error patterns.\n\n### Why Focus on Accuracy Over Speed?\n**Principle**: Correctness First, Optimization Second\n\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\nPremature optimization is the root of all evil. Get it working, get it right, then make it fast.\n\n### Why Test Pyramid (Many Unit, Few E2E)?\n**Principle**: Fast Feedback Loops (Continuous Delivery)\n\nUnit tests:\n- Run in milliseconds\n- Give instant feedback\n- Pinpoint exact failure\n- Enable rapid iteration\n\nE2E tests:\n- Run in seconds/minutes\n- Slow feedback\n- Hard to debug failures\n- Necessary but expensive\n\nBuild on solid foundation of fast unit tests, use E2E tests for critical paths only.\n\n### Why Dependency Injection?\n**Principle**: Inversion of Control (IoC)\n\nComponents receive dependencies rather than creating them:\n- Easy to substitute mocks for testing\n- Easy to swap implementations (e.g., different LLM, different storage)\n- Explicit dependencies (no hidden coupling)\n- Testable in isolation\n\n```python\n# Good (DI)\nclass DriveThruAgent:\n    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):\n        self.order_state = order_state  # Injected\n        self.menu = menu                # Injected\n\n# Bad (hidden dependencies)\nclass DriveThruAgent:\n    def __init__(self):\n        self.order_state = OrderStateManager()  # Hard-coded\n        self.menu = MenuProvider()              # Hard-coded\n        # Now can't test with mocks, can't swap implementations\n```\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":12,"oldLines":6,"newStart":12,"newLines":98,"lines":[" "," ---"," ","+## 0. Clean Architecture Principles (Kent Beck + Dave Farley)","+","+This implementation follows clean architecture principles for maintainability, testability, and continuous delivery.","+","+### Core Principles Checklist","+","+**✓ Single Responsibility Principle (SRP)**","+- Each component has one reason to change","+- DriveThruLLM: Context injection only (no state)","+- OrderStateManager: State + persistence only","+- MenuProvider: Read-only data access only","+- menu_validation.py: Pure validation functions only","+","+**✓ Dependency Inversion**","+- Components receive dependencies via constructor (DI)","+- High-level components don't depend on low-level details","+- Easy to mock, easy to test, easy to swap","+","+**✓ Pure Functions Where Possible**","+- menu_validation.py: 100% pure functions","+- No I/O, no side effects, fully deterministic","+- Fast, testable, reusable","+","+**✓ Immutability Reduces Bugs**","+- MenuProvider returns immutable data","+- Menu cannot be accidentally corrupted","+- Thread-safe by design","+","+**✓ Single Source of Truth**","+- OrderStateManager is ONLY owner of order state","+- All mutations flow through one place","+- Easy to debug, easy to audit, easy to test","+","+**✓ Tell, Don't Ask**","+- Tools tell OrderStateManager what to do","+- Don't query state, mutate it, then write back","+- Reduces coupling, increases cohesion","+","+**✓ Test Pyramid**","+- Many fast unit tests (milliseconds)","+- Some integration tests (seconds)","+- Few E2E tests (minutes)","+- Fast feedback loops enable TDD","+","+**✓ Make Invalid States Unrepresentable**","+- Use type system + schemas to prevent errors","+- Function calling enforces structure","+- Validation happens before state mutation","+","+### Boundary Rules","+","+| Component | Can Access | Cannot Access |","+|-----------|-----------|---------------|","+| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |","+| `MenuProvider` | Menu JSON file | Order state, LLM |","+| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |","+| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |","+| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |","+| `DriveThruAgent` | Everything (orchestrator) | N/A |","+","+**Dependency Flow** (always downward, never circular):","+```","+DriveThruAgent","+    ├─> OrderStateManager","+    ├─> MenuProvider","+    ├─> OrderTools","+    │       ├─> menu_validation.py","+    │       ├─> OrderStateManager","+    │       └─> MenuProvider","+    └─> DriveThruLLM","+            └─> MenuProvider","+```","+","+### Testing Strategy","+","+**Unit Tests** (Fast, isolated, many)","+- `test_menu_validation.py`: Pure functions, no mocks needed","+- `test_menu_provider.py`: Test with fixture JSON","+- `test_order_state.py`: In-memory state, temp file I/O","+- `test_drive_thru_llm.py`: Mock wrapped LLM","+","+**Integration Tests** (Medium speed, some mocks)","+- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager","+","+**E2E Tests** (Slow, real components, few)","+- `test_drive_thru_agent.py`: Full agent with judge-based evaluation","+- `test_accuracy.py`: Accuracy benchmarks","+","+**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.","+","+---","+"," ## 1. System Architecture"," "," ### 1.1 Core Components & Data Flow"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"be87b125-4789-4ea7-afac-5bac44361146"}
{"parentUuid":"d6465c47-706e-4fe1-ae91-aa8fe8a2f777","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TqTW4cn4V2ULy4k3Hwq9i8","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Perfect! Now let me make one more edit to ensure the order state model section reflects the clean boundaries.","signature":"EpUCCkYICxgCKkDzwdNyTjfYVfXZyPKi1WR4dXaMtwF2VLSjRAtyJ8CnoUVbtheisRUOV4O2o1YX7gk+wBrmPbQW+xOU2J41s6D2EgwVeXGlZ7YPV3shc/YaDEVKLu49JfJ90vOLgCIwb65oJAHt8wIOpgcpoHeP/Y7UOnnT5XbrhE+4NdJdqMGkofxrifPj10D9BuS4tn/gKn3FnwCjyZjyT4RBRU4EDpuzBYBeKqt5VOEQVkhXX8oQQKxCEz/hPBGeyDcljzH1KiA/waah9P3nUvs4IuqED5O1VCjoVKJpqs9DuCXaMEkHlSXOZaOOEg4Lm0C02663VBdPCkvNLSs/yup69UJHCsedoqzeN8ixTo6tXZCD8RgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1132,"cache_read_input_tokens":57461,"cache_creation":{"ephemeral_5m_input_tokens":1132,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ3S3JtJvJYhuRqT6FN","type":"assistant","uuid":"261e72f7-af49-45a5-981b-9f681e5596b6","timestamp":"2026-01-21T23:33:48.862Z"}
{"parentUuid":"261e72f7-af49-45a5-981b-9f681e5596b6","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TqTW4cn4V2ULy4k3Hwq9i8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01982aysicpVBhkrNmiPXQUK","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","offset":500,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1132,"cache_read_input_tokens":57461,"cache_creation":{"ephemeral_5m_input_tokens":1132,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ3S3JtJvJYhuRqT6FN","type":"assistant","uuid":"36068773-42c9-4004-91be-613c3d7e28e2","timestamp":"2026-01-21T23:33:49.495Z"}
{"parentUuid":"36068773-42c9-4004-91be-613c3d7e28e2","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01982aysicpVBhkrNmiPXQUK","type":"tool_result","content":"   500→\n   501→---\n   502→\n   503→#### Strategy 2: Menu Context Injection\n   504→**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n   505→\n   506→**Implementation**:\n   507→- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n   508→- Fetch relevant menu items from Menu model\n   509→- Include in system prompt: \"Available items: [filtered list]\"\n   510→- Reduces hallucination by showing exact menu item names\n   511→\n   512→**Example**:\n   513→```\n   514→Customer: \"I'd like a Big Mac\"\n   515→→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n   516→```\n   517→\n   518→**Pros**:\n   519→- Reduces hallucination\n   520→- Helps with exact item name matching\n   521→- Context-aware\n   522→\n   523→**Cons**:\n   524→- Increases token usage\n   525→- May miss items if keyword matching fails\n   526→\n   527→**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n   528→\n   529→---\n   530→\n   531→#### Strategy 3: Explicit Confirmation Loop\n   532→**Approach**: After each item is understood, explicitly confirm with customer.\n   533→\n   534→**Implementation**:\n   535→- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n   536→- Customer can correct if wrong\n   537→- Only write to order file after confirmation\n   538→\n   539→**Example Flow**:\n   540→```\n   541→Customer: \"Big Mac please\"\n   542→Agent: \"One Big Mac - is that correct?\"\n   543→Customer: \"Yes\"\n   544→Agent: \"Great! Anything else?\"\n   545→[Write to order file]\n   546→```\n   547→\n   548→**Pros**:\n   549→- Allows error correction\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"538e47d8-6bb7-49cb-9bb2-9619b980b524","timestamp":"2026-01-21T23:33:49.763Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","content":"\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction","numLines":50,"startLine":500,"totalLines":1584}},"sourceToolAssistantUUID":"36068773-42c9-4004-91be-613c3d7e28e2"}
{"parentUuid":"538e47d8-6bb7-49cb-9bb2-9619b980b524","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01RyPXhjv7sAhwUBJF8gggkv","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me update the section that talks about \"where strategies are implemented\" to make it clear which component owns what.","signature":"EqICCkYICxgCKkA/1Gj33ls7wQlfZOY7yPvS+IriOD0PKgVbii3BejyumOP79+bEQKVbSApQ4RHXLSJ4bh7pMvtg0SSyfzkrvjHrEgyltEhZjWMQGuECcXcaDCbquD8A0gtvxsUgDSIwLALhvPZE0eAyk+q3MQAAMfwFbTqrmo13RRKJx0p/BNosXh+5D/GC9RMNOmuj5zppKokBXfAOH8WI2IDBKaLg4cmckabFr8eQ3zN3QGfAgC1ke/U+FMihA/M2fCl114uUEHcrZUtg7Fjmv4qPibEwT9eiyTJ+VfY9OZ+gatDdSKIh1ryW/lYHzO8/HXr3UZggM5zoTx7e1k7cqdWW4rhkW6E0EVxpkUBAMrBUPHvexpAfGFo9luMOECuWkDwYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":776,"cache_read_input_tokens":58593,"cache_creation":{"ephemeral_5m_input_tokens":776,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ3fMWG5AcVTdka7M8G","type":"assistant","uuid":"f3acbe66-6f50-4a27-b4bf-a3ca2d2985fd","timestamp":"2026-01-21T23:33:51.967Z"}
{"parentUuid":"f3acbe66-6f50-4a27-b4bf-a3ca2d2985fd","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01RyPXhjv7sAhwUBJF8gggkv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EBsuLV5oVx6Q3xGJo1C76j","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed","new_string":"### Recommended Strategy Combination & Component Ownership\n\nEach strategy is owned by a specific component, following SRP.\n\n**Phase 1 (MVP)**:\n1. **Function Calling** (Strategy 1)\n   - Owner: `OrderTools` (defines tool schemas)\n   - Core structure for order taking\n\n2. **Menu Context Injection** (Strategy 2)\n   - Owner: `DriveThruLLM` (injects context in chat())\n   - Grounding LLM in actual menu\n\n3. **Fuzzy String Matching** (Strategy 4)\n   - Owner: `menu_validation.py` (pure function)\n   - STT error handling\n\n4. **Post-Processing Validation** (Strategy 9)\n   - Owner: `OrderTools` (validates before state mutation)\n   - Safety net - validate before add_item()\n\n**Phase 2 (Optimization)**:\n5. **Explicit Confirmation Loop** (Strategy 3)\n   - Owner: `DriveThruAgent` (instructions/conversation flow)\n   - User validation\n\n6. **Semantic Search** (Strategy 5)\n   - Owner: `MenuProvider` (add embedding-based search method)\n   - Better matching via semantics\n\n**Phase 3 (Advanced)**:\n7. **Two-Stage Parsing** (Strategy 6)\n   - Owner: `OrderTools` (modify tool implementation)\n   - If needed for complex orders\n\n8. **Chain-of-Thought** (Strategy 7)\n   - Owner: `DriveThruAgent` (modify instructions)\n   - If needed for better reasoning\n\n**Key Insight**: Each strategy lives in exactly one component. This:\n- Makes it easy to A/B test strategies (change one component)\n- Enables independent testing of strategies\n- Prevents strategy logic from leaking across boundaries"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":776,"cache_read_input_tokens":58593,"cache_creation":{"ephemeral_5m_input_tokens":776,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ3fMWG5AcVTdka7M8G","type":"assistant","uuid":"a618567c-f7b9-4e51-9e11-c8e8253ad2a6","timestamp":"2026-01-21T23:33:59.496Z"}
{"parentUuid":"a618567c-f7b9-4e51-9e11-c8e8253ad2a6","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EBsuLV5oVx6Q3xGJo1C76j","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"786f6578-0412-4303-ac9e-7fe9adcf9fe9","timestamp":"2026-01-21T23:33:59.734Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed","newString":"### Recommended Strategy Combination & Component Ownership\n\nEach strategy is owned by a specific component, following SRP.\n\n**Phase 1 (MVP)**:\n1. **Function Calling** (Strategy 1)\n   - Owner: `OrderTools` (defines tool schemas)\n   - Core structure for order taking\n\n2. **Menu Context Injection** (Strategy 2)\n   - Owner: `DriveThruLLM` (injects context in chat())\n   - Grounding LLM in actual menu\n\n3. **Fuzzy String Matching** (Strategy 4)\n   - Owner: `menu_validation.py` (pure function)\n   - STT error handling\n\n4. **Post-Processing Validation** (Strategy 9)\n   - Owner: `OrderTools` (validates before state mutation)\n   - Safety net - validate before add_item()\n\n**Phase 2 (Optimization)**:\n5. **Explicit Confirmation Loop** (Strategy 3)\n   - Owner: `DriveThruAgent` (instructions/conversation flow)\n   - User validation\n\n6. **Semantic Search** (Strategy 5)\n   - Owner: `MenuProvider` (add embedding-based search method)\n   - Better matching via semantics\n\n**Phase 3 (Advanced)**:\n7. **Two-Stage Parsing** (Strategy 6)\n   - Owner: `OrderTools` (modify tool implementation)\n   - If needed for complex orders\n\n8. **Chain-of-Thought** (Strategy 7)\n   - Owner: `DriveThruAgent` (modify instructions)\n   - If needed for better reasoning\n\n**Key Insight**: Each strategy lives in exactly one component. This:\n- Makes it easy to A/B test strategies (change one component)\n- Enables independent testing of strategies\n- Prevents strategy logic from leaking across boundaries","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 0. Clean Architecture Principles (Kent Beck + Dave Farley)\n\nThis implementation follows clean architecture principles for maintainability, testability, and continuous delivery.\n\n### Core Principles Checklist\n\n**✓ Single Responsibility Principle (SRP)**\n- Each component has one reason to change\n- DriveThruLLM: Context injection only (no state)\n- OrderStateManager: State + persistence only\n- MenuProvider: Read-only data access only\n- menu_validation.py: Pure validation functions only\n\n**✓ Dependency Inversion**\n- Components receive dependencies via constructor (DI)\n- High-level components don't depend on low-level details\n- Easy to mock, easy to test, easy to swap\n\n**✓ Pure Functions Where Possible**\n- menu_validation.py: 100% pure functions\n- No I/O, no side effects, fully deterministic\n- Fast, testable, reusable\n\n**✓ Immutability Reduces Bugs**\n- MenuProvider returns immutable data\n- Menu cannot be accidentally corrupted\n- Thread-safe by design\n\n**✓ Single Source of Truth**\n- OrderStateManager is ONLY owner of order state\n- All mutations flow through one place\n- Easy to debug, easy to audit, easy to test\n\n**✓ Tell, Don't Ask**\n- Tools tell OrderStateManager what to do\n- Don't query state, mutate it, then write back\n- Reduces coupling, increases cohesion\n\n**✓ Test Pyramid**\n- Many fast unit tests (milliseconds)\n- Some integration tests (seconds)\n- Few E2E tests (minutes)\n- Fast feedback loops enable TDD\n\n**✓ Make Invalid States Unrepresentable**\n- Use type system + schemas to prevent errors\n- Function calling enforces structure\n- Validation happens before state mutation\n\n### Boundary Rules\n\n| Component | Can Access | Cannot Access |\n|-----------|-----------|---------------|\n| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |\n| `MenuProvider` | Menu JSON file | Order state, LLM |\n| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |\n| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |\n| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |\n| `DriveThruAgent` | Everything (orchestrator) | N/A |\n\n**Dependency Flow** (always downward, never circular):\n```\nDriveThruAgent\n    ├─> OrderStateManager\n    ├─> MenuProvider\n    ├─> OrderTools\n    │       ├─> menu_validation.py\n    │       ├─> OrderStateManager\n    │       └─> MenuProvider\n    └─> DriveThruLLM\n            └─> MenuProvider\n```\n\n### Testing Strategy\n\n**Unit Tests** (Fast, isolated, many)\n- `test_menu_validation.py`: Pure functions, no mocks needed\n- `test_menu_provider.py`: Test with fixture JSON\n- `test_order_state.py`: In-memory state, temp file I/O\n- `test_drive_thru_llm.py`: Mock wrapped LLM\n\n**Integration Tests** (Medium speed, some mocks)\n- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager\n\n**E2E Tests** (Slow, real components, few)\n- `test_drive_thru_agent.py`: Full agent with judge-based evaluation\n- `test_accuracy.py`: Accuracy benchmarks\n\n**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination\n\n**Phase 1 (MVP)**:\n1. Function Calling (Strategy 1) - Core structure\n2. Menu Context Injection (Strategy 2) - Grounding\n3. Fuzzy String Matching (Strategy 4) - STT error handling\n4. Post-Processing Validation (Strategy 9) - Safety net\n\n**Phase 2 (Optimization)**:\n5. Explicit Confirmation Loop (Strategy 3) - User validation\n6. Semantic Search (Strategy 5) - Better matching\n\n**Phase 3 (Advanced)**:\n7. Two-Stage Parsing (Strategy 6) - If needed\n8. Chain-of-Thought (Strategy 7) - If needed\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)\n\n### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy\n\n### Phase 3: Agent Integration (Wire everything together)\n\n**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n\n#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n- [ ] Implement `DriveThruAgent` class\n  - Constructor receives: order_state, menu_provider, config\n  - Sets drive-thru specific instructions (system prompt)\n  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  - Agent OWNS OrderStateManager (composition)\n  - Agent RECEIVES MenuProvider (dependency injection)\n- [ ] Define agent instructions/persona\n  - Concise, friendly, efficient\n  - Clear about when to use tools\n  - Handles confirmation flow\n\n#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n- [ ] Add `DriveThruConfig` to `src/config.py`\n  - menu_file_path, orders_output_dir\n  - fuzzy_match_threshold, max_context_items\n  - enable_confirmation_loop, enable_semantic_search\n- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  - Instantiate MenuProvider (singleton, loaded once)\n  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  - Create OrderStateManager for each session (session_handler)\n  - Create DriveThruAgent (injecting order_state and menu_provider)\n  - Wire to SessionHandler\n- [ ] Verify dependency flow:\n  ```\n  App creates MenuProvider (singleton)\n     ├─> Injects into DriveThruLLM wrapper\n     ├─> Injects into DriveThruAgent\n     └─> Injects into OrderTools\n\n  App creates OrderStateManager per session\n     ├─> Owned by DriveThruAgent\n     └─> Passed to OrderTools\n  ```\n\n#### Step 3.3: Integration Testing\n- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  - No mocked components, real coordination\n  - Verify end-to-end flow: validate → add → log\n- [ ] Test console mode end-to-end\n  - Use mock LLM or real LLM with simple prompts\n  - Verify order state is persisted correctly\n  - Verify incremental logs and final JSON\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Separate DriveThruLLM from OrderStateManager?\n**Principle**: Single Responsibility Principle (SRP)\n\nLLM wrapping (context injection) is orthogonal to state management. By separating:\n- DriveThruLLM can be tested with mock LLM (fast unit tests)\n- OrderStateManager can be tested without LLM (fast unit tests)\n- Each component has one reason to change\n- Components can be swapped independently (e.g., try different context injection strategies)\n\n### Why Pure Functions for Validation?\n**Principle**: Functional Core, Imperative Shell\n\nPure functions are maximally testable:\n- No I/O, no side effects\n- Deterministic outputs for same inputs\n- Fast to execute (no database, no API calls)\n- Easy to reason about\n- Can be reused anywhere\n\nThis enables Test-Driven Development: write test first, implement function, iterate quickly.\n\n### Why MenuProvider Returns Immutable Data?\n**Principle**: Immutability Reduces Bugs\n\nIf MenuProvider returned mutable references:\n- Callers could accidentally modify menu data\n- Hard to track down where menu was corrupted\n- Thread safety issues in concurrent sessions\n\nBy returning immutable copies:\n- Menu data is protected from accidental mutation\n- Single source of truth guaranteed\n- Easier to reason about data flow\n\n### Why OrderStateManager is the Only State Owner?\n**Principle**: Single Source of Truth (SSOT)\n\nAll order mutations flow through one place:\n- Easy to add logging/auditing\n- Persistence logic centralized\n- Impossible to have inconsistent state\n- Debugging is straightforward: check one component\n- Testing is simple: verify state before/after\n\nContrast with diffused state (anti-pattern):\n- State scattered across DriveThruLLM, tools, agent\n- Hard to debug: \"Where did this item come from?\"\n- Hard to test: need to set up multiple components\n- Brittle: changes ripple across multiple components\n\n### Why Tools are Thin Coordination Layer?\n**Principle**: Tell, Don't Ask\n\nTools coordinate but don't implement logic:\n```python\n# Good (coordination)\ndef add_item_to_order_tool(...):\n    result = validate_order_item(...)  # Ask validation layer\n    if result.is_valid:\n        order_state.add_item(...)      # Tell state manager\n    return confirmation\n\n# Bad (implementation leaking into tool)\ndef add_item_to_order_tool(...):\n    # Fuzzy matching logic here\n    # Modifier validation logic here\n    # File I/O logic here\n    # Now tool is hard to test and has multiple responsibilities\n```\n\n### Why Function Calling?\n**Principle**: Make Invalid States Unrepresentable\n\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\nSchema enforcement means: \"If it parses, it's valid\" (or close to it).\n\n### Why Multiple Strategies?\n**Principle**: Defense in Depth\n\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.\n\n### Why Confirmation Loop?\n**Principle**: Human-in-the-Loop\n\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.\n\n### Why Incremental Logging?\n**Principle**: Observability & Debuggability\n\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.\n\nEnables data-driven improvement: analyze logs to find common error patterns.\n\n### Why Focus on Accuracy Over Speed?\n**Principle**: Correctness First, Optimization Second\n\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\nPremature optimization is the root of all evil. Get it working, get it right, then make it fast.\n\n### Why Test Pyramid (Many Unit, Few E2E)?\n**Principle**: Fast Feedback Loops (Continuous Delivery)\n\nUnit tests:\n- Run in milliseconds\n- Give instant feedback\n- Pinpoint exact failure\n- Enable rapid iteration\n\nE2E tests:\n- Run in seconds/minutes\n- Slow feedback\n- Hard to debug failures\n- Necessary but expensive\n\nBuild on solid foundation of fast unit tests, use E2E tests for critical paths only.\n\n### Why Dependency Injection?\n**Principle**: Inversion of Control (IoC)\n\nComponents receive dependencies rather than creating them:\n- Easy to substitute mocks for testing\n- Easy to swap implementations (e.g., different LLM, different storage)\n- Explicit dependencies (no hidden coupling)\n- Testable in isolation\n\n```python\n# Good (DI)\nclass DriveThruAgent:\n    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):\n        self.order_state = order_state  # Injected\n        self.menu = menu                # Injected\n\n# Bad (hidden dependencies)\nclass DriveThruAgent:\n    def __init__(self):\n        self.order_state = OrderStateManager()  # Hard-coded\n        self.menu = MenuProvider()              # Hard-coded\n        # Now can't test with mocks, can't swap implementations\n```\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":751,"oldLines":22,"newStart":751,"newLines":50,"lines":[" "," ---"," ","-### Recommended Strategy Combination","+### Recommended Strategy Combination & Component Ownership"," ","+Each strategy is owned by a specific component, following SRP.","+"," **Phase 1 (MVP)**:","-1. Function Calling (Strategy 1) - Core structure","-2. Menu Context Injection (Strategy 2) - Grounding","-3. Fuzzy String Matching (Strategy 4) - STT error handling","-4. Post-Processing Validation (Strategy 9) - Safety net","+1. **Function Calling** (Strategy 1)","+   - Owner: `OrderTools` (defines tool schemas)","+   - Core structure for order taking"," ","+2. **Menu Context Injection** (Strategy 2)","+   - Owner: `DriveThruLLM` (injects context in chat())","+   - Grounding LLM in actual menu","+","+3. **Fuzzy String Matching** (Strategy 4)","+   - Owner: `menu_validation.py` (pure function)","+   - STT error handling","+","+4. **Post-Processing Validation** (Strategy 9)","+   - Owner: `OrderTools` (validates before state mutation)","+   - Safety net - validate before add_item()","+"," **Phase 2 (Optimization)**:","-5. Explicit Confirmation Loop (Strategy 3) - User validation","-6. Semantic Search (Strategy 5) - Better matching","+5. **Explicit Confirmation Loop** (Strategy 3)","+   - Owner: `DriveThruAgent` (instructions/conversation flow)","+   - User validation"," ","+6. **Semantic Search** (Strategy 5)","+   - Owner: `MenuProvider` (add embedding-based search method)","+   - Better matching via semantics","+"," **Phase 3 (Advanced)**:","-7. Two-Stage Parsing (Strategy 6) - If needed","-8. Chain-of-Thought (Strategy 7) - If needed","+7. **Two-Stage Parsing** (Strategy 6)","+   - Owner: `OrderTools` (modify tool implementation)","+   - If needed for complex orders"," ","+8. **Chain-of-Thought** (Strategy 7)","+   - Owner: `DriveThruAgent` (modify instructions)","+   - If needed for better reasoning","+","+**Key Insight**: Each strategy lives in exactly one component. This:","+- Makes it easy to A/B test strategies (change one component)","+- Enables independent testing of strategies","+- Prevents strategy logic from leaking across boundaries","+"," ---"," "," ## 3. Order State Management"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a618567c-f7b9-4e51-9e11-c8e8253ad2a6"}
{"parentUuid":"786f6578-0412-4303-ac9e-7fe9adcf9fe9","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013UT6bbVe76bvCj7XW3pjLM","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Great! Now let me finalize by adding one more edit to the Order State Model section to clarify the clean separation there as well.","signature":"EqsCCkYICxgCKkAyZKYMLz3IFLMCSLH1dP50TrXFDHKTZgMvd4DQfLa3ZwDKhug8zDRWdu2tpOfLQW0bJe8hzZE2Ff9SZBMLMSbFEgyZAGqHIyHnX9Ee2KIaDMPNCj4wDXQxE6beYCIwADP1sSzRQLRb2SsbVXaS9sEGQtftecw+k7xBFFn9RFDeiAU/XBPlAvlVIMay/v1QKpIBPLwoaWCYbXtom1u94S4WE2j9vPbsUYGRXCfK8mKy9pV4AHRDeZhSuvxsnE5PMLUtsmcL4FYWucnE6a89T73m7U82Wc5Q/a2SaLvcyjdHDqe29rstwHM88iqkhCw2A9qEqrVdqP00zsUIhJjdKFcb/W+9Qdhb97Yfh/Ta5P2jM0loDZljHklhs3fgVY7mpT2YAm4YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":835,"cache_read_input_tokens":59369,"cache_creation":{"ephemeral_5m_input_tokens":835,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ4P1XHRjTNUSUnnxMz","type":"assistant","uuid":"6392acdc-1145-4027-9f32-8100f52a86d9","timestamp":"2026-01-21T23:34:01.657Z"}
{"parentUuid":"6392acdc-1145-4027-9f32-8100f52a86d9","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013UT6bbVe76bvCj7XW3pjLM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qtr3AaGd2fkTbiriaKTLDc","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","offset":660,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":835,"cache_read_input_tokens":59369,"cache_creation":{"ephemeral_5m_input_tokens":835,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ4P1XHRjTNUSUnnxMz","type":"assistant","uuid":"9f7a555e-f659-4348-abe5-de36d03ac449","timestamp":"2026-01-21T23:34:02.237Z"}
{"parentUuid":"9f7a555e-f659-4348-abe5-de36d03ac449","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qtr3AaGd2fkTbiriaKTLDc","type":"tool_result","content":"   660→- More interpretable\n   661→- Can catch logic errors\n   662→\n   663→**Cons**:\n   664→- Increases token usage\n   665→- May add latency\n   666→- Reasoning not always visible to customer\n   667→\n   668→**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n   669→\n   670→---\n   671→\n   672→#### Strategy 8: Constrained Decoding\n   673→**Approach**: Use grammar-based constrained generation (if LLM supports it).\n   674→\n   675→**Implementation**:\n   676→- Define grammar for valid responses\n   677→- LLM can only output strings that match the grammar\n   678→- Grammar includes exact menu item names\n   679→\n   680→**Example Grammar**:\n   681→```\n   682→ORDER := <ITEM> | <ITEM> \"and\" <ORDER>\n   683→ITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\n   684→MENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n   685→```\n   686→\n   687→**Pros**:\n   688→- Guarantees valid output\n   689→- No hallucination possible\n   690→- Perfect accuracy for item names\n   691→\n   692→**Cons**:\n   693→- Very few LLMs support this\n   694→- Complex to implement\n   695→- May be too rigid\n   696→\n   697→**Accuracy Impact**: VERY HIGH (9/10) - If available\n   698→\n   699→---\n   700→\n   701→#### Strategy 9: Post-Processing Validation Layer\n   702→**Approach**: Validate every LLM output against menu before speaking to customer.\n   703→\n   704→**Implementation**:\n   705→```python\n   706→class OrderValidator:\n   707→    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n   708→        # Check item exists in menu\n   709→        # Check modifiers are valid for that item\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"a59bd7ce-5085-45e9-8046-699e78763852","timestamp":"2026-01-21T23:34:02.487Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","content":"- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item","numLines":50,"startLine":660,"totalLines":1612}},"sourceToolAssistantUUID":"9f7a555e-f659-4348-abe5-de36d03ac449"}
{"parentUuid":"a59bd7ce-5085-45e9-8046-699e78763852","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013ygXnsy2eovX9gYbTh63mr","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I see the old OrderValidator class reference. Let me find and update that section to be consistent with our pure functions approach.","signature":"Eq0CCkYICxgCKkBbL2Q4LMYQSS0Q0GMj2defuA8IozQQ+0HWV/Bh7sNjHH8mGy8oZCz/af1RJfgiOdP0C5x2qRDz449gfLFdDJWmEgwGcuD1pIMhwjTiyQoaDN6/z+ISfLrYsM6diyIwHbuWH2p/flN6MgwBiiTpxSolD841buFzvy6Ukb8R4DdwWwjS8PM5U9S768zlRr98KpQBfaJnD9EEK4mLfUMgkweL/Erj1RG5jQJXYMI0jlIoikYyj5ZGtqbX2lGF/+pkeFTYYWbXgysmMa43Y87p7Ml3POlc6C+NjfmpYXgFOtdTApfdnzU+zIBSC7RRR4+rC05r1NSF1ZmaKCtRhIm0J4Q76tcjGYesnv/Pq1KokFC+slX4WJzDLQFr899+y5Jv34n4vec3zRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":781,"cache_read_input_tokens":60204,"cache_creation":{"ephemeral_5m_input_tokens":781,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CXMQ4b2L9S1M4G2E5bby3","type":"assistant","uuid":"dcf90236-d1ad-4c66-9e03-5d6ca3b56dd5","timestamp":"2026-01-21T23:34:04.362Z"}
{"parentUuid":"dcf90236-d1ad-4c66-9e03-5d6ca3b56dd5","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013ygXnsy2eovX9gYbTh63mr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FQzKAhQaMaNKkeYAkgMsLc","name":"Edit","input":{"replace_all":false,"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","old_string":"#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```","new_string":"#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before mutating order state.\n\n**Implementation**: Pure function in `menu_validation.py`\n```python\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Pure function: check item exists + modifiers valid.\"\"\"\n    # Check item exists in menu\n    # Check modifiers are valid for that item\n    # Return ValidationResult with matched item or error\n```\n\n**Component Ownership**: `menu_validation.py` (pure functions)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":781,"cache_read_input_tokens":60204,"cache_creation":{"ephemeral_5m_input_tokens":781,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"}},"requestId":"req_011CXMQ4b2L9S1M4G2E5bby3","type":"assistant","uuid":"9cf0e016-a208-4938-ac29-92805320c426","timestamp":"2026-01-21T23:34:07.684Z"}
{"parentUuid":"9cf0e016-a208-4938-ac29-92805320c426","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FQzKAhQaMaNKkeYAkgMsLc","type":"tool_result","content":"The file /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md has been updated successfully."}]},"uuid":"91a71124-268c-49c7-bd13-2ec690cb13c8","timestamp":"2026-01-21T23:34:07.926Z","toolUseResult":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/mcdonalds-drive-thru-agent-plan.md","oldString":"#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```","newString":"#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before mutating order state.\n\n**Implementation**: Pure function in `menu_validation.py`\n```python\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Pure function: check item exists + modifiers valid.\"\"\"\n    # Check item exists in menu\n    # Check modifiers are valid for that item\n    # Return ValidationResult with matched item or error\n```\n\n**Component Ownership**: `menu_validation.py` (pure functions)","originalFile":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 0. Clean Architecture Principles (Kent Beck + Dave Farley)\n\nThis implementation follows clean architecture principles for maintainability, testability, and continuous delivery.\n\n### Core Principles Checklist\n\n**✓ Single Responsibility Principle (SRP)**\n- Each component has one reason to change\n- DriveThruLLM: Context injection only (no state)\n- OrderStateManager: State + persistence only\n- MenuProvider: Read-only data access only\n- menu_validation.py: Pure validation functions only\n\n**✓ Dependency Inversion**\n- Components receive dependencies via constructor (DI)\n- High-level components don't depend on low-level details\n- Easy to mock, easy to test, easy to swap\n\n**✓ Pure Functions Where Possible**\n- menu_validation.py: 100% pure functions\n- No I/O, no side effects, fully deterministic\n- Fast, testable, reusable\n\n**✓ Immutability Reduces Bugs**\n- MenuProvider returns immutable data\n- Menu cannot be accidentally corrupted\n- Thread-safe by design\n\n**✓ Single Source of Truth**\n- OrderStateManager is ONLY owner of order state\n- All mutations flow through one place\n- Easy to debug, easy to audit, easy to test\n\n**✓ Tell, Don't Ask**\n- Tools tell OrderStateManager what to do\n- Don't query state, mutate it, then write back\n- Reduces coupling, increases cohesion\n\n**✓ Test Pyramid**\n- Many fast unit tests (milliseconds)\n- Some integration tests (seconds)\n- Few E2E tests (minutes)\n- Fast feedback loops enable TDD\n\n**✓ Make Invalid States Unrepresentable**\n- Use type system + schemas to prevent errors\n- Function calling enforces structure\n- Validation happens before state mutation\n\n### Boundary Rules\n\n| Component | Can Access | Cannot Access |\n|-----------|-----------|---------------|\n| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |\n| `MenuProvider` | Menu JSON file | Order state, LLM |\n| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |\n| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |\n| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |\n| `DriveThruAgent` | Everything (orchestrator) | N/A |\n\n**Dependency Flow** (always downward, never circular):\n```\nDriveThruAgent\n    ├─> OrderStateManager\n    ├─> MenuProvider\n    ├─> OrderTools\n    │       ├─> menu_validation.py\n    │       ├─> OrderStateManager\n    │       └─> MenuProvider\n    └─> DriveThruLLM\n            └─> MenuProvider\n```\n\n### Testing Strategy\n\n**Unit Tests** (Fast, isolated, many)\n- `test_menu_validation.py`: Pure functions, no mocks needed\n- `test_menu_provider.py`: Test with fixture JSON\n- `test_order_state.py`: In-memory state, temp file I/O\n- `test_drive_thru_llm.py`: Mock wrapped LLM\n\n**Integration Tests** (Medium speed, some mocks)\n- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager\n\n**E2E Tests** (Slow, real components, few)\n- `test_drive_thru_agent.py`: Full agent with judge-based evaluation\n- `test_accuracy.py`: Accuracy benchmarks\n\n**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before speaking to customer.\n\n**Implementation**:\n```python\nclass OrderValidator:\n    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:\n        # Check item exists in menu\n        # Check modifiers are valid for that item\n        # Return corrected version or error\n```\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination & Component Ownership\n\nEach strategy is owned by a specific component, following SRP.\n\n**Phase 1 (MVP)**:\n1. **Function Calling** (Strategy 1)\n   - Owner: `OrderTools` (defines tool schemas)\n   - Core structure for order taking\n\n2. **Menu Context Injection** (Strategy 2)\n   - Owner: `DriveThruLLM` (injects context in chat())\n   - Grounding LLM in actual menu\n\n3. **Fuzzy String Matching** (Strategy 4)\n   - Owner: `menu_validation.py` (pure function)\n   - STT error handling\n\n4. **Post-Processing Validation** (Strategy 9)\n   - Owner: `OrderTools` (validates before state mutation)\n   - Safety net - validate before add_item()\n\n**Phase 2 (Optimization)**:\n5. **Explicit Confirmation Loop** (Strategy 3)\n   - Owner: `DriveThruAgent` (instructions/conversation flow)\n   - User validation\n\n6. **Semantic Search** (Strategy 5)\n   - Owner: `MenuProvider` (add embedding-based search method)\n   - Better matching via semantics\n\n**Phase 3 (Advanced)**:\n7. **Two-Stage Parsing** (Strategy 6)\n   - Owner: `OrderTools` (modify tool implementation)\n   - If needed for complex orders\n\n8. **Chain-of-Thought** (Strategy 7)\n   - Owner: `DriveThruAgent` (modify instructions)\n   - If needed for better reasoning\n\n**Key Insight**: Each strategy lives in exactly one component. This:\n- Makes it easy to A/B test strategies (change one component)\n- Enables independent testing of strategies\n- Prevents strategy logic from leaking across boundaries\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)\n\n### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy\n\n### Phase 3: Agent Integration (Wire everything together)\n\n**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n\n#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n- [ ] Implement `DriveThruAgent` class\n  - Constructor receives: order_state, menu_provider, config\n  - Sets drive-thru specific instructions (system prompt)\n  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  - Agent OWNS OrderStateManager (composition)\n  - Agent RECEIVES MenuProvider (dependency injection)\n- [ ] Define agent instructions/persona\n  - Concise, friendly, efficient\n  - Clear about when to use tools\n  - Handles confirmation flow\n\n#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n- [ ] Add `DriveThruConfig` to `src/config.py`\n  - menu_file_path, orders_output_dir\n  - fuzzy_match_threshold, max_context_items\n  - enable_confirmation_loop, enable_semantic_search\n- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  - Instantiate MenuProvider (singleton, loaded once)\n  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  - Create OrderStateManager for each session (session_handler)\n  - Create DriveThruAgent (injecting order_state and menu_provider)\n  - Wire to SessionHandler\n- [ ] Verify dependency flow:\n  ```\n  App creates MenuProvider (singleton)\n     ├─> Injects into DriveThruLLM wrapper\n     ├─> Injects into DriveThruAgent\n     └─> Injects into OrderTools\n\n  App creates OrderStateManager per session\n     ├─> Owned by DriveThruAgent\n     └─> Passed to OrderTools\n  ```\n\n#### Step 3.3: Integration Testing\n- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  - No mocked components, real coordination\n  - Verify end-to-end flow: validate → add → log\n- [ ] Test console mode end-to-end\n  - Use mock LLM or real LLM with simple prompts\n  - Verify order state is persisted correctly\n  - Verify incremental logs and final JSON\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Separate DriveThruLLM from OrderStateManager?\n**Principle**: Single Responsibility Principle (SRP)\n\nLLM wrapping (context injection) is orthogonal to state management. By separating:\n- DriveThruLLM can be tested with mock LLM (fast unit tests)\n- OrderStateManager can be tested without LLM (fast unit tests)\n- Each component has one reason to change\n- Components can be swapped independently (e.g., try different context injection strategies)\n\n### Why Pure Functions for Validation?\n**Principle**: Functional Core, Imperative Shell\n\nPure functions are maximally testable:\n- No I/O, no side effects\n- Deterministic outputs for same inputs\n- Fast to execute (no database, no API calls)\n- Easy to reason about\n- Can be reused anywhere\n\nThis enables Test-Driven Development: write test first, implement function, iterate quickly.\n\n### Why MenuProvider Returns Immutable Data?\n**Principle**: Immutability Reduces Bugs\n\nIf MenuProvider returned mutable references:\n- Callers could accidentally modify menu data\n- Hard to track down where menu was corrupted\n- Thread safety issues in concurrent sessions\n\nBy returning immutable copies:\n- Menu data is protected from accidental mutation\n- Single source of truth guaranteed\n- Easier to reason about data flow\n\n### Why OrderStateManager is the Only State Owner?\n**Principle**: Single Source of Truth (SSOT)\n\nAll order mutations flow through one place:\n- Easy to add logging/auditing\n- Persistence logic centralized\n- Impossible to have inconsistent state\n- Debugging is straightforward: check one component\n- Testing is simple: verify state before/after\n\nContrast with diffused state (anti-pattern):\n- State scattered across DriveThruLLM, tools, agent\n- Hard to debug: \"Where did this item come from?\"\n- Hard to test: need to set up multiple components\n- Brittle: changes ripple across multiple components\n\n### Why Tools are Thin Coordination Layer?\n**Principle**: Tell, Don't Ask\n\nTools coordinate but don't implement logic:\n```python\n# Good (coordination)\ndef add_item_to_order_tool(...):\n    result = validate_order_item(...)  # Ask validation layer\n    if result.is_valid:\n        order_state.add_item(...)      # Tell state manager\n    return confirmation\n\n# Bad (implementation leaking into tool)\ndef add_item_to_order_tool(...):\n    # Fuzzy matching logic here\n    # Modifier validation logic here\n    # File I/O logic here\n    # Now tool is hard to test and has multiple responsibilities\n```\n\n### Why Function Calling?\n**Principle**: Make Invalid States Unrepresentable\n\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\nSchema enforcement means: \"If it parses, it's valid\" (or close to it).\n\n### Why Multiple Strategies?\n**Principle**: Defense in Depth\n\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.\n\n### Why Confirmation Loop?\n**Principle**: Human-in-the-Loop\n\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.\n\n### Why Incremental Logging?\n**Principle**: Observability & Debuggability\n\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.\n\nEnables data-driven improvement: analyze logs to find common error patterns.\n\n### Why Focus on Accuracy Over Speed?\n**Principle**: Correctness First, Optimization Second\n\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\nPremature optimization is the root of all evil. Get it working, get it right, then make it fast.\n\n### Why Test Pyramid (Many Unit, Few E2E)?\n**Principle**: Fast Feedback Loops (Continuous Delivery)\n\nUnit tests:\n- Run in milliseconds\n- Give instant feedback\n- Pinpoint exact failure\n- Enable rapid iteration\n\nE2E tests:\n- Run in seconds/minutes\n- Slow feedback\n- Hard to debug failures\n- Necessary but expensive\n\nBuild on solid foundation of fast unit tests, use E2E tests for critical paths only.\n\n### Why Dependency Injection?\n**Principle**: Inversion of Control (IoC)\n\nComponents receive dependencies rather than creating them:\n- Easy to substitute mocks for testing\n- Easy to swap implementations (e.g., different LLM, different storage)\n- Explicit dependencies (no hidden coupling)\n- Testable in isolation\n\n```python\n# Good (DI)\nclass DriveThruAgent:\n    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):\n        self.order_state = order_state  # Injected\n        self.menu = menu                # Injected\n\n# Bad (hidden dependencies)\nclass DriveThruAgent:\n    def __init__(self):\n        self.order_state = OrderStateManager()  # Hard-coded\n        self.menu = MenuProvider()              # Hard-coded\n        # Now can't test with mocks, can't swap implementations\n```\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","structuredPatch":[{"oldStart":699,"oldLines":17,"newStart":699,"newLines":25,"lines":[" ---"," "," #### Strategy 9: Post-Processing Validation Layer","-**Approach**: Validate every LLM output against menu before speaking to customer.","+**Approach**: Validate every LLM output against menu before mutating order state."," ","-**Implementation**:","+**Implementation**: Pure function in `menu_validation.py`"," ```python","-class OrderValidator:","-    def validate_order_item(self, item_name: str, modifiers: list[str]) -> ValidationResult:","-        # Check item exists in menu","-        # Check modifiers are valid for that item","-        # Return corrected version or error","+def validate_order_item(","+    item_name: str,","+    category: str,","+    modifiers: list[str],","+    menu_provider: MenuProvider,","+    fuzzy_threshold: int = 85","+) -> ValidationResult:","+    \"\"\"Pure function: check item exists + modifiers valid.\"\"\"","+    # Check item exists in menu","+    # Check modifiers are valid for that item","+    # Return ValidationResult with matched item or error"," ```"," ","+**Component Ownership**: `menu_validation.py` (pure functions)","+"," **Pros**:"," - Last line of defense"," - Can auto-correct minor errors"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"9cf0e016-a208-4938-ac29-92805320c426"}
{"parentUuid":"91a71124-268c-49c7-bd13-2ec690cb13c8","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01B4WxGWw3A6PPX7XUzNPttY","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Perfect! Now let me complete the todo list and provide a summary to the user.","signature":"EvUBCkYICxgCKkCD04xdk0HeJm4Egl4CvVWYr9zl7ghQcwul0aeNKX6E0AQ7d6SWU03MaUkZmzgk/My/tN3AVfLLymrU0UvBBMUHEgzj7pgPpIzmv7lboh4aDKqPmRJ8p3qRMt/xiSIwG2T6As9mAVHaRxfZ3BdxaLPM6VDz4vE9HgWSsp72cvmI5l2ujBpgeYmtBk9kUOUpKl1jHM7bwQm7WzDiNjmdAvp17j2ooOlRhHfWLVFZv9yA9TQvTK5iSA5muGArAkuXnnPWWIfIE5y3ODMcGwAbXt2vhY4zPaQMQTfqa/P8jShKallxKRCHjnLKdp12fcMYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":518,"cache_read_input_tokens":60985,"cache_creation":{"ephemeral_5m_input_tokens":518,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ4z69ytrvqHbaJoPaS","type":"assistant","uuid":"8c6b8a2c-8863-4fbf-b13d-73cd12a6a399","timestamp":"2026-01-21T23:34:09.671Z"}
{"parentUuid":"8c6b8a2c-8863-4fbf-b13d-73cd12a6a399","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01B4WxGWw3A6PPX7XUzNPttY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DpET55WgtunvwtB9XiT1mZ","name":"TodoWrite","input":{"todos":[{"content":"Review plan for separation of concerns violations","activeForm":"Reviewing plan for separation of concerns violations","status":"completed"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","activeForm":"Redefining DriveThruLLM as pure wrapper","status":"completed"},{"content":"Clarify OrderStateManager as single source of truth for state","activeForm":"Clarifying OrderStateManager responsibilities","status":"completed"},{"content":"Define MenuProvider as pure read-only service","activeForm":"Defining MenuProvider responsibilities","status":"completed"},{"content":"Separate menu_validation.py into pure functions","activeForm":"Separating menu_validation into pure functions","status":"completed"},{"content":"Update architecture diagram with clean boundaries","activeForm":"Updating architecture diagram","status":"completed"},{"content":"Add clean architecture summary section","activeForm":"Adding clean architecture summary section","status":"completed"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":518,"cache_read_input_tokens":60985,"cache_creation":{"ephemeral_5m_input_tokens":518,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ4z69ytrvqHbaJoPaS","type":"assistant","uuid":"09c044c7-1e15-4d8b-90e4-d93e16de862a","timestamp":"2026-01-21T23:34:12.683Z"}
{"parentUuid":"09c044c7-1e15-4d8b-90e4-d93e16de862a","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DpET55WgtunvwtB9XiT1mZ","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"uuid":"3e9a91fb-2001-4458-a7ef-a407adb5fda9","timestamp":"2026-01-21T23:34:12.868Z","toolUseResult":{"oldTodos":[{"content":"Review plan for separation of concerns violations","status":"completed","activeForm":"Reviewing plan for separation of concerns violations"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","status":"completed","activeForm":"Redefining DriveThruLLM as pure wrapper"},{"content":"Clarify OrderStateManager as single source of truth for state","status":"completed","activeForm":"Clarifying OrderStateManager responsibilities"},{"content":"Define MenuProvider as pure read-only service","status":"completed","activeForm":"Defining MenuProvider responsibilities"},{"content":"Separate menu_validation.py into pure functions","status":"completed","activeForm":"Separating menu_validation into pure functions"},{"content":"Update architecture diagram with clean boundaries","status":"completed","activeForm":"Updating architecture diagram"},{"content":"Add clean architecture summary section","status":"in_progress","activeForm":"Adding clean architecture summary section"}],"newTodos":[{"content":"Review plan for separation of concerns violations","status":"completed","activeForm":"Reviewing plan for separation of concerns violations"},{"content":"Redefine DriveThruLLM as pure wrapper (no state)","status":"completed","activeForm":"Redefining DriveThruLLM as pure wrapper"},{"content":"Clarify OrderStateManager as single source of truth for state","status":"completed","activeForm":"Clarifying OrderStateManager responsibilities"},{"content":"Define MenuProvider as pure read-only service","status":"completed","activeForm":"Defining MenuProvider responsibilities"},{"content":"Separate menu_validation.py into pure functions","status":"completed","activeForm":"Separating menu_validation into pure functions"},{"content":"Update architecture diagram with clean boundaries","status":"completed","activeForm":"Updating architecture diagram"},{"content":"Add clean architecture summary section","status":"completed","activeForm":"Adding clean architecture summary section"}]},"sourceToolAssistantUUID":"09c044c7-1e15-4d8b-90e4-d93e16de862a"}
{"parentUuid":"3e9a91fb-2001-4458-a7ef-a407adb5fda9","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_011WnRCAWjQZ77dym2eMraEq","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Perfect! Now let me provide a clear summary to the user of what I've done, highlighting the key changes that enforce clean architecture principles.","signature":"ErwCCkYICxgCKkAmndIvnvJWtl7O0ungESgji0OL0kaike6D8cN6km7cZ0z1k3IcGy4xH8phCccKRi3w1w7q/rQvyw7CV4Vj0g1+EgyaMlquuw3qKMt6T7saDOMV++no8EkcErq+jCIweo6/uYAFxYc4aKpi7LLzARIpEd/44v/5pzGYnf3POQFCKKYZ2Rk84t69ZbiXjMtMKqMBO6sD9YBwuSVqfEMWTH+LElEEjPKgVboSasP01Z2gcLGDgjgjBjamIZDc+y22HqZVrN3nNfrygfdPhoyj3J/zmKQcMYhLcr7cV6JL1katETuHfUggOGWptFebUAs4o/PjmLd4fGfNXb+w+ktIwz3NxUSCW817DMt7FMMEcdqdGU9OwFxK2PRG3oluse2d/odPwJN1jiwptWnuBRXuAqWSSPsVrhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":371,"cache_read_input_tokens":61503,"cache_creation":{"ephemeral_5m_input_tokens":371,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ5MPKbNcsMwKsYq9eM","type":"assistant","uuid":"aed5c701-9f02-4582-9ec4-2843c74701ee","timestamp":"2026-01-21T23:34:14.675Z"}
{"parentUuid":"aed5c701-9f02-4582-9ec4-2843c74701ee","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_011WnRCAWjQZ77dym2eMraEq","type":"message","role":"assistant","content":[{"type":"text","text":"Perfect! I've completely revised the plan with sharp boundaries and clean separation of concerns, following Kent Beck and Dave Farley principles. Here's what changed:\n\n## Key Revisions\n\n### 1. **DriveThruLLM: No Longer Manages State**\n**Before**: \"Manages conversation state and order tracking\"\n**After**: Pure, stateless wrapper that:\n- Only injects menu context into chat_ctx\n- Delegates to wrapped LLM\n- NO state management whatsoever\n\nThis follows the **Single Responsibility Principle** - LLM wrapping is separate from state management.\n\n### 2. **OrderStateManager: Single Source of Truth**\nNow the ONLY component that:\n- Owns order state\n- Mutates order state  \n- Handles persistence (incremental logs + final JSON)\n- All mutations flow through one place\n\nThis enables **easy debugging**, **testability**, and prevents inconsistent state.\n\n### 3. **MenuProvider: Pure Read-Only Service**\n- Loads menu data once\n- Returns immutable data\n- Never modifies state\n- Just a \"menu database\"\n\n**Immutability** prevents accidental corruption and makes the system thread-safe.\n\n### 4. **menu_validation.py: Pure Functions Only**\n- No classes, no state\n- Pure functions: `fuzzy_match_item()`, `validate_order_item()`\n- Fully deterministic\n- Fast to test (no I/O)\n\n**Functional core** enables rapid TDD cycles.\n\n### 5. **New Component: OrderTools**\nThin coordination layer that:\n- Defines LiveKit Tool schemas\n- Orchestrates: validate → add to state → return result\n- Receives dependencies (doesn't create them)\n\nImplements **Tell, Don't Ask** - tools tell OrderStateManager what to do.\n\n### 6. **DriveThruAgent: Orchestrator**\n- Owns OrderStateManager (composition)\n- Receives MenuProvider (dependency injection)\n- Registers tools with dependencies\n- Doesn't manage state directly\n\nAgent conducts, delegates work.\n\n## New Sections Added\n\n### **Section 0: Clean Architecture Principles**\nQuick reference checklist with:\n- Core principles (SRP, DI, Pure Functions, etc.)\n- Boundary rules table (what can access what)\n- Dependency flow diagram\n- Testing strategy pyramid\n\n### **Section 1.3: Component Contracts**\nExplicit interfaces for each component with:\n- Method signatures\n- What it does vs. doesn't do\n- Dependencies clearly stated\n\n### **Updated Architecture Diagrams**\nTwo new diagrams showing:\n1. **Data flow**: Voice → STT → LLM → Tools → State → TTS\n2. **Dependency diagram**: Who owns what, who calls what\n\n### **Revised Implementation Phases**\nNow follows **bottom-up** construction:\n1. **Phase 1**: Build components with no dependencies first (pure functions, models)\n2. **Phase 2**: Build coordination layer (tools, wrappers)\n3. **Phase 3**: Wire everything together (agent)\n\nEach phase builds on testable foundations.\n\n### **Expanded Design Decisions (Section 12)**\nAdded detailed explanations of:\n- Why separate LLM from state?\n- Why pure functions?\n- Why immutability?\n- Why single source of truth?\n- Why test pyramid?\n- Why dependency injection?\n\nEach principle includes code examples showing good vs. bad patterns.\n\n## Boundary Rules Summary\n\n| Component | Responsibility | State? | Can Access |\n|-----------|---------------|---------|------------|\n| `menu_validation.py` | Pure validation | None | Menu data (parameter only) |\n| `MenuProvider` | Read-only menu data | Immutable | Menu JSON |\n| `OrderStateManager` | Order state + persistence | Mutable (owned) | Order state, files |\n| `OrderTools` | Coordination | None | All of the above |\n| `DriveThruLLM` | Context injection | None | MenuProvider only |\n| `DriveThruAgent` | Orchestration | None (delegates) | Everything |\n\nThe plan now follows **clean architecture** with:\n- ✅ Single Responsibility Principle  \n- ✅ Dependency Inversion\n- ✅ Pure functions where possible\n- ✅ Immutability reduces bugs\n- ✅ Single source of truth for state\n- ✅ Tell, Don't Ask\n- ✅ Fast test pyramid\n\nEach component has **one reason to change**, making the system maintainable, testable, and ready for continuous delivery."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":371,"cache_read_input_tokens":61503,"cache_creation":{"ephemeral_5m_input_tokens":371,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMQ5MPKbNcsMwKsYq9eM","type":"assistant","uuid":"1a599fb0-8b9c-40c4-9834-cde40b9d33d0","timestamp":"2026-01-21T23:34:30.584Z"}
{"parentUuid":"1a599fb0-8b9c-40c4-9834-cde40b9d33d0","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"4cf43f87-139d-4340-ba8c-8f9b2dee1c9b","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"purrfect-fluttering-penguin","type":"system","subtype":"turn_duration","durationMs":233404,"timestamp":"2026-01-21T23:34:30.730Z","uuid":"3efca612-2696-4ccb-83fe-72a072e438f3","isMeta":false}
{"type":"summary","summary":"Item class enhancements & architecture refactoring","leafUuid":"1a599fb0-8b9c-40c4-9834-cde40b9d33d0"}
