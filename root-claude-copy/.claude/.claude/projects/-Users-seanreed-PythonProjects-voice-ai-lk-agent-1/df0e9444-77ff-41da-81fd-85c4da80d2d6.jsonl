{"type":"file-history-snapshot","messageId":"cf179495-7cb4-4b68-bc52-f4ac24cfa26c","snapshot":{"messageId":"cf179495-7cb4-4b68-bc52-f4ac24cfa26c","trackedFileBackups":{},"timestamp":"2026-01-22T00:39:02.829Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"},"isMeta":true,"uuid":"7974dd8c-709e-4b02-a337-a85982f51a1c","timestamp":"2026-01-22T00:39:02.825Z"}
{"parentUuid":"7974dd8c-709e-4b02-a337-a85982f51a1c","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"cf179495-7cb4-4b68-bc52-f4ac24cfa26c","timestamp":"2026-01-22T00:39:02.807Z"}
{"parentUuid":"cf179495-7cb4-4b68-bc52-f4ac24cfa26c","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"76dbd7bd-2b69-4ab4-9f18-1702ffbe772d","timestamp":"2026-01-22T00:39:02.825Z"}
{"type":"file-history-snapshot","messageId":"6608d435-8dca-423b-b359-dca984633196","snapshot":{"messageId":"6608d435-8dca-423b-b359-dca984633196","trackedFileBackups":{},"timestamp":"2026-01-22T00:42:40.694Z"},"isSnapshotUpdate":false}
{"parentUuid":"76dbd7bd-2b69-4ab4-9f18-1702ffbe772d","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":"'/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/thoughts' given these thoughts, create a plan and then write a markdown on what a minimal list of bdd scenarios and features files might look like so we can test the behavior of the system and not its implementation. create only the markdown. "},"uuid":"6608d435-8dca-423b-b359-dca984633196","timestamp":"2026-01-22T00:42:40.687Z","thinkingMetadata":{"level":"high","disabled":false,"triggers":[]}}
{"parentUuid":"6608d435-8dca-423b-b359-dca984633196","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Ctqb5BKtMbrf6EatpiFXNd","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user is asking me to:\n1. Look at the thoughts directory at `/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/thoughts`\n2. Create a plan based on those thoughts\n3. Write a markdown document describing what a minimal list of BDD scenarios and feature files might look like for testing system behavior (not implementation)\n4. Create only the markdown - not the actual feature files\n\nLet me first explore the thoughts directory to understand what's there.","signature":"EvUECkYICxgCKkBP0gaIfh3krgGGEsNrM3dvSugonNMKBTnvWJg9OOoPk+sgAmb7Rw83C7qG70BtHMpoK5u8nsHKfrOIe43dZrkUEgzPnjZ2lv+1g0uAFdEaDCE5NSe4KBvwNU0QqiIwH4uL56R+2zlwM9qcWZYWfv1nAY6pfhLFPpGX7qtPWTV+PI0ipKN6wf+ZNdYK+YM5KtwDSY5dQuL0393XfRMnHVJRmJClya9B9gu09VC1zoyTFq8PyuQaj65iD5gR6kUeJ6mfqghei9Nm6Fvl/IlggzXzqsMC8EDn/5lPov4hcM24pwVze4yK+GxuQDKGLXpJDoPBU3Zl3TpFr8gLnvf2iKPxgakR1tnJaqGg3YBUw7orCChl2GsUJjss+IQvoE1mqh9fssZZfv+pBAwnvPd/rKJdGd2LtbBaT7m7BjS4f5XYRRmUXq3iUalhq/NugifKXZ6XpxqpfJuE8Ns0omMSN958ZJ2cLBvW4sApAZxTeyMwspkDiJohU8XE1LzUFMmsna6roejBU68uhQhlsv0nSVuTeqiSeSqzz7Zn0TEzqESbBE+vgI8hPs5hsTOT2MsnUBJ2IMpD4wvoKQgbxykHv0cAuNPCH55PuEWNNWZoMA2vz2qPQUIY852AzyQTCxTW9okeT97VcS0avkisMzQlhtQjcZaZcZvqww65n04c4PQm13MGvR4WDMjNuNPBJ1isnrMGUHcicGqoz7W0xwYA34j0ZHkWNiz/Ios8lck3fmLjGNjEViZTA1o7RBH42wSv6guxe5MA/z25CQ7XrUxB9zi8PB0xXWfJBzXVmRXVIu2iKvF9FYkwKohRnSYup1sYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25772,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25772,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMVJ9Tv1YvumymSCM12T","type":"assistant","uuid":"d9ef82bd-1bc8-41bb-a3a8-c966cb42cf48","timestamp":"2026-01-22T00:42:43.418Z"}
{"parentUuid":"d9ef82bd-1bc8-41bb-a3a8-c966cb42cf48","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Ctqb5BKtMbrf6EatpiFXNd","type":"message","role":"assistant","content":[{"type":"text","text":"I'll explore the thoughts directory to understand the context, then create a markdown document outlining minimal BDD scenarios and feature files for testing the system's behavior."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25772,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25772,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMVJ9Tv1YvumymSCM12T","type":"assistant","uuid":"4ee54afa-795b-49f2-9368-0a01f49739a8","timestamp":"2026-01-22T00:42:43.951Z"}
{"parentUuid":"4ee54afa-795b-49f2-9368-0a01f49739a8","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Ctqb5BKtMbrf6EatpiFXNd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VeZGDEgYKmZ6oRNT2L5TsA","name":"Bash","input":{"command":"find /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/thoughts -type f -name \"*.md\" | head -20","description":"Find markdown files in thoughts directory"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":10,"cache_creation_input_tokens":25772,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":25772,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMVJ9Tv1YvumymSCM12T","type":"assistant","uuid":"2a76cbd2-524d-40e0-8535-5d3b823c78a9","timestamp":"2026-01-22T00:42:44.546Z"}
{"parentUuid":"2a76cbd2-524d-40e0-8535-5d3b823c78a9","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VeZGDEgYKmZ6oRNT2L5TsA","type":"tool_result","content":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/thoughts/mcdonalds-drive-thru-agent-plan.md","is_error":false}]},"uuid":"8da4a38d-7289-4ea9-8252-4db0cb595513","timestamp":"2026-01-22T00:42:44.631Z","toolUseResult":{"stdout":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/thoughts/mcdonalds-drive-thru-agent-plan.md","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"2a76cbd2-524d-40e0-8535-5d3b823c78a9"}
{"parentUuid":"8da4a38d-7289-4ea9-8252-4db0cb595513","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019v1st2DfchmqTTXQKQuaxY","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, there's one markdown file. Let me read it to understand the context.","signature":"EvIBCkYICxgCKkBSKmej9mwf6R9C4VTO09+1b3huMmqZYq0S8O/U+dHQgEav0Hieg4KKVh3e13dEdeXp2Bd+ek6I64KEPAAKrGRwEgy/0hZ+wmUXm3LgUxwaDBPtmvml3oJ6xt7jBCIwqXOWtLJs8xFp87Uz0R/v7Estf5Ima0ZBw/W+/59l0ktpnqOhyLVQwBAeIYHtjpA6Klqvg7th5/WjjRXtQZZMT/S2qIomuuMHCeUHGDMgQcNdFRt/dGNcKxXzLgGS9rONRN3ayeVWddSoN/+lyS3xEhAfJFg6vXpRssfdvofc82zZ+CNC7btiV8u3ENEYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":325,"cache_read_input_tokens":25772,"cache_creation":{"ephemeral_5m_input_tokens":325,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMVJS7mz6RKGBJKeenpx","type":"assistant","uuid":"9cb176ad-c090-4a11-8fed-0c0e9ded7ba4","timestamp":"2026-01-22T00:42:46.057Z"}
{"parentUuid":"9cb176ad-c090-4a11-8fed-0c0e9ded7ba4","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019v1st2DfchmqTTXQKQuaxY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q5zpa9uFJWbEVuB9A69Soa","name":"Read","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/thoughts/mcdonalds-drive-thru-agent-plan.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":325,"cache_read_input_tokens":25772,"cache_creation":{"ephemeral_5m_input_tokens":325,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CXMVJS7mz6RKGBJKeenpx","type":"assistant","uuid":"837e7495-0027-4319-8976-fc3885bda6d2","timestamp":"2026-01-22T00:42:46.481Z"}
{"parentUuid":"837e7495-0027-4319-8976-fc3885bda6d2","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q5zpa9uFJWbEVuB9A69Soa","type":"tool_result","content":"     1→# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n     2→\n     3→**Created**: 2026-01-21\n     4→**Status**: Planning Phase\n     5→**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n     6→\n     7→---\n     8→\n     9→## Executive Summary\n    10→\n    11→This plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n    12→\n    13→---\n    14→\n    15→## 0. Clean Architecture Principles (Kent Beck + Dave Farley)\n    16→\n    17→This implementation follows clean architecture principles for maintainability, testability, and continuous delivery.\n    18→\n    19→### Core Principles Checklist\n    20→\n    21→**✓ Single Responsibility Principle (SRP)**\n    22→- Each component has one reason to change\n    23→- DriveThruLLM: Context injection only (no state)\n    24→- OrderStateManager: State + persistence only\n    25→- MenuProvider: Read-only data access only\n    26→- menu_validation.py: Pure validation functions only\n    27→\n    28→**✓ Dependency Inversion**\n    29→- Components receive dependencies via constructor (DI)\n    30→- High-level components don't depend on low-level details\n    31→- Easy to mock, easy to test, easy to swap\n    32→\n    33→**✓ Pure Functions Where Possible**\n    34→- menu_validation.py: 100% pure functions\n    35→- No I/O, no side effects, fully deterministic\n    36→- Fast, testable, reusable\n    37→\n    38→**✓ Immutability Reduces Bugs**\n    39→- MenuProvider returns immutable data\n    40→- Menu cannot be accidentally corrupted\n    41→- Thread-safe by design\n    42→\n    43→**✓ Single Source of Truth**\n    44→- OrderStateManager is ONLY owner of order state\n    45→- All mutations flow through one place\n    46→- Easy to debug, easy to audit, easy to test\n    47→\n    48→**✓ Tell, Don't Ask**\n    49→- Tools tell OrderStateManager what to do\n    50→- Don't query state, mutate it, then write back\n    51→- Reduces coupling, increases cohesion\n    52→\n    53→**✓ Test Pyramid**\n    54→- Many fast unit tests (milliseconds)\n    55→- Some integration tests (seconds)\n    56→- Few E2E tests (minutes)\n    57→- Fast feedback loops enable TDD\n    58→\n    59→**✓ Make Invalid States Unrepresentable**\n    60→- Use type system + schemas to prevent errors\n    61→- Function calling enforces structure\n    62→- Validation happens before state mutation\n    63→\n    64→### Boundary Rules\n    65→\n    66→| Component | Can Access | Cannot Access |\n    67→|-----------|-----------|---------------|\n    68→| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |\n    69→| `MenuProvider` | Menu JSON file | Order state, LLM |\n    70→| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |\n    71→| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |\n    72→| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |\n    73→| `DriveThruAgent` | Everything (orchestrator) | N/A |\n    74→\n    75→**Dependency Flow** (always downward, never circular):\n    76→```\n    77→DriveThruAgent\n    78→    ├─> OrderStateManager\n    79→    ├─> MenuProvider\n    80→    ├─> OrderTools\n    81→    │       ├─> menu_validation.py\n    82→    │       ├─> OrderStateManager\n    83→    │       └─> MenuProvider\n    84→    └─> DriveThruLLM\n    85→            └─> MenuProvider\n    86→```\n    87→\n    88→### Testing Strategy\n    89→\n    90→**Unit Tests** (Fast, isolated, many)\n    91→- `test_menu_validation.py`: Pure functions, no mocks needed\n    92→- `test_menu_provider.py`: Test with fixture JSON\n    93→- `test_order_state.py`: In-memory state, temp file I/O\n    94→- `test_drive_thru_llm.py`: Mock wrapped LLM\n    95→\n    96→**Integration Tests** (Medium speed, some mocks)\n    97→- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager\n    98→\n    99→**E2E Tests** (Slow, real components, few)\n   100→- `test_drive_thru_agent.py`: Full agent with judge-based evaluation\n   101→- `test_accuracy.py`: Accuracy benchmarks\n   102→\n   103→**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.\n   104→\n   105→---\n   106→\n   107→## 1. System Architecture\n   108→\n   109→### 1.1 Core Components & Data Flow\n   110→\n   111→```\n   112→Customer Voice Input\n   113→    ↓\n   114→[STT] → AssemblyAI Universal Streaming\n   115→    ↓\n   116→[AgentSession with DriveThruLLM wrapper]\n   117→    │\n   118→    ├─> DriveThruLLM.chat()\n   119→    │   ├─ Queries MenuProvider for context\n   120→    │   ├─ Injects menu context into chat_ctx\n   121→    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n   122→    │\n   123→    ├─> Base LLM outputs function call → add_item_to_order(...)\n   124→    │\n   125→    ├─> OrderTools.add_item_to_order()\n   126→    │   ├─ Calls menu_validation.validate_item() [pure function]\n   127→    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n   128→    │   │   └─ OrderStateManager appends to incremental log\n   129→    │   └─ Returns result to LLM\n   130→    │\n   131→    └─> LLM generates response text\n   132→    ↓\n   133→[TTS] → Inworld/Cartesia\n   134→    ↓\n   135→Agent Voice Response\n   136→\n   137→\n   138→┌─────────────────────────────────────────────────────┐\n   139→│ Dependency Diagram (Composition, not inheritance)  │\n   140→└─────────────────────────────────────────────────────┘\n   141→\n   142→VoiceAgentApp\n   143→    │\n   144→    ├─> Creates: DriveThruAgent (owns conversation)\n   145→    │        │\n   146→    │        ├─> Owns: OrderStateManager (mutable state)\n   147→    │        │\n   148→    │        ├─> Receives: MenuProvider (read-only data)\n   149→    │        │\n   150→    │        └─> Registers: OrderTools (coordination layer)\n   151→    │                  │\n   152→    │                  ├─> Uses: menu_validation.py (pure functions)\n   153→    │                  │\n   154→    │                  ├─> Calls: OrderStateManager (state mutations)\n   155→    │                  │\n   156→    │                  └─> Queries: MenuProvider (data access)\n   157→    │\n   158→    ├─> Creates: DriveThruLLM (wraps base LLM)\n   159→    │        │\n   160→    │        └─> Queries: MenuProvider (for context injection)\n   161→    │\n   162→    └─> Loads: MenuProvider (singleton, immutable)\n   163→\n   164→\n   165→Key Principles:\n   166→- MenuProvider: Read-only, queried by many\n   167→- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n   168→- menu_validation.py: Pure functions, no dependencies\n   169→- DriveThruLLM: Stateless wrapper, delegates to base LLM\n   170→- OrderTools: Thin coordination layer, receives dependencies\n   171→```\n   172→\n   173→### 1.2 New Components to Build\n   174→\n   175→Each component has a single, well-defined responsibility following the Single Responsibility Principle.\n   176→\n   177→#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n   178→**Responsibility**: Pure LLM wrapper - context injection only\n   179→**Does**:\n   180→- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n   181→- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n   182→- Delegates to wrapped LLM\n   183→- Returns LLM stream\n   184→\n   185→**Does NOT**:\n   186→- Manage order state (that's `OrderStateManager`)\n   187→- Store any state (stateless wrapper)\n   188→- Validate menu items (that's `menu_validation.py`)\n   189→- Perform searches (that's `MenuProvider`)\n   190→\n   191→**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n   192→\n   193→---\n   194→\n   195→#### 2. **MenuProvider** (`src/menu_provider.py`)\n   196→**Responsibility**: Read-only menu data access\n   197→**Does**:\n   198→- Loads menu data from JSON using existing Pydantic models\n   199→- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n   200→- Returns menu data structures (immutable)\n   201→\n   202→**Does NOT**:\n   203→- Modify menu data (read-only)\n   204→- Validate orders (that's `menu_validation.py`)\n   205→- Manage order state (that's `OrderStateManager`)\n   206→- Fuzzy match (that's `menu_validation.py`)\n   207→\n   208→**Why**: Single source of truth for menu data, but purely a data provider\n   209→\n   210→---\n   211→\n   212→#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n   213→**Responsibility**: Single source of truth for order state and persistence\n   214→**Does**:\n   215→- Owns ALL order state (items, quantities, session info)\n   216→- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n   217→- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n   218→- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n   219→- Manages session lifecycle\n   220→\n   221→**Does NOT**:\n   222→- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n   223→- Search menu (that's `MenuProvider`)\n   224→- Make decisions (it's told what to do)\n   225→\n   226→**Why**: All state changes go through one place - testable, debuggable, single source of truth\n   227→\n   228→---\n   229→\n   230→#### 4. **menu_validation.py** (`src/menu_validation.py`)\n   231→**Responsibility**: Pure validation and matching functions\n   232→**Does**:\n   233→- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n   234→- Fuzzy string matching using `rapidfuzz`\n   235→- Returns validation results (success/failure with details)\n   236→\n   237→**Does NOT**:\n   238→- Store state (pure functions only)\n   239→- Load menu data (receives menu data as parameter)\n   240→- Modify orders (just validates, doesn't change state)\n   241→\n   242→**Why**: Pure functions are maximally testable and reusable\n   243→\n   244→---\n   245→\n   246→#### 5. **OrderTools** (`src/tools/order_tools.py`)\n   247→**Responsibility**: LiveKit Tool definitions for LLM function calling\n   248→**Does**:\n   249→- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n   250→- Defines `complete_order` tool\n   251→- Thin wrappers that orchestrate: validate → add to order state → return result\n   252→- Receives `OrderStateManager` and `MenuProvider` as dependencies\n   253→\n   254→**Does NOT**:\n   255→- Own state (receives OrderStateManager)\n   256→- Implement validation logic (calls menu_validation.py)\n   257→\n   258→**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n   259→\n   260→---\n   261→\n   262→#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n   263→**Responsibility**: Agent orchestration and configuration\n   264→**Does**:\n   265→- Defines agent instructions/persona (system prompt)\n   266→- Owns `OrderStateManager` instance (via composition)\n   267→- Registers tools with agent (passing OrderStateManager as dependency)\n   268→- Coordinates conversation flow\n   269→\n   270→**Does NOT**:\n   271→- Manage state directly (delegates to OrderStateManager)\n   272→- Validate items (delegates to validation layer via tools)\n   273→- Load menu (receives MenuProvider as dependency)\n   274→\n   275→**Why**: Agent is the conductor - it orchestrates but delegates actual work\n   276→\n   277→---\n   278→\n   279→## 1.3 Component Contracts (Interfaces)\n   280→\n   281→Following the Interface Segregation Principle, here are the explicit contracts for each component.\n   282→\n   283→### MenuProvider Interface\n   284→```python\n   285→class MenuProvider:\n   286→    \"\"\"Read-only menu data provider.\"\"\"\n   287→\n   288→    def __init__(self, menu_file_path: str) -> None:\n   289→        \"\"\"Load menu from JSON file.\"\"\"\n   290→\n   291→    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n   292→        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n   293→\n   294→    def get_category(self, category_name: str) -> list[Item]:\n   295→        \"\"\"Get all items in a category.\"\"\"\n   296→\n   297→    def get_item(self, category_name: str, item_name: str) -> Item | None:\n   298→        \"\"\"Get a specific item by category and name.\"\"\"\n   299→\n   300→    def get_all_categories(self) -> list[str]:\n   301→        \"\"\"Get list of all category names.\"\"\"\n   302→\n   303→    def get_menu(self) -> Menu:\n   304→        \"\"\"Get the complete menu (immutable).\"\"\"\n   305→```\n   306→\n   307→### OrderStateManager Interface\n   308→```python\n   309→@dataclass\n   310→class OrderItem:\n   311→    \"\"\"A single item in an order.\"\"\"\n   312→    item_name: str\n   313→    category: str\n   314→    modifiers: list[str]\n   315→    quantity: int\n   316→    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n   317→    timestamp: datetime = field(default_factory=datetime.now)\n   318→\n   319→\n   320→class OrderStateManager:\n   321→    \"\"\"Single source of truth for order state and persistence.\"\"\"\n   322→\n   323→    def __init__(self, session_id: str, output_dir: str) -> None:\n   324→        \"\"\"Initialize order state for a session.\"\"\"\n   325→\n   326→    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n   327→        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n   328→\n   329→    def remove_item(self, item_id: str) -> bool:\n   330→        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n   331→\n   332→    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n   333→        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n   334→\n   335→    def get_items(self) -> list[OrderItem]:\n   336→        \"\"\"Get all items in current order (read-only copy).\"\"\"\n   337→\n   338→    def get_total_count(self) -> int:\n   339→        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n   340→\n   341→    def get_order_summary(self) -> str:\n   342→        \"\"\"Get human-readable order summary.\"\"\"\n   343→\n   344→    def complete_order(self) -> dict:\n   345→        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n   346→\n   347→    def clear_order(self) -> None:\n   348→        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n   349→```\n   350→\n   351→### menu_validation Module (Pure Functions)\n   352→```python\n   353→@dataclass\n   354→class ValidationResult:\n   355→    \"\"\"Result of a validation operation.\"\"\"\n   356→    is_valid: bool\n   357→    matched_item: Item | None = None\n   358→    confidence_score: float = 0.0\n   359→    error_message: str | None = None\n   360→\n   361→\n   362→def fuzzy_match_item(\n   363→    item_name: str,\n   364→    menu_items: list[Item],\n   365→    threshold: int = 85\n   366→) -> ValidationResult:\n   367→    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n   368→\n   369→\n   370→def validate_item_exists(\n   371→    item_name: str,\n   372→    category: str,\n   373→    menu_provider: MenuProvider\n   374→) -> ValidationResult:\n   375→    \"\"\"Validate that an item exists in the specified category.\"\"\"\n   376→\n   377→\n   378→def validate_modifiers(\n   379→    item: Item,\n   380→    requested_modifiers: list[str],\n   381→    fuzzy_threshold: int = 85\n   382→) -> ValidationResult:\n   383→    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n   384→\n   385→\n   386→def validate_order_item(\n   387→    item_name: str,\n   388→    category: str,\n   389→    modifiers: list[str],\n   390→    menu_provider: MenuProvider,\n   391→    fuzzy_threshold: int = 85\n   392→) -> ValidationResult:\n   393→    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n   394→```\n   395→\n   396→### OrderTools (LiveKit Tool Definitions)\n   397→```python\n   398→def create_order_tools(\n   399→    order_state: OrderStateManager,\n   400→    menu_provider: MenuProvider,\n   401→    config: DriveThruConfig\n   402→) -> list[Tool]:\n   403→    \"\"\"Create LiveKit Tool instances with dependencies injected.\n   404→\n   405→    Returns:\n   406→        List of Tool objects that can be registered with an Agent\n   407→    \"\"\"\n   408→\n   409→    # Tool 1: add_item_to_order\n   410→    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n   411→    # Behavior: validate → add to state → return confirmation\n   412→\n   413→    # Tool 2: complete_order\n   414→    # Schema: {}\n   415→    # Behavior: complete order → return summary\n   416→```\n   417→\n   418→### DriveThruLLM Interface\n   419→```python\n   420→class DriveThruLLM(LLM):\n   421→    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n   422→\n   423→    def __init__(\n   424→        self,\n   425→        wrapped_llm: LLM,\n   426→        menu_provider: MenuProvider,\n   427→        config: DriveThruConfig\n   428→    ) -> None:\n   429→        \"\"\"Initialize wrapper with dependencies.\"\"\"\n   430→\n   431→    def chat(\n   432→        self,\n   433→        *,\n   434→        chat_ctx: ChatContext,\n   435→        tools: list[Tool] | None = None,\n   436→        **kwargs\n   437→    ) -> LLMStream:\n   438→        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n   439→        # 1. Extract keywords from latest user message\n   440→        # 2. Query MenuProvider for relevant items\n   441→        # 3. Inject into chat_ctx as system message or augment existing prompt\n   442→        # 4. Delegate to wrapped_llm.chat()\n   443→```\n   444→\n   445→### DriveThruAgent\n   446→```python\n   447→class DriveThruAgent(Agent):\n   448→    \"\"\"Drive-thru order taking agent.\"\"\"\n   449→\n   450→    def __init__(\n   451→        self,\n   452→        order_state: OrderStateManager,\n   453→        menu_provider: MenuProvider,\n   454→        config: DriveThruConfig\n   455→    ) -> None:\n   456→        \"\"\"Initialize agent with dependencies.\n   457→\n   458→        - Sets instructions/persona\n   459→        - Registers order tools\n   460→        - Owns OrderStateManager\n   461→        \"\"\"\n   462→```\n   463→\n   464→**Design Principles Applied**:\n   465→1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n   466→2. **Interface Segregation**: Each interface is minimal and focused\n   467→3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n   468→4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n   469→5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n   470→6. **Single Source of Truth**: All order state lives in OrderStateManager\n   471→\n   472→---\n   473→\n   474→## 2. Accuracy-Boosting Strategies\n   475→\n   476→### Priority 1: Core Strategies (Implement First)\n   477→\n   478→#### Strategy 1: LLM Function Calling / Structured Output\n   479→**Approach**: Define tools/functions that the LLM can call to add items to the order.\n   480→\n   481→**Implementation**:\n   482→- Create `add_item_to_order` function with parameters:\n   483→  - `category` (enum from menu categories)\n   484→  - `item_name` (string)\n   485→  - `modifiers` (list of strings)\n   486→  - `quantity` (int, default 1)\n   487→- LLM must use this function instead of free-form text\n   488→- Validates parameters against menu before accepting\n   489→\n   490→**Pros**:\n   491→- Structured, parseable output\n   492→- Forces LLM to think in terms of menu structure\n   493→- Easy to validate\n   494→\n   495→**Cons**:\n   496→- Requires LLM with good function calling support\n   497→- May feel less natural for complex orders\n   498→\n   499→**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n   500→\n   501→---\n   502→\n   503→#### Strategy 2: Menu Context Injection\n   504→**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n   505→\n   506→**Implementation**:\n   507→- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n   508→- Fetch relevant menu items from Menu model\n   509→- Include in system prompt: \"Available items: [filtered list]\"\n   510→- Reduces hallucination by showing exact menu item names\n   511→\n   512→**Example**:\n   513→```\n   514→Customer: \"I'd like a Big Mac\"\n   515→→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n   516→```\n   517→\n   518→**Pros**:\n   519→- Reduces hallucination\n   520→- Helps with exact item name matching\n   521→- Context-aware\n   522→\n   523→**Cons**:\n   524→- Increases token usage\n   525→- May miss items if keyword matching fails\n   526→\n   527→**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n   528→\n   529→---\n   530→\n   531→#### Strategy 3: Explicit Confirmation Loop\n   532→**Approach**: After each item is understood, explicitly confirm with customer.\n   533→\n   534→**Implementation**:\n   535→- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n   536→- Customer can correct if wrong\n   537→- Only write to order file after confirmation\n   538→\n   539→**Example Flow**:\n   540→```\n   541→Customer: \"Big Mac please\"\n   542→Agent: \"One Big Mac - is that correct?\"\n   543→Customer: \"Yes\"\n   544→Agent: \"Great! Anything else?\"\n   545→[Write to order file]\n   546→```\n   547→\n   548→**Pros**:\n   549→- Allows error correction\n   550→- Builds customer confidence\n   551→- Simple to implement\n   552→\n   553→**Cons**:\n   554→- Slower ordering process\n   555→- May annoy customers with simple orders\n   556→\n   557→**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n   558→\n   559→---\n   560→\n   561→#### Strategy 4: Fuzzy String Matching\n   562→**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n   563→\n   564→**Implementation**:\n   565→- Use `rapidfuzz` or `fuzzywuzzy` library\n   566→- When LLM outputs an item name, fuzzy match against menu\n   567→- Accept if confidence > 85%\n   568→- Handle common variations:\n   569→  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n   570→  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n   571→\n   572→**Example**:\n   573→```python\n   574→from rapidfuzz import process, fuzz\n   575→\n   576→def find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n   577→    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n   578→    return result[0], result[1]  # item, confidence_score\n   579→```\n   580→\n   581→**Pros**:\n   582→- Handles STT errors\n   583→- Tolerates variations\n   584→- Fast and deterministic\n   585→\n   586→**Cons**:\n   587→- Can match wrong items if names are similar\n   588→- Requires confidence threshold tuning\n   589→\n   590→**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n   591→\n   592→---\n   593→\n   594→### Priority 2: Advanced Strategies (Implement Later for Optimization)\n   595→\n   596→#### Strategy 5: Semantic Search with Embeddings\n   597→**Approach**: Use embeddings to find semantically similar menu items.\n   598→\n   599→**Implementation**:\n   600→- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n   601→- Store in vector DB or in-memory\n   602→- When customer speaks, embed their utterance\n   603→- Find nearest neighbors in embedding space\n   604→- Use as candidates for LLM to choose from\n   605→\n   606→**Pros**:\n   607→- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n   608→- Semantic understanding\n   609→- Robust to paraphrasing\n   610→\n   611→**Cons**:\n   612→- More complex implementation\n   613→- Requires embedding API calls\n   614→- May introduce latency\n   615→\n   616→**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n   617→\n   618→---\n   619→\n   620→#### Strategy 6: Two-Stage Parsing\n   621→**Approach**: Separate intent extraction from menu item selection.\n   622→\n   623→**Implementation**:\n   624→1. **Stage 1**: Extract customer intent\n   625→   - \"I want a burger with cheese\"\n   626→   - Intent: {type: burger, modifiers: [cheese]}\n   627→2. **Stage 2**: Match intent to menu items\n   628→   - Search menu for burgers with cheese modifier\n   629→   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n   630→3. **Stage 3**: LLM selects best match or asks clarifying question\n   631→\n   632→**Pros**:\n   633→- Cleaner separation of concerns\n   634→- Can optimize each stage separately\n   635→- Better debuggability\n   636→\n   637→**Cons**:\n   638→- More complex\n   639→- Additional latency from multiple stages\n   640→\n   641→**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n   642→\n   643→---\n   644→\n   645→#### Strategy 7: Chain-of-Thought Prompting\n   646→**Approach**: Ask LLM to explain its reasoning before outputting.\n   647→\n   648→**Implementation**:\n   649→```\n   650→System: When a customer orders, think step-by-step:\n   651→1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n   652→2. Which specific item from our menu matches best?\n   653→3. Did they mention any modifiers?\n   654→4. What quantity?\n   655→Then output the structured order.\n   656→```\n   657→\n   658→**Pros**:\n   659→- Improves LLM reasoning\n   660→- More interpretable\n   661→- Can catch logic errors\n   662→\n   663→**Cons**:\n   664→- Increases token usage\n   665→- May add latency\n   666→- Reasoning not always visible to customer\n   667→\n   668→**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n   669→\n   670→---\n   671→\n   672→#### Strategy 8: Constrained Decoding\n   673→**Approach**: Use grammar-based constrained generation (if LLM supports it).\n   674→\n   675→**Implementation**:\n   676→- Define grammar for valid responses\n   677→- LLM can only output strings that match the grammar\n   678→- Grammar includes exact menu item names\n   679→\n   680→**Example Grammar**:\n   681→```\n   682→ORDER := <ITEM> | <ITEM> \"and\" <ORDER>\n   683→ITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\n   684→MENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n   685→```\n   686→\n   687→**Pros**:\n   688→- Guarantees valid output\n   689→- No hallucination possible\n   690→- Perfect accuracy for item names\n   691→\n   692→**Cons**:\n   693→- Very few LLMs support this\n   694→- Complex to implement\n   695→- May be too rigid\n   696→\n   697→**Accuracy Impact**: VERY HIGH (9/10) - If available\n   698→\n   699→---\n   700→\n   701→#### Strategy 9: Post-Processing Validation Layer\n   702→**Approach**: Validate every LLM output against menu before mutating order state.\n   703→\n   704→**Implementation**: Pure function in `menu_validation.py`\n   705→```python\n   706→def validate_order_item(\n   707→    item_name: str,\n   708→    category: str,\n   709→    modifiers: list[str],\n   710→    menu_provider: MenuProvider,\n   711→    fuzzy_threshold: int = 85\n   712→) -> ValidationResult:\n   713→    \"\"\"Pure function: check item exists + modifiers valid.\"\"\"\n   714→    # Check item exists in menu\n   715→    # Check modifiers are valid for that item\n   716→    # Return ValidationResult with matched item or error\n   717→```\n   718→\n   719→**Component Ownership**: `menu_validation.py` (pure functions)\n   720→\n   721→**Pros**:\n   722→- Last line of defense\n   723→- Can auto-correct minor errors\n   724→- Prevents invalid orders\n   725→\n   726→**Cons**:\n   727→- Reactive, not proactive\n   728→- May reject valid variations\n   729→\n   730→**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n   731→\n   732→---\n   733→\n   734→#### Strategy 10: Context Window Optimization\n   735→**Approach**: Only include relevant portions of menu in context.\n   736→\n   737→**Implementation**:\n   738→- Detect if customer is ordering breakfast, lunch, drinks, etc.\n   739→- Only inject that category's items into prompt\n   740→- Reduces noise and token count\n   741→- Improves focus\n   742→\n   743→**Example**:\n   744→```\n   745→Customer: \"I want breakfast\"\n   746→→ Only include Breakfast category items in context\n   747→```\n   748→\n   749→**Pros**:\n   750→- Reduces token usage\n   751→- Reduces hallucination\n   752→- Faster inference\n   753→\n   754→**Cons**:\n   755→- May miss cross-category orders\n   756→- Requires intent detection\n   757→\n   758→**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n   759→\n   760→---\n   761→\n   762→### Recommended Strategy Combination & Component Ownership\n   763→\n   764→Each strategy is owned by a specific component, following SRP.\n   765→\n   766→**Phase 1 (MVP)**:\n   767→1. **Function Calling** (Strategy 1)\n   768→   - Owner: `OrderTools` (defines tool schemas)\n   769→   - Core structure for order taking\n   770→\n   771→2. **Menu Context Injection** (Strategy 2)\n   772→   - Owner: `DriveThruLLM` (injects context in chat())\n   773→   - Grounding LLM in actual menu\n   774→\n   775→3. **Fuzzy String Matching** (Strategy 4)\n   776→   - Owner: `menu_validation.py` (pure function)\n   777→   - STT error handling\n   778→\n   779→4. **Post-Processing Validation** (Strategy 9)\n   780→   - Owner: `OrderTools` (validates before state mutation)\n   781→   - Safety net - validate before add_item()\n   782→\n   783→**Phase 2 (Optimization)**:\n   784→5. **Explicit Confirmation Loop** (Strategy 3)\n   785→   - Owner: `DriveThruAgent` (instructions/conversation flow)\n   786→   - User validation\n   787→\n   788→6. **Semantic Search** (Strategy 5)\n   789→   - Owner: `MenuProvider` (add embedding-based search method)\n   790→   - Better matching via semantics\n   791→\n   792→**Phase 3 (Advanced)**:\n   793→7. **Two-Stage Parsing** (Strategy 6)\n   794→   - Owner: `OrderTools` (modify tool implementation)\n   795→   - If needed for complex orders\n   796→\n   797→8. **Chain-of-Thought** (Strategy 7)\n   798→   - Owner: `DriveThruAgent` (modify instructions)\n   799→   - If needed for better reasoning\n   800→\n   801→**Key Insight**: Each strategy lives in exactly one component. This:\n   802→- Makes it easy to A/B test strategies (change one component)\n   803→- Enables independent testing of strategies\n   804→- Prevents strategy logic from leaking across boundaries\n   805→\n   806→---\n   807→\n   808→## 3. Order State Management\n   809→\n   810→### 3.1 Order State Model\n   811→\n   812→```python\n   813→@dataclass\n   814→class OrderItem:\n   815→    item_name: str\n   816→    category: str\n   817→    modifiers: list[str]\n   818→    quantity: int\n   819→    timestamp: datetime\n   820→    confirmed: bool = False\n   821→\n   822→@dataclass\n   823→class OrderSession:\n   824→    session_id: str\n   825→    start_time: datetime\n   826→    items: list[OrderItem]\n   827→    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n   828→```\n   829→\n   830→### 3.2 Incremental Logging\n   831→\n   832→After each customer turn where an item is added:\n   833→- Append to `orders/{session_id}/incremental_log.jsonl`\n   834→- Each line is a JSON object with:\n   835→  - `timestamp`\n   836→  - `customer_utterance`\n   837→  - `item_parsed`\n   838→  - `agent_response`\n   839→\n   840→### 3.3 Final Output\n   841→\n   842→When customer says \"done\" or \"that's all\":\n   843→- Generate `orders/{session_id}/final_order.json`:\n   844→\n   845→```json\n   846→{\n   847→  \"session_id\": \"uuid-here\",\n   848→  \"timestamp\": \"2026-01-21T14:30:00Z\",\n   849→  \"items\": [\n   850→    {\n   851→      \"item_name\": \"Big Mac\",\n   852→      \"category\": \"Beef & Pork\",\n   853→      \"modifiers\": [],\n   854→      \"quantity\": 1\n   855→    },\n   856→    {\n   857→      \"item_name\": \"Medium Fries\",\n   858→      \"category\": \"Snacks & Sides\",\n   859→      \"modifiers\": [],\n   860→      \"quantity\": 1\n   861→    }\n   862→  ],\n   863→  \"total_items\": 2,\n   864→  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n   865→}\n   866→```\n   867→\n   868→### 3.4 Menu Model Enhancements\n   869→\n   870→To support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n   871→\n   872→#### 3.4.1 New Fields\n   873→\n   874→1. **quantity field** (`int`, default=1)\n   875→   - Tracks how many of this item are in the order\n   876→   - Default value is 1 for single items\n   877→   - Used for aggregating duplicate items\n   878→\n   879→2. **item_id field** (`str`)\n   880→   - Unique identifier for each item instance\n   881→   - Auto-generated UUID to distinguish between item instances\n   882→   - Allows tracking individual items even with same name and modifiers\n   883→\n   884→#### 3.4.2 Item Addition (`__add__` method)\n   885→\n   886→Implements addition operator for combining items. Two items can be added if and only if:\n   887→\n   888→**Conditions**:\n   889→- `item1.item_name == item2.item_name` (exact name match)\n   890→- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n   891→\n   892→**Behavior**:\n   893→- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n   894→- If conditions are not met: Raise `ValueError` with descriptive message\n   895→\n   896→**Example Usage**:\n   897→```python\n   898→# Create two identical Big Macs\n   899→item1 = Item(\n   900→    category_name=\"Beef & Pork\",\n   901→    item_name=\"Big Mac\",\n   902→    available_as_base=True,\n   903→    quantity=1\n   904→)\n   905→\n   906→item2 = Item(\n   907→    category_name=\"Beef & Pork\",\n   908→    item_name=\"Big Mac\",\n   909→    available_as_base=True,\n   910→    quantity=2\n   911→)\n   912→\n   913→# Add them together\n   914→combined = item1 + item2  # quantity=3\n   915→\n   916→# Items with different modifiers cannot be added\n   917→item3 = Item(\n   918→    category_name=\"Beef & Pork\",\n   919→    item_name=\"Big Mac\",\n   920→    available_as_base=True,\n   921→    quantity=1\n   922→)\n   923→item3.add_modifier(\"No Pickles\")\n   924→\n   925→# This will raise ValueError\n   926→combined = item1 + item3  # Error! Different modifiers\n   927→```\n   928→\n   929→**Implementation Notes**:\n   930→- Modifier comparison uses set equality, so order doesn't matter\n   931→- The new combined item gets a new `item_id`\n   932→- Original items remain unchanged\n   933→- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n   934→\n   935→---\n   936→\n   937→## 4. Agent Instructions & Persona\n   938→\n   939→### 4.1 System Prompt\n   940→\n   941→```\n   942→You are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n   943→\n   944→1. Greet the customer warmly\n   945→2. Listen carefully to their order\n   946→3. Use the add_item_to_order function to record each item\n   947→4. Confirm each item with the customer\n   948→5. When they're done, read back their complete order\n   949→6. Thank them and tell them the total\n   950→\n   951→Guidelines:\n   952→- Be concise and natural in your responses\n   953→- If you're unsure about an item, ask for clarification\n   954→- Always confirm items before adding to the order\n   955→- Use the exact menu item names when confirming\n   956→- If a customer mentions an item not on the menu, politely inform them\n   957→\n   958→Menu Structure:\n   959→- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n   960→- 212 total items\n   961→- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n   962→```\n   963→\n   964→### 4.2 Conversation Flow\n   965→\n   966→```\n   967→Agent: \"Welcome to McDonald's! What can I get for you today?\"\n   968→\n   969→Customer: \"I'll have a Big Mac\"\n   970→\n   971→Agent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n   972→      \"Got it, one Big Mac. Anything else?\"\n   973→\n   974→Customer: \"And a medium fries\"\n   975→\n   976→Agent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n   977→      \"One medium fries. Anything else?\"\n   978→\n   979→Customer: \"No, that's all\"\n   980→\n   981→Agent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n   982→       Please pull around to the first window.\"\n   983→       [Writes final order JSON]\n   984→```\n   985→\n   986→---\n   987→\n   988→## 5. Testing Strategy\n   989→\n   990→### 5.1 Test Categories\n   991→\n   992→1. **Single Item Orders**\n   993→   - Simple: \"I want a Big Mac\"\n   994→   - With quantity: \"Two cheeseburgers\"\n   995→   - With modifiers: \"Quarter Pounder with cheese\"\n   996→\n   997→2. **Multi-Item Orders**\n   998→   - \"Big Mac, large fries, and a Coke\"\n   999→   - \"Two Big Macs, one with no pickles\"\n  1000→\n  1001→3. **Complex Orders**\n  1002→   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n  1003→   - Orders with substitutions\n  1004→   - Orders with special requests\n  1005→\n  1006→4. **Error Handling**\n  1007→   - Invalid items: \"I want a Whopper\" (Burger King item)\n  1008→   - Unclear requests: \"I want a burger\"\n  1009→   - Corrections: \"Actually, make that a McDouble\"\n  1010→\n  1011→5. **Accuracy Tests**\n  1012→   - STT variations: \"Big Mack\" → \"Big Mac\"\n  1013→   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n  1014→   - Modifier accuracy: Did modifiers get applied correctly?\n  1015→\n  1016→### 5.2 Test Implementation\n  1017→\n  1018→```python\n  1019→@pytest.mark.asyncio\n  1020→async def test_single_item_order_accuracy() -> None:\n  1021→    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n  1022→    async with (\n  1023→        _llm() as judge_llm,\n  1024→        AgentSession(llm=drive_thru_llm) as session,\n  1025→    ):\n  1026→        await session.start(DriveThruAgent())\n  1027→\n  1028→        # Customer orders a Big Mac\n  1029→        result = await session.run(user_input=\"I'll have a Big Mac\")\n  1030→\n  1031→        # Verify the agent called the add_item_to_order function\n  1032→        result.expect.next_event().is_function_call(\n  1033→            function_name=\"add_item_to_order\",\n  1034→            arguments={\n  1035→                \"category\": \"Beef & Pork\",\n  1036→                \"item_name\": \"Big Mac\",\n  1037→                \"quantity\": 1,\n  1038→                \"modifiers\": []\n  1039→            }\n  1040→        )\n  1041→\n  1042→        # Verify the agent confirmed the item\n  1043→        await (\n  1044→            result.expect.next_event()\n  1045→            .is_message(role=\"assistant\")\n  1046→            .judge(\n  1047→                judge_llm,\n  1048→                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n  1049→            )\n  1050→        )\n  1051→\n  1052→        # End the order\n  1053→        result = await session.run(user_input=\"That's all\")\n  1054→\n  1055→        # Verify final order JSON was created correctly\n  1056→        assert order_manager.get_final_order() == {\n  1057→            \"items\": [\n  1058→                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n  1059→            ]\n  1060→        }\n  1061→```\n  1062→\n  1063→### 5.3 Accuracy Metrics\n  1064→\n  1065→Track the following metrics:\n  1066→- **Item Name Accuracy**: % of items correctly identified\n  1067→- **Modifier Accuracy**: % of modifiers correctly applied\n  1068→- **Quantity Accuracy**: % of quantities correctly captured\n  1069→- **Order Completeness**: % of orders with all items captured\n  1070→- **False Positives**: Items added that weren't ordered\n  1071→- **False Negatives**: Items ordered but not added\n  1072→\n  1073→Target: 95%+ accuracy on all metrics\n  1074→\n  1075→---\n  1076→\n  1077→## 6. Implementation Phases\n  1078→\n  1079→### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n  1080→\n  1081→**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n  1082→\n  1083→#### Step 1.1: Menu Models & Validation (No dependencies)\n  1084→- [ ] Enhance `Item` class with `quantity` field (default=1)\n  1085→- [ ] Enhance `Item` class with `item_id` field (UUID)\n  1086→- [ ] Implement `__add__` method for `Item` class\n  1087→- [ ] Write unit tests for `Item` enhancements\n  1088→  - Test addition with same modifiers\n  1089→  - Test addition failure with different modifiers\n  1090→  - Test quantity field defaults\n  1091→\n  1092→#### Step 1.2: Pure Functions (No dependencies)\n  1093→- [ ] Implement `menu_validation.py` with pure functions\n  1094→  - `fuzzy_match_item()`\n  1095→  - `validate_item_exists()`\n  1096→  - `validate_modifiers()`\n  1097→  - `validate_order_item()`\n  1098→- [ ] Write comprehensive unit tests for validation functions\n  1099→  - Fast, deterministic, no I/O\n  1100→  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n  1101→\n  1102→#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n  1103→- [ ] Implement `MenuProvider` class\n  1104→  - Constructor loads JSON\n  1105→  - `search_items()`, `get_category()`, `get_item()`\n  1106→  - All methods return immutable data\n  1107→- [ ] Write unit tests for MenuProvider\n  1108→  - Use fixture JSON file\n  1109→  - Test search, category queries, item lookups\n  1110→  - Verify immutability (mutations don't affect provider)\n  1111→\n  1112→#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n  1113→- [ ] Define `OrderItem` dataclass\n  1114→- [ ] Implement `OrderStateManager` class\n  1115→  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  1116→  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  1117→  - `complete_order()`, `clear_order()`\n  1118→  - Incremental logging (append to JSONL after each mutation)\n  1119→  - Final JSON generation\n  1120→- [ ] Write unit tests for OrderStateManager\n  1121→  - Test in-memory state operations (fast)\n  1122→  - Test file I/O separately (use temp directory)\n  1123→  - Verify incremental log appends correctly\n  1124→  - Verify final JSON structure\n  1125→\n  1126→#### Step 1.5: Verify Boundaries\n  1127→- [ ] Ensure MenuProvider has no mutable state\n  1128→- [ ] Ensure OrderStateManager is single source of truth\n  1129→- [ ] Ensure validation functions are pure (no I/O, no side effects)\n  1130→- [ ] Run all unit tests - should be fast (<1 second total)\n  1131→\n  1132→### Phase 2: Coordination Layer (Build tools and wrappers)\n  1133→\n  1134→**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n  1135→\n  1136→#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n  1137→- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  1138→  - Define `add_item_to_order` tool schema\n  1139→    - Parameters: category, item_name, modifiers, quantity\n  1140→    - Description optimized for LLM understanding\n  1141→  - Implement tool function:\n  1142→    ```python\n  1143→    # 1. Validate using menu_validation.validate_order_item()\n  1144→    # 2. If valid: order_state.add_item()\n  1145→    # 3. Return structured confirmation\n  1146→    ```\n  1147→  - Define `complete_order` tool schema\n  1148→  - Implement tool function: calls order_state.complete_order()\n  1149→- [ ] Write integration tests for order_tools\n  1150→  - Mock OrderStateManager, real MenuProvider\n  1151→  - Verify validation is called before state mutation\n  1152→  - Verify tool returns proper schema\n  1153→  - Test invalid inputs (should not mutate state)\n  1154→\n  1155→#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n  1156→- [ ] Implement `DriveThruLLM` wrapper\n  1157→  - Constructor: receives wrapped_llm, menu_provider, config\n  1158→  - `chat()` method:\n  1159→    ```python\n  1160→    # 1. Extract keywords from latest user message\n  1161→    # 2. Query menu_provider.search_items(keyword)\n  1162→    # 3. Inject relevant items into chat_ctx (augment system message)\n  1163→    # 4. Delegate to wrapped_llm.chat()\n  1164→    ```\n  1165→  - Keep wrapper STATELESS\n  1166→- [ ] Write unit tests for DriveThruLLM\n  1167→  - Mock wrapped LLM\n  1168→  - Verify menu context is injected into chat_ctx\n  1169→  - Verify delegation to wrapped LLM\n  1170→  - No state stored in wrapper\n  1171→\n  1172→#### Step 2.3: Accuracy Strategies (Implement within existing components)\n  1173→- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n  1174→- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n  1175→- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n  1176→- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n  1177→- [ ] Verify all strategies are in place\n  1178→- [ ] Document which component owns which strategy\n  1179→\n  1180→### Phase 3: Agent Integration (Wire everything together)\n  1181→\n  1182→**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n  1183→\n  1184→#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n  1185→- [ ] Implement `DriveThruAgent` class\n  1186→  - Constructor receives: order_state, menu_provider, config\n  1187→  - Sets drive-thru specific instructions (system prompt)\n  1188→  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  1189→  - Agent OWNS OrderStateManager (composition)\n  1190→  - Agent RECEIVES MenuProvider (dependency injection)\n  1191→- [ ] Define agent instructions/persona\n  1192→  - Concise, friendly, efficient\n  1193→  - Clear about when to use tools\n  1194→  - Handles confirmation flow\n  1195→\n  1196→#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n  1197→- [ ] Add `DriveThruConfig` to `src/config.py`\n  1198→  - menu_file_path, orders_output_dir\n  1199→  - fuzzy_match_threshold, max_context_items\n  1200→  - enable_confirmation_loop, enable_semantic_search\n  1201→- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  1202→  - Instantiate MenuProvider (singleton, loaded once)\n  1203→  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  1204→  - Create OrderStateManager for each session (session_handler)\n  1205→  - Create DriveThruAgent (injecting order_state and menu_provider)\n  1206→  - Wire to SessionHandler\n  1207→- [ ] Verify dependency flow:\n  1208→  ```\n  1209→  App creates MenuProvider (singleton)\n  1210→     ├─> Injects into DriveThruLLM wrapper\n  1211→     ├─> Injects into DriveThruAgent\n  1212→     └─> Injects into OrderTools\n  1213→\n  1214→  App creates OrderStateManager per session\n  1215→     ├─> Owned by DriveThruAgent\n  1216→     └─> Passed to OrderTools\n  1217→  ```\n  1218→\n  1219→#### Step 3.3: Integration Testing\n  1220→- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  1221→  - No mocked components, real coordination\n  1222→  - Verify end-to-end flow: validate → add → log\n  1223→- [ ] Test console mode end-to-end\n  1224→  - Use mock LLM or real LLM with simple prompts\n  1225→  - Verify order state is persisted correctly\n  1226→  - Verify incremental logs and final JSON\n  1227→\n  1228→### Phase 4: Testing & Refinement (2-3 days)\n  1229→- [ ] Write comprehensive test suite (20+ tests)\n  1230→- [ ] Test with real voice input (console mode)\n  1231→- [ ] Measure accuracy metrics\n  1232→- [ ] Identify failure modes\n  1233→- [ ] Iterate on prompts and validation logic\n  1234→\n  1235→### Phase 5: Advanced Strategies (Optional, 2-3 days)\n  1236→- [ ] Implement Strategy 3: Explicit Confirmation Loop\n  1237→- [ ] Implement Strategy 5: Semantic Search with Embeddings\n  1238→- [ ] A/B test different strategy combinations\n  1239→- [ ] Optimize for latency and cost\n  1240→\n  1241→---\n  1242→\n  1243→## 7. File Structure\n  1244→\n  1245→```\n  1246→src/\n  1247→├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n  1248→├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n  1249→├── menu_provider.py             # Menu data provider (read-only)\n  1250→├── order_state_manager.py       # Order state + persistence (single source of truth)\n  1251→├── menu_validation.py           # Pure validation functions\n  1252→└── tools/\n  1253→    ├── __init__.py\n  1254→    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n  1255→\n  1256→tests/\n  1257→├── test_menu_validation.py      # Unit tests for pure functions (fast)\n  1258→├── test_menu_provider.py        # Unit tests for menu queries (fast)\n  1259→├── test_order_state.py          # Unit tests for state management (fast)\n  1260→├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n  1261→├── test_order_tools.py          # Integration tests for tools (medium)\n  1262→├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n  1263→└── test_accuracy.py             # Accuracy benchmarks (slow)\n  1264→\n  1265→orders/\n  1266→├── {session_id}/\n  1267→│   ├── incremental_log.jsonl    # Per-turn logging\n  1268→│   └── final_order.json         # Final order output\n  1269→\n  1270→menus/\n  1271→└── mcdonalds/\n  1272→    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n  1273→    └── transformed-data/\n  1274→        └── menu-structure-2026-01-21.json\n  1275→\n  1276→plan/\n  1277→└── mcdonalds-drive-thru-agent-plan.md  # This document\n  1278→\n  1279→\n  1280→Test Pyramid (following best practices):\n  1281→┌─────────────┐\n  1282→│  E2E Tests  │  ← Few, slow, test full agent behavior\n  1283→├─────────────┤\n  1284→│ Integration │  ← Some, medium, test component interactions\n  1285→├─────────────┤\n  1286→│ Unit Tests  │  ← Many, fast, test isolated components\n  1287→└─────────────┘\n  1288→\n  1289→Unit tests should be:\n  1290→- Fast (no I/O, no real LLM calls)\n  1291→- Isolated (test one component at a time)\n  1292→- Deterministic (no randomness, no flakiness)\n  1293→\n  1294→Integration tests should:\n  1295→- Use real components but mock expensive dependencies (e.g., mock LLM)\n  1296→- Test interactions between 2-3 components\n  1297→\n  1298→E2E tests should:\n  1299→- Use judge-based evaluation for natural language\n  1300→- Cover critical user paths\n  1301→- Be fewer in number (expensive to run)\n  1302→```\n  1303→\n  1304→---\n  1305→\n  1306→## 8. Configuration\n  1307→\n  1308→Add to `src/config.py`:\n  1309→\n  1310→```python\n  1311→class DriveThruConfig(BaseModel):\n  1312→    \"\"\"Configuration for drive-thru agent.\"\"\"\n  1313→\n  1314→    menu_file_path: str = Field(\n  1315→        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n  1316→        description=\"Path to menu JSON file\"\n  1317→    )\n  1318→\n  1319→    orders_output_dir: str = Field(\n  1320→        default=\"orders\",\n  1321→        description=\"Directory to save order files\"\n  1322→    )\n  1323→\n  1324→    fuzzy_match_threshold: int = Field(\n  1325→        default=85,\n  1326→        description=\"Minimum fuzzy match score (0-100)\"\n  1327→    )\n  1328→\n  1329→    enable_confirmation_loop: bool = Field(\n  1330→        default=True,\n  1331→        description=\"Require confirmation before adding items\"\n  1332→    )\n  1333→\n  1334→    enable_semantic_search: bool = Field(\n  1335→        default=False,\n  1336→        description=\"Use embeddings for semantic item search\"\n  1337→    )\n  1338→\n  1339→    max_context_items: int = Field(\n  1340→        default=50,\n  1341→        description=\"Maximum number of menu items to inject into context\"\n  1342→    )\n  1343→```\n  1344→\n  1345→---\n  1346→\n  1347→## 9. Risks & Mitigations\n  1348→\n  1349→### Risk 1: STT Errors\n  1350→**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n  1351→**Mitigation**:\n  1352→- Fuzzy string matching (Strategy 4)\n  1353→- Semantic search (Strategy 5)\n  1354→- Confirmation loop (Strategy 3)\n  1355→\n  1356→### Risk 2: LLM Hallucination\n  1357→**Impact**: LLM adds items not on the menu\n  1358→**Mitigation**:\n  1359→- Function calling with strict validation\n  1360→- Menu context injection (Strategy 2)\n  1361→- Post-processing validation (Strategy 9)\n  1362→\n  1363→### Risk 3: Modifier Errors\n  1364→**Impact**: Customer wants \"no pickles\" but modifier not captured\n  1365→**Mitigation**:\n  1366→- Structured modifier field in function calling\n  1367→- Validation against available modifiers per item\n  1368→- Explicit confirmation\n  1369→\n  1370→### Risk 4: Latency\n  1371→**Impact**: Slow response times frustrate customers\n  1372→**Mitigation**:\n  1373→- Use faster LLM (GPT-4.1-nano or similar)\n  1374→- Optimize context injection (Strategy 10)\n  1375→- Precompute embeddings if using Strategy 5\n  1376→- Enable preemptive generation\n  1377→\n  1378→### Risk 5: Multi-Item Order Complexity\n  1379→**Impact**: Customer orders 5 items in one utterance, agent misses some\n  1380→**Mitigation**:\n  1381→- Ask customer to order one item at a time\n  1382→- Use two-stage parsing (Strategy 6) if needed\n  1383→- Read back full order at end for correction\n  1384→\n  1385→---\n  1386→\n  1387→## 10. Success Criteria\n  1388→\n  1389→The implementation will be considered successful when:\n  1390→\n  1391→1. **Accuracy**: ≥95% item name accuracy on test suite\n  1392→2. **Modifier Accuracy**: ≥90% modifier accuracy\n  1393→3. **Completeness**: ≥95% of orders captured completely\n  1394→4. **Latency**: <2 seconds per turn (STT → TTS)\n  1395→5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n  1396→6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n  1397→7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n  1398→\n  1399→---\n  1400→\n  1401→## 11. Future Enhancements\n  1402→\n  1403→After initial implementation, consider:\n  1404→\n  1405→1. **Meal Combos**: Support \"Number 1\" style ordering\n  1406→2. **Upselling**: \"Would you like to make that a meal?\"\n  1407→3. **Menu Recommendations**: Based on time of day, weather, etc.\n  1408→4. **Price Calculation**: Calculate total cost\n  1409→5. **Multi-Language Support**: Spanish, etc.\n  1410→6. **Voice Biometrics**: Remember repeat customers\n  1411→7. **Order History**: \"Same as last time\"\n  1412→8. **Integration**: Connect to POS system for real orders\n  1413→\n  1414→---\n  1415→\n  1416→## 12. Key Design Decisions\n  1417→\n  1418→### Why Separate DriveThruLLM from OrderStateManager?\n  1419→**Principle**: Single Responsibility Principle (SRP)\n  1420→\n  1421→LLM wrapping (context injection) is orthogonal to state management. By separating:\n  1422→- DriveThruLLM can be tested with mock LLM (fast unit tests)\n  1423→- OrderStateManager can be tested without LLM (fast unit tests)\n  1424→- Each component has one reason to change\n  1425→- Components can be swapped independently (e.g., try different context injection strategies)\n  1426→\n  1427→### Why Pure Functions for Validation?\n  1428→**Principle**: Functional Core, Imperative Shell\n  1429→\n  1430→Pure functions are maximally testable:\n  1431→- No I/O, no side effects\n  1432→- Deterministic outputs for same inputs\n  1433→- Fast to execute (no database, no API calls)\n  1434→- Easy to reason about\n  1435→- Can be reused anywhere\n  1436→\n  1437→This enables Test-Driven Development: write test first, implement function, iterate quickly.\n  1438→\n  1439→### Why MenuProvider Returns Immutable Data?\n  1440→**Principle**: Immutability Reduces Bugs\n  1441→\n  1442→If MenuProvider returned mutable references:\n  1443→- Callers could accidentally modify menu data\n  1444→- Hard to track down where menu was corrupted\n  1445→- Thread safety issues in concurrent sessions\n  1446→\n  1447→By returning immutable copies:\n  1448→- Menu data is protected from accidental mutation\n  1449→- Single source of truth guaranteed\n  1450→- Easier to reason about data flow\n  1451→\n  1452→### Why OrderStateManager is the Only State Owner?\n  1453→**Principle**: Single Source of Truth (SSOT)\n  1454→\n  1455→All order mutations flow through one place:\n  1456→- Easy to add logging/auditing\n  1457→- Persistence logic centralized\n  1458→- Impossible to have inconsistent state\n  1459→- Debugging is straightforward: check one component\n  1460→- Testing is simple: verify state before/after\n  1461→\n  1462→Contrast with diffused state (anti-pattern):\n  1463→- State scattered across DriveThruLLM, tools, agent\n  1464→- Hard to debug: \"Where did this item come from?\"\n  1465→- Hard to test: need to set up multiple components\n  1466→- Brittle: changes ripple across multiple components\n  1467→\n  1468→### Why Tools are Thin Coordination Layer?\n  1469→**Principle**: Tell, Don't Ask\n  1470→\n  1471→Tools coordinate but don't implement logic:\n  1472→```python\n  1473→# Good (coordination)\n  1474→def add_item_to_order_tool(...):\n  1475→    result = validate_order_item(...)  # Ask validation layer\n  1476→    if result.is_valid:\n  1477→        order_state.add_item(...)      # Tell state manager\n  1478→    return confirmation\n  1479→\n  1480→# Bad (implementation leaking into tool)\n  1481→def add_item_to_order_tool(...):\n  1482→    # Fuzzy matching logic here\n  1483→    # Modifier validation logic here\n  1484→    # File I/O logic here\n  1485→    # Now tool is hard to test and has multiple responsibilities\n  1486→```\n  1487→\n  1488→### Why Function Calling?\n  1489→**Principle**: Make Invalid States Unrepresentable\n  1490→\n  1491→Function calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n  1492→\n  1493→Schema enforcement means: \"If it parses, it's valid\" (or close to it).\n  1494→\n  1495→### Why Multiple Strategies?\n  1496→**Principle**: Defense in Depth\n  1497→\n  1498→No single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.\n  1499→\n  1500→### Why Confirmation Loop?\n  1501→**Principle**: Human-in-the-Loop\n  1502→\n  1503→Voice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.\n  1504→\n  1505→### Why Incremental Logging?\n  1506→**Principle**: Observability & Debuggability\n  1507→\n  1508→Provides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.\n  1509→\n  1510→Enables data-driven improvement: analyze logs to find common error patterns.\n  1511→\n  1512→### Why Focus on Accuracy Over Speed?\n  1513→**Principle**: Correctness First, Optimization Second\n  1514→\n  1515→Wrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n  1516→\n  1517→Premature optimization is the root of all evil. Get it working, get it right, then make it fast.\n  1518→\n  1519→### Why Test Pyramid (Many Unit, Few E2E)?\n  1520→**Principle**: Fast Feedback Loops (Continuous Delivery)\n  1521→\n  1522→Unit tests:\n  1523→- Run in milliseconds\n  1524→- Give instant feedback\n  1525→- Pinpoint exact failure\n  1526→- Enable rapid iteration\n  1527→\n  1528→E2E tests:\n  1529→- Run in seconds/minutes\n  1530→- Slow feedback\n  1531→- Hard to debug failures\n  1532→- Necessary but expensive\n  1533→\n  1534→Build on solid foundation of fast unit tests, use E2E tests for critical paths only.\n  1535→\n  1536→### Why Dependency Injection?\n  1537→**Principle**: Inversion of Control (IoC)\n  1538→\n  1539→Components receive dependencies rather than creating them:\n  1540→- Easy to substitute mocks for testing\n  1541→- Easy to swap implementations (e.g., different LLM, different storage)\n  1542→- Explicit dependencies (no hidden coupling)\n  1543→- Testable in isolation\n  1544→\n  1545→```python\n  1546→# Good (DI)\n  1547→class DriveThruAgent:\n  1548→    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):\n  1549→        self.order_state = order_state  # Injected\n  1550→        self.menu = menu                # Injected\n  1551→\n  1552→# Bad (hidden dependencies)\n  1553→class DriveThruAgent:\n  1554→    def __init__(self):\n  1555→        self.order_state = OrderStateManager()  # Hard-coded\n  1556→        self.menu = MenuProvider()              # Hard-coded\n  1557→        # Now can't test with mocks, can't swap implementations\n  1558→```\n  1559→\n  1560→---\n  1561→\n  1562→## 13. Experimentation Framework\n  1563→\n  1564→To determine which strategies work best, implement an experimentation framework:\n  1565→\n  1566→```python\n  1567→class AccuracyExperiment:\n  1568→    \"\"\"Framework for testing accuracy strategies.\"\"\"\n  1569→\n  1570→    def __init__(self, test_cases: list[OrderTestCase]):\n  1571→        self.test_cases = test_cases\n  1572→\n  1573→    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n  1574→        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n  1575→        results = []\n  1576→        for test_case in self.test_cases:\n  1577→            result = await self.run_single_test(test_case, strategy_config)\n  1578→            results.append(result)\n  1579→        return ExperimentResults(results)\n  1580→\n  1581→    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n  1582→        \"\"\"A/B test two strategy configurations.\"\"\"\n  1583→        results_a = await self.run_experiment(strategy_a)\n  1584→        results_b = await self.run_experiment(strategy_b)\n  1585→        return Comparison(results_a, results_b)\n  1586→```\n  1587→\n  1588→Use this to answer questions like:\n  1589→- Does semantic search improve accuracy over fuzzy matching?\n  1590→- What's the optimal fuzzy match threshold?\n  1591→- Does chain-of-thought reduce hallucination?\n  1592→- What's the latency vs accuracy tradeoff?\n  1593→\n  1594→---\n  1595→\n  1596→## 14. Monitoring & Observability\n  1597→\n  1598→In production, track:\n  1599→- **Per-turn metrics**: Item extraction accuracy, latency\n  1600→- **Per-order metrics**: Order completeness, correction rate\n  1601→- **LLM metrics**: Token usage, cost per order\n  1602→- **Error rates**: Invalid items, failed validations\n  1603→- **User satisfaction**: Explicit feedback, order completion rate\n  1604→\n  1605→Use LiveKit's built-in metrics framework + custom application metrics.\n  1606→\n  1607→---\n  1608→\n  1609→## Conclusion\n  1610→\n  1611→This plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n  1612→\n  1613→The phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n  1614→\n  1615→**Next Steps**:\n  1616→1. Review and approve this plan\n  1617→2. Begin Phase 1 implementation\n  1618→3. Set up testing infrastructure\n  1619→4. Iterate based on real-world results\n  1620→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8f601171-0224-4e82-bbdd-4628e2b76cde","timestamp":"2026-01-22T00:42:46.656Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/thoughts/mcdonalds-drive-thru-agent-plan.md","content":"# McDonald's Drive-Thru Order Taker Agent - Implementation Plan\n\n**Created**: 2026-01-21\n**Status**: Planning Phase\n**Goal**: Create a high-accuracy voice AI agent for taking McDonald's drive-thru orders\n\n---\n\n## Executive Summary\n\nThis plan outlines the implementation of a custom voice AI agent that acts as a McDonald's drive-thru order taker. The agent must accurately capture customer orders from the 212-item menu across 9 categories, maintain order state, and generate structured output files. The primary focus is on **maximizing accuracy** through multiple complementary strategies.\n\n---\n\n## 0. Clean Architecture Principles (Kent Beck + Dave Farley)\n\nThis implementation follows clean architecture principles for maintainability, testability, and continuous delivery.\n\n### Core Principles Checklist\n\n**✓ Single Responsibility Principle (SRP)**\n- Each component has one reason to change\n- DriveThruLLM: Context injection only (no state)\n- OrderStateManager: State + persistence only\n- MenuProvider: Read-only data access only\n- menu_validation.py: Pure validation functions only\n\n**✓ Dependency Inversion**\n- Components receive dependencies via constructor (DI)\n- High-level components don't depend on low-level details\n- Easy to mock, easy to test, easy to swap\n\n**✓ Pure Functions Where Possible**\n- menu_validation.py: 100% pure functions\n- No I/O, no side effects, fully deterministic\n- Fast, testable, reusable\n\n**✓ Immutability Reduces Bugs**\n- MenuProvider returns immutable data\n- Menu cannot be accidentally corrupted\n- Thread-safe by design\n\n**✓ Single Source of Truth**\n- OrderStateManager is ONLY owner of order state\n- All mutations flow through one place\n- Easy to debug, easy to audit, easy to test\n\n**✓ Tell, Don't Ask**\n- Tools tell OrderStateManager what to do\n- Don't query state, mutate it, then write back\n- Reduces coupling, increases cohesion\n\n**✓ Test Pyramid**\n- Many fast unit tests (milliseconds)\n- Some integration tests (seconds)\n- Few E2E tests (minutes)\n- Fast feedback loops enable TDD\n\n**✓ Make Invalid States Unrepresentable**\n- Use type system + schemas to prevent errors\n- Function calling enforces structure\n- Validation happens before state mutation\n\n### Boundary Rules\n\n| Component | Can Access | Cannot Access |\n|-----------|-----------|---------------|\n| `menu_validation.py` | Menu data (parameter) | Nothing (pure functions) |\n| `MenuProvider` | Menu JSON file | Order state, LLM |\n| `OrderStateManager` | Order state, file I/O | Menu data, LLM, validation logic |\n| `OrderTools` | OrderStateManager, MenuProvider, menu_validation | LLM internals |\n| `DriveThruLLM` | MenuProvider, wrapped LLM | Order state, validation |\n| `DriveThruAgent` | Everything (orchestrator) | N/A |\n\n**Dependency Flow** (always downward, never circular):\n```\nDriveThruAgent\n    ├─> OrderStateManager\n    ├─> MenuProvider\n    ├─> OrderTools\n    │       ├─> menu_validation.py\n    │       ├─> OrderStateManager\n    │       └─> MenuProvider\n    └─> DriveThruLLM\n            └─> MenuProvider\n```\n\n### Testing Strategy\n\n**Unit Tests** (Fast, isolated, many)\n- `test_menu_validation.py`: Pure functions, no mocks needed\n- `test_menu_provider.py`: Test with fixture JSON\n- `test_order_state.py`: In-memory state, temp file I/O\n- `test_drive_thru_llm.py`: Mock wrapped LLM\n\n**Integration Tests** (Medium speed, some mocks)\n- `test_order_tools.py`: Real MenuProvider, mock OrderStateManager\n\n**E2E Tests** (Slow, real components, few)\n- `test_drive_thru_agent.py`: Full agent with judge-based evaluation\n- `test_accuracy.py`: Accuracy benchmarks\n\n**Goal**: Unit tests run in <1 second total, enabling rapid TDD cycles.\n\n---\n\n## 1. System Architecture\n\n### 1.1 Core Components & Data Flow\n\n```\nCustomer Voice Input\n    ↓\n[STT] → AssemblyAI Universal Streaming\n    ↓\n[AgentSession with DriveThruLLM wrapper]\n    │\n    ├─> DriveThruLLM.chat()\n    │   ├─ Queries MenuProvider for context\n    │   ├─ Injects menu context into chat_ctx\n    │   └─ Delegates to Base LLM (OpenAI GPT-4.1)\n    │\n    ├─> Base LLM outputs function call → add_item_to_order(...)\n    │\n    ├─> OrderTools.add_item_to_order()\n    │   ├─ Calls menu_validation.validate_item() [pure function]\n    │   ├─ If valid: OrderStateManager.add_item() [state mutation]\n    │   │   └─ OrderStateManager appends to incremental log\n    │   └─ Returns result to LLM\n    │\n    └─> LLM generates response text\n    ↓\n[TTS] → Inworld/Cartesia\n    ↓\nAgent Voice Response\n\n\n┌─────────────────────────────────────────────────────┐\n│ Dependency Diagram (Composition, not inheritance)  │\n└─────────────────────────────────────────────────────┘\n\nVoiceAgentApp\n    │\n    ├─> Creates: DriveThruAgent (owns conversation)\n    │        │\n    │        ├─> Owns: OrderStateManager (mutable state)\n    │        │\n    │        ├─> Receives: MenuProvider (read-only data)\n    │        │\n    │        └─> Registers: OrderTools (coordination layer)\n    │                  │\n    │                  ├─> Uses: menu_validation.py (pure functions)\n    │                  │\n    │                  ├─> Calls: OrderStateManager (state mutations)\n    │                  │\n    │                  └─> Queries: MenuProvider (data access)\n    │\n    ├─> Creates: DriveThruLLM (wraps base LLM)\n    │        │\n    │        └─> Queries: MenuProvider (for context injection)\n    │\n    └─> Loads: MenuProvider (singleton, immutable)\n\n\nKey Principles:\n- MenuProvider: Read-only, queried by many\n- OrderStateManager: Write-heavy, single owner (DriveThruAgent)\n- menu_validation.py: Pure functions, no dependencies\n- DriveThruLLM: Stateless wrapper, delegates to base LLM\n- OrderTools: Thin coordination layer, receives dependencies\n```\n\n### 1.2 New Components to Build\n\nEach component has a single, well-defined responsibility following the Single Responsibility Principle.\n\n#### 1. **DriveThruLLM** (`src/drive_thru_llm.py`)\n**Responsibility**: Pure LLM wrapper - context injection only\n**Does**:\n- Wraps a base LLM (similar to `KeywordInterceptLLM` pattern)\n- Intercepts `chat()` calls to inject relevant menu context into `chat_ctx`\n- Delegates to wrapped LLM\n- Returns LLM stream\n\n**Does NOT**:\n- Manage order state (that's `OrderStateManager`)\n- Store any state (stateless wrapper)\n- Validate menu items (that's `menu_validation.py`)\n- Perform searches (that's `MenuProvider`)\n\n**Why**: Separation of concerns - LLM wrapping is orthogonal to state management\n\n---\n\n#### 2. **MenuProvider** (`src/menu_provider.py`)\n**Responsibility**: Read-only menu data access\n**Does**:\n- Loads menu data from JSON using existing Pydantic models\n- Provides search/query interface: `search_items(keyword)`, `get_category(name)`, `get_item(category, name)`\n- Returns menu data structures (immutable)\n\n**Does NOT**:\n- Modify menu data (read-only)\n- Validate orders (that's `menu_validation.py`)\n- Manage order state (that's `OrderStateManager`)\n- Fuzzy match (that's `menu_validation.py`)\n\n**Why**: Single source of truth for menu data, but purely a data provider\n\n---\n\n#### 3. **OrderStateManager** (`src/order_state_manager.py`)\n**Responsibility**: Single source of truth for order state and persistence\n**Does**:\n- Owns ALL order state (items, quantities, session info)\n- Provides command methods: `add_item()`, `remove_item()`, `clear_order()`, `complete_order()`\n- Provides query methods: `get_items()`, `get_total_count()`, `get_order_summary()`\n- Handles persistence: incremental log (append after each operation), final JSON (on complete)\n- Manages session lifecycle\n\n**Does NOT**:\n- Validate menu items (that's `menu_validation.py` - validation happens before calling OrderStateManager)\n- Search menu (that's `MenuProvider`)\n- Make decisions (it's told what to do)\n\n**Why**: All state changes go through one place - testable, debuggable, single source of truth\n\n---\n\n#### 4. **menu_validation.py** (`src/menu_validation.py`)\n**Responsibility**: Pure validation and matching functions\n**Does**:\n- Provides pure functions: `fuzzy_match_item()`, `validate_item_exists()`, `validate_modifiers()`\n- Fuzzy string matching using `rapidfuzz`\n- Returns validation results (success/failure with details)\n\n**Does NOT**:\n- Store state (pure functions only)\n- Load menu data (receives menu data as parameter)\n- Modify orders (just validates, doesn't change state)\n\n**Why**: Pure functions are maximally testable and reusable\n\n---\n\n#### 5. **OrderTools** (`src/tools/order_tools.py`)\n**Responsibility**: LiveKit Tool definitions for LLM function calling\n**Does**:\n- Defines `add_item_to_order` tool with schema (category, item_name, modifiers, quantity)\n- Defines `complete_order` tool\n- Thin wrappers that orchestrate: validate → add to order state → return result\n- Receives `OrderStateManager` and `MenuProvider` as dependencies\n\n**Does NOT**:\n- Own state (receives OrderStateManager)\n- Implement validation logic (calls menu_validation.py)\n\n**Why**: Tools are the interface between LLM and our system - they coordinate but don't own logic\n\n---\n\n#### 6. **DriveThruAgent** (`src/drive_thru_agent.py`)\n**Responsibility**: Agent orchestration and configuration\n**Does**:\n- Defines agent instructions/persona (system prompt)\n- Owns `OrderStateManager` instance (via composition)\n- Registers tools with agent (passing OrderStateManager as dependency)\n- Coordinates conversation flow\n\n**Does NOT**:\n- Manage state directly (delegates to OrderStateManager)\n- Validate items (delegates to validation layer via tools)\n- Load menu (receives MenuProvider as dependency)\n\n**Why**: Agent is the conductor - it orchestrates but delegates actual work\n\n---\n\n## 1.3 Component Contracts (Interfaces)\n\nFollowing the Interface Segregation Principle, here are the explicit contracts for each component.\n\n### MenuProvider Interface\n```python\nclass MenuProvider:\n    \"\"\"Read-only menu data provider.\"\"\"\n\n    def __init__(self, menu_file_path: str) -> None:\n        \"\"\"Load menu from JSON file.\"\"\"\n\n    def search_items(self, keyword: str, category: str | None = None) -> list[Item]:\n        \"\"\"Search for items by keyword, optionally filtered by category.\"\"\"\n\n    def get_category(self, category_name: str) -> list[Item]:\n        \"\"\"Get all items in a category.\"\"\"\n\n    def get_item(self, category_name: str, item_name: str) -> Item | None:\n        \"\"\"Get a specific item by category and name.\"\"\"\n\n    def get_all_categories(self) -> list[str]:\n        \"\"\"Get list of all category names.\"\"\"\n\n    def get_menu(self) -> Menu:\n        \"\"\"Get the complete menu (immutable).\"\"\"\n```\n\n### OrderStateManager Interface\n```python\n@dataclass\nclass OrderItem:\n    \"\"\"A single item in an order.\"\"\"\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    item_id: str = field(default_factory=lambda: str(uuid.uuid4()))\n    timestamp: datetime = field(default_factory=datetime.now)\n\n\nclass OrderStateManager:\n    \"\"\"Single source of truth for order state and persistence.\"\"\"\n\n    def __init__(self, session_id: str, output_dir: str) -> None:\n        \"\"\"Initialize order state for a session.\"\"\"\n\n    def add_item(self, item_name: str, category: str, modifiers: list[str], quantity: int = 1) -> OrderItem:\n        \"\"\"Add item to order. Returns the created OrderItem. Appends to incremental log.\"\"\"\n\n    def remove_item(self, item_id: str) -> bool:\n        \"\"\"Remove item by ID. Returns True if found and removed.\"\"\"\n\n    def update_item_quantity(self, item_id: str, new_quantity: int) -> bool:\n        \"\"\"Update quantity for an item. Returns True if found and updated.\"\"\"\n\n    def get_items(self) -> list[OrderItem]:\n        \"\"\"Get all items in current order (read-only copy).\"\"\"\n\n    def get_total_count(self) -> int:\n        \"\"\"Get total number of items (accounting for quantities).\"\"\"\n\n    def get_order_summary(self) -> str:\n        \"\"\"Get human-readable order summary.\"\"\"\n\n    def complete_order(self) -> dict:\n        \"\"\"Mark order complete and generate final JSON. Returns final order dict.\"\"\"\n\n    def clear_order(self) -> None:\n        \"\"\"Clear all items (for cancellation/restart).\"\"\"\n```\n\n### menu_validation Module (Pure Functions)\n```python\n@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation operation.\"\"\"\n    is_valid: bool\n    matched_item: Item | None = None\n    confidence_score: float = 0.0\n    error_message: str | None = None\n\n\ndef fuzzy_match_item(\n    item_name: str,\n    menu_items: list[Item],\n    threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Fuzzy match an item name against menu items. Returns best match if above threshold.\"\"\"\n\n\ndef validate_item_exists(\n    item_name: str,\n    category: str,\n    menu_provider: MenuProvider\n) -> ValidationResult:\n    \"\"\"Validate that an item exists in the specified category.\"\"\"\n\n\ndef validate_modifiers(\n    item: Item,\n    requested_modifiers: list[str],\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Validate that all requested modifiers are available for the item.\"\"\"\n\n\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Complete validation: item exists + modifiers valid. Convenience function.\"\"\"\n```\n\n### OrderTools (LiveKit Tool Definitions)\n```python\ndef create_order_tools(\n    order_state: OrderStateManager,\n    menu_provider: MenuProvider,\n    config: DriveThruConfig\n) -> list[Tool]:\n    \"\"\"Create LiveKit Tool instances with dependencies injected.\n\n    Returns:\n        List of Tool objects that can be registered with an Agent\n    \"\"\"\n\n    # Tool 1: add_item_to_order\n    # Schema: {category: str, item_name: str, modifiers: list[str], quantity: int}\n    # Behavior: validate → add to state → return confirmation\n\n    # Tool 2: complete_order\n    # Schema: {}\n    # Behavior: complete order → return summary\n```\n\n### DriveThruLLM Interface\n```python\nclass DriveThruLLM(LLM):\n    \"\"\"Stateless LLM wrapper that injects menu context.\"\"\"\n\n    def __init__(\n        self,\n        wrapped_llm: LLM,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize wrapper with dependencies.\"\"\"\n\n    def chat(\n        self,\n        *,\n        chat_ctx: ChatContext,\n        tools: list[Tool] | None = None,\n        **kwargs\n    ) -> LLMStream:\n        \"\"\"Intercept chat to inject menu context, then delegate to wrapped LLM.\"\"\"\n        # 1. Extract keywords from latest user message\n        # 2. Query MenuProvider for relevant items\n        # 3. Inject into chat_ctx as system message or augment existing prompt\n        # 4. Delegate to wrapped_llm.chat()\n```\n\n### DriveThruAgent\n```python\nclass DriveThruAgent(Agent):\n    \"\"\"Drive-thru order taking agent.\"\"\"\n\n    def __init__(\n        self,\n        order_state: OrderStateManager,\n        menu_provider: MenuProvider,\n        config: DriveThruConfig\n    ) -> None:\n        \"\"\"Initialize agent with dependencies.\n\n        - Sets instructions/persona\n        - Registers order tools\n        - Owns OrderStateManager\n        \"\"\"\n```\n\n**Design Principles Applied**:\n1. **Dependency Injection**: Components receive dependencies via constructor, not by creating them\n2. **Interface Segregation**: Each interface is minimal and focused\n3. **Immutability**: MenuProvider returns immutable data; OrderStateManager is the only mutator\n4. **Pure Functions**: `menu_validation.py` has no side effects, fully testable\n5. **Tell, Don't Ask**: Tools tell OrderStateManager what to do, don't query and manipulate\n6. **Single Source of Truth**: All order state lives in OrderStateManager\n\n---\n\n## 2. Accuracy-Boosting Strategies\n\n### Priority 1: Core Strategies (Implement First)\n\n#### Strategy 1: LLM Function Calling / Structured Output\n**Approach**: Define tools/functions that the LLM can call to add items to the order.\n\n**Implementation**:\n- Create `add_item_to_order` function with parameters:\n  - `category` (enum from menu categories)\n  - `item_name` (string)\n  - `modifiers` (list of strings)\n  - `quantity` (int, default 1)\n- LLM must use this function instead of free-form text\n- Validates parameters against menu before accepting\n\n**Pros**:\n- Structured, parseable output\n- Forces LLM to think in terms of menu structure\n- Easy to validate\n\n**Cons**:\n- Requires LLM with good function calling support\n- May feel less natural for complex orders\n\n**Accuracy Impact**: HIGH (8/10) - Eliminates parsing errors\n\n---\n\n#### Strategy 2: Menu Context Injection\n**Approach**: Dynamically inject relevant menu items into the LLM context based on customer utterance.\n\n**Implementation**:\n- When customer speaks, extract keywords (e.g., \"burger\", \"breakfast\", \"coffee\")\n- Fetch relevant menu items from Menu model\n- Include in system prompt: \"Available items: [filtered list]\"\n- Reduces hallucination by showing exact menu item names\n\n**Example**:\n```\nCustomer: \"I'd like a Big Mac\"\n→ Inject into context: \"Beef & Pork items: Big Mac, McDouble, Quarter Pounder...\"\n```\n\n**Pros**:\n- Reduces hallucination\n- Helps with exact item name matching\n- Context-aware\n\n**Cons**:\n- Increases token usage\n- May miss items if keyword matching fails\n\n**Accuracy Impact**: HIGH (8/10) - Grounds LLM in actual menu\n\n---\n\n#### Strategy 3: Explicit Confirmation Loop\n**Approach**: After each item is understood, explicitly confirm with customer.\n\n**Implementation**:\n- After LLM extracts an item, respond: \"Got it, one Big Mac. Anything else?\"\n- Customer can correct if wrong\n- Only write to order file after confirmation\n\n**Example Flow**:\n```\nCustomer: \"Big Mac please\"\nAgent: \"One Big Mac - is that correct?\"\nCustomer: \"Yes\"\nAgent: \"Great! Anything else?\"\n[Write to order file]\n```\n\n**Pros**:\n- Allows error correction\n- Builds customer confidence\n- Simple to implement\n\n**Cons**:\n- Slower ordering process\n- May annoy customers with simple orders\n\n**Accuracy Impact**: VERY HIGH (9/10) - Human-in-the-loop validation\n\n---\n\n#### Strategy 4: Fuzzy String Matching\n**Approach**: Use fuzzy matching to handle pronunciation variations and STT errors.\n\n**Implementation**:\n- Use `rapidfuzz` or `fuzzywuzzy` library\n- When LLM outputs an item name, fuzzy match against menu\n- Accept if confidence > 85%\n- Handle common variations:\n  - \"Big Mac\" vs \"big mac\" vs \"bigmac\" vs \"Big Mack\"\n  - \"McNuggets\" vs \"chicken nuggets\" vs \"nuggets\"\n\n**Example**:\n```python\nfrom rapidfuzz import process, fuzz\n\ndef find_menu_item(utterance: str, menu_items: list[str]) -> tuple[str, float]:\n    result = process.extractOne(utterance, menu_items, scorer=fuzz.ratio)\n    return result[0], result[1]  # item, confidence_score\n```\n\n**Pros**:\n- Handles STT errors\n- Tolerates variations\n- Fast and deterministic\n\n**Cons**:\n- Can match wrong items if names are similar\n- Requires confidence threshold tuning\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Catches STT errors\n\n---\n\n### Priority 2: Advanced Strategies (Implement Later for Optimization)\n\n#### Strategy 5: Semantic Search with Embeddings\n**Approach**: Use embeddings to find semantically similar menu items.\n\n**Implementation**:\n- Pre-compute embeddings for all menu items (OpenAI text-embedding-3-small)\n- Store in vector DB or in-memory\n- When customer speaks, embed their utterance\n- Find nearest neighbors in embedding space\n- Use as candidates for LLM to choose from\n\n**Pros**:\n- Handles synonyms (\"cheeseburger\" → \"Quarter Pounder with Cheese\")\n- Semantic understanding\n- Robust to paraphrasing\n\n**Cons**:\n- More complex implementation\n- Requires embedding API calls\n- May introduce latency\n\n**Accuracy Impact**: HIGH (8/10) - Semantic understanding\n\n---\n\n#### Strategy 6: Two-Stage Parsing\n**Approach**: Separate intent extraction from menu item selection.\n\n**Implementation**:\n1. **Stage 1**: Extract customer intent\n   - \"I want a burger with cheese\"\n   - Intent: {type: burger, modifiers: [cheese]}\n2. **Stage 2**: Match intent to menu items\n   - Search menu for burgers with cheese modifier\n   - Return candidates: [Cheeseburger, Double Cheeseburger, Quarter Pounder with Cheese]\n3. **Stage 3**: LLM selects best match or asks clarifying question\n\n**Pros**:\n- Cleaner separation of concerns\n- Can optimize each stage separately\n- Better debuggability\n\n**Cons**:\n- More complex\n- Additional latency from multiple stages\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Structured approach\n\n---\n\n#### Strategy 7: Chain-of-Thought Prompting\n**Approach**: Ask LLM to explain its reasoning before outputting.\n\n**Implementation**:\n```\nSystem: When a customer orders, think step-by-step:\n1. What type of item are they requesting? (burger, drink, breakfast, etc.)\n2. Which specific item from our menu matches best?\n3. Did they mention any modifiers?\n4. What quantity?\nThen output the structured order.\n```\n\n**Pros**:\n- Improves LLM reasoning\n- More interpretable\n- Can catch logic errors\n\n**Cons**:\n- Increases token usage\n- May add latency\n- Reasoning not always visible to customer\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps LLM think clearly\n\n---\n\n#### Strategy 8: Constrained Decoding\n**Approach**: Use grammar-based constrained generation (if LLM supports it).\n\n**Implementation**:\n- Define grammar for valid responses\n- LLM can only output strings that match the grammar\n- Grammar includes exact menu item names\n\n**Example Grammar**:\n```\nORDER := <ITEM> | <ITEM> \"and\" <ORDER>\nITEM := <QUANTITY> <MENU_ITEM> <MODIFIERS>\nMENU_ITEM := \"Big Mac\" | \"Quarter Pounder\" | ...\n```\n\n**Pros**:\n- Guarantees valid output\n- No hallucination possible\n- Perfect accuracy for item names\n\n**Cons**:\n- Very few LLMs support this\n- Complex to implement\n- May be too rigid\n\n**Accuracy Impact**: VERY HIGH (9/10) - If available\n\n---\n\n#### Strategy 9: Post-Processing Validation Layer\n**Approach**: Validate every LLM output against menu before mutating order state.\n\n**Implementation**: Pure function in `menu_validation.py`\n```python\ndef validate_order_item(\n    item_name: str,\n    category: str,\n    modifiers: list[str],\n    menu_provider: MenuProvider,\n    fuzzy_threshold: int = 85\n) -> ValidationResult:\n    \"\"\"Pure function: check item exists + modifiers valid.\"\"\"\n    # Check item exists in menu\n    # Check modifiers are valid for that item\n    # Return ValidationResult with matched item or error\n```\n\n**Component Ownership**: `menu_validation.py` (pure functions)\n\n**Pros**:\n- Last line of defense\n- Can auto-correct minor errors\n- Prevents invalid orders\n\n**Cons**:\n- Reactive, not proactive\n- May reject valid variations\n\n**Accuracy Impact**: MEDIUM-HIGH (7/10) - Safety net\n\n---\n\n#### Strategy 10: Context Window Optimization\n**Approach**: Only include relevant portions of menu in context.\n\n**Implementation**:\n- Detect if customer is ordering breakfast, lunch, drinks, etc.\n- Only inject that category's items into prompt\n- Reduces noise and token count\n- Improves focus\n\n**Example**:\n```\nCustomer: \"I want breakfast\"\n→ Only include Breakfast category items in context\n```\n\n**Pros**:\n- Reduces token usage\n- Reduces hallucination\n- Faster inference\n\n**Cons**:\n- May miss cross-category orders\n- Requires intent detection\n\n**Accuracy Impact**: MEDIUM (6/10) - Helps focus\n\n---\n\n### Recommended Strategy Combination & Component Ownership\n\nEach strategy is owned by a specific component, following SRP.\n\n**Phase 1 (MVP)**:\n1. **Function Calling** (Strategy 1)\n   - Owner: `OrderTools` (defines tool schemas)\n   - Core structure for order taking\n\n2. **Menu Context Injection** (Strategy 2)\n   - Owner: `DriveThruLLM` (injects context in chat())\n   - Grounding LLM in actual menu\n\n3. **Fuzzy String Matching** (Strategy 4)\n   - Owner: `menu_validation.py` (pure function)\n   - STT error handling\n\n4. **Post-Processing Validation** (Strategy 9)\n   - Owner: `OrderTools` (validates before state mutation)\n   - Safety net - validate before add_item()\n\n**Phase 2 (Optimization)**:\n5. **Explicit Confirmation Loop** (Strategy 3)\n   - Owner: `DriveThruAgent` (instructions/conversation flow)\n   - User validation\n\n6. **Semantic Search** (Strategy 5)\n   - Owner: `MenuProvider` (add embedding-based search method)\n   - Better matching via semantics\n\n**Phase 3 (Advanced)**:\n7. **Two-Stage Parsing** (Strategy 6)\n   - Owner: `OrderTools` (modify tool implementation)\n   - If needed for complex orders\n\n8. **Chain-of-Thought** (Strategy 7)\n   - Owner: `DriveThruAgent` (modify instructions)\n   - If needed for better reasoning\n\n**Key Insight**: Each strategy lives in exactly one component. This:\n- Makes it easy to A/B test strategies (change one component)\n- Enables independent testing of strategies\n- Prevents strategy logic from leaking across boundaries\n\n---\n\n## 3. Order State Management\n\n### 3.1 Order State Model\n\n```python\n@dataclass\nclass OrderItem:\n    item_name: str\n    category: str\n    modifiers: list[str]\n    quantity: int\n    timestamp: datetime\n    confirmed: bool = False\n\n@dataclass\nclass OrderSession:\n    session_id: str\n    start_time: datetime\n    items: list[OrderItem]\n    status: Literal[\"in_progress\", \"completed\", \"cancelled\"]\n```\n\n### 3.2 Incremental Logging\n\nAfter each customer turn where an item is added:\n- Append to `orders/{session_id}/incremental_log.jsonl`\n- Each line is a JSON object with:\n  - `timestamp`\n  - `customer_utterance`\n  - `item_parsed`\n  - `agent_response`\n\n### 3.3 Final Output\n\nWhen customer says \"done\" or \"that's all\":\n- Generate `orders/{session_id}/final_order.json`:\n\n```json\n{\n  \"session_id\": \"uuid-here\",\n  \"timestamp\": \"2026-01-21T14:30:00Z\",\n  \"items\": [\n    {\n      \"item_name\": \"Big Mac\",\n      \"category\": \"Beef & Pork\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    },\n    {\n      \"item_name\": \"Medium Fries\",\n      \"category\": \"Snacks & Sides\",\n      \"modifiers\": [],\n      \"quantity\": 1\n    }\n  ],\n  \"total_items\": 2,\n  \"order_summary\": \"1 Big Mac, 1 Medium Fries\"\n}\n```\n\n### 3.4 Menu Model Enhancements\n\nTo support order aggregation and better tracking, the `Item` class in `menus/mcdonalds/models.py` will be enhanced with the following features:\n\n#### 3.4.1 New Fields\n\n1. **quantity field** (`int`, default=1)\n   - Tracks how many of this item are in the order\n   - Default value is 1 for single items\n   - Used for aggregating duplicate items\n\n2. **item_id field** (`str`)\n   - Unique identifier for each item instance\n   - Auto-generated UUID to distinguish between item instances\n   - Allows tracking individual items even with same name and modifiers\n\n#### 3.4.2 Item Addition (`__add__` method)\n\nImplements addition operator for combining items. Two items can be added if and only if:\n\n**Conditions**:\n- `item1.item_name == item2.item_name` (exact name match)\n- `set(item1.modifiers) == set(item2.modifiers)` (same modifiers, order doesn't matter)\n\n**Behavior**:\n- If conditions are met: Create new item with `quantity = item1.quantity + item2.quantity`\n- If conditions are not met: Raise `ValueError` with descriptive message\n\n**Example Usage**:\n```python\n# Create two identical Big Macs\nitem1 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\n\nitem2 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=2\n)\n\n# Add them together\ncombined = item1 + item2  # quantity=3\n\n# Items with different modifiers cannot be added\nitem3 = Item(\n    category_name=\"Beef & Pork\",\n    item_name=\"Big Mac\",\n    available_as_base=True,\n    quantity=1\n)\nitem3.add_modifier(\"No Pickles\")\n\n# This will raise ValueError\ncombined = item1 + item3  # Error! Different modifiers\n```\n\n**Implementation Notes**:\n- Modifier comparison uses set equality, so order doesn't matter\n- The new combined item gets a new `item_id`\n- Original items remain unchanged\n- This enables order consolidation: \"Two Big Macs\" + \"One Big Mac\" = \"Three Big Macs\"\n\n---\n\n## 4. Agent Instructions & Persona\n\n### 4.1 System Prompt\n\n```\nYou are a friendly and efficient McDonald's drive-thru order taker. Your goal is to:\n\n1. Greet the customer warmly\n2. Listen carefully to their order\n3. Use the add_item_to_order function to record each item\n4. Confirm each item with the customer\n5. When they're done, read back their complete order\n6. Thank them and tell them the total\n\nGuidelines:\n- Be concise and natural in your responses\n- If you're unsure about an item, ask for clarification\n- Always confirm items before adding to the order\n- Use the exact menu item names when confirming\n- If a customer mentions an item not on the menu, politely inform them\n\nMenu Structure:\n- 9 categories: Breakfast, Beef & Pork, Chicken & Fish, Salads, Snacks & Sides, Desserts, Beverages, Coffee & Tea, Smoothies & Shakes\n- 212 total items\n- Some items have modifiers (e.g., \"Quarter Pounder\" with \"Cheese\")\n```\n\n### 4.2 Conversation Flow\n\n```\nAgent: \"Welcome to McDonald's! What can I get for you today?\"\n\nCustomer: \"I'll have a Big Mac\"\n\nAgent: [Calls add_item_to_order(category=\"Beef & Pork\", item_name=\"Big Mac\", quantity=1)]\n      \"Got it, one Big Mac. Anything else?\"\n\nCustomer: \"And a medium fries\"\n\nAgent: [Calls add_item_to_order(category=\"Snacks & Sides\", item_name=\"Medium Fries\", quantity=1)]\n      \"One medium fries. Anything else?\"\n\nCustomer: \"No, that's all\"\n\nAgent: \"Perfect! Your order is one Big Mac and one medium fries. Your total is [calculated].\n       Please pull around to the first window.\"\n       [Writes final order JSON]\n```\n\n---\n\n## 5. Testing Strategy\n\n### 5.1 Test Categories\n\n1. **Single Item Orders**\n   - Simple: \"I want a Big Mac\"\n   - With quantity: \"Two cheeseburgers\"\n   - With modifiers: \"Quarter Pounder with cheese\"\n\n2. **Multi-Item Orders**\n   - \"Big Mac, large fries, and a Coke\"\n   - \"Two Big Macs, one with no pickles\"\n\n3. **Complex Orders**\n   - \"I want a number 1 with a Coke\" (if meal combos are supported)\n   - Orders with substitutions\n   - Orders with special requests\n\n4. **Error Handling**\n   - Invalid items: \"I want a Whopper\" (Burger King item)\n   - Unclear requests: \"I want a burger\"\n   - Corrections: \"Actually, make that a McDouble\"\n\n5. **Accuracy Tests**\n   - STT variations: \"Big Mack\" → \"Big Mac\"\n   - Synonym handling: \"chicken nuggets\" → \"Chicken McNuggets\"\n   - Modifier accuracy: Did modifiers get applied correctly?\n\n### 5.2 Test Implementation\n\n```python\n@pytest.mark.asyncio\nasync def test_single_item_order_accuracy() -> None:\n    \"\"\"Test that a simple single-item order is captured accurately.\"\"\"\n    async with (\n        _llm() as judge_llm,\n        AgentSession(llm=drive_thru_llm) as session,\n    ):\n        await session.start(DriveThruAgent())\n\n        # Customer orders a Big Mac\n        result = await session.run(user_input=\"I'll have a Big Mac\")\n\n        # Verify the agent called the add_item_to_order function\n        result.expect.next_event().is_function_call(\n            function_name=\"add_item_to_order\",\n            arguments={\n                \"category\": \"Beef & Pork\",\n                \"item_name\": \"Big Mac\",\n                \"quantity\": 1,\n                \"modifiers\": []\n            }\n        )\n\n        # Verify the agent confirmed the item\n        await (\n            result.expect.next_event()\n            .is_message(role=\"assistant\")\n            .judge(\n                judge_llm,\n                intent=\"Confirms that one Big Mac was added to the order and asks if the customer wants anything else\"\n            )\n        )\n\n        # End the order\n        result = await session.run(user_input=\"That's all\")\n\n        # Verify final order JSON was created correctly\n        assert order_manager.get_final_order() == {\n            \"items\": [\n                {\"item_name\": \"Big Mac\", \"category\": \"Beef & Pork\", \"modifiers\": [], \"quantity\": 1}\n            ]\n        }\n```\n\n### 5.3 Accuracy Metrics\n\nTrack the following metrics:\n- **Item Name Accuracy**: % of items correctly identified\n- **Modifier Accuracy**: % of modifiers correctly applied\n- **Quantity Accuracy**: % of quantities correctly captured\n- **Order Completeness**: % of orders with all items captured\n- **False Positives**: Items added that weren't ordered\n- **False Negatives**: Items ordered but not added\n\nTarget: 95%+ accuracy on all metrics\n\n---\n\n## 6. Implementation Phases\n\n### Phase 1: Core Infrastructure (Build from bottom up, test-first)\n\n**Principle**: Start with components that have no dependencies (pure functions, data models), then build upward.\n\n#### Step 1.1: Menu Models & Validation (No dependencies)\n- [ ] Enhance `Item` class with `quantity` field (default=1)\n- [ ] Enhance `Item` class with `item_id` field (UUID)\n- [ ] Implement `__add__` method for `Item` class\n- [ ] Write unit tests for `Item` enhancements\n  - Test addition with same modifiers\n  - Test addition failure with different modifiers\n  - Test quantity field defaults\n\n#### Step 1.2: Pure Functions (No dependencies)\n- [ ] Implement `menu_validation.py` with pure functions\n  - `fuzzy_match_item()`\n  - `validate_item_exists()`\n  - `validate_modifiers()`\n  - `validate_order_item()`\n- [ ] Write comprehensive unit tests for validation functions\n  - Fast, deterministic, no I/O\n  - Test edge cases: empty inputs, exact matches, fuzzy matches, no matches\n\n#### Step 1.3: Read-Only Data Provider (Depends on: Item models)\n- [ ] Implement `MenuProvider` class\n  - Constructor loads JSON\n  - `search_items()`, `get_category()`, `get_item()`\n  - All methods return immutable data\n- [ ] Write unit tests for MenuProvider\n  - Use fixture JSON file\n  - Test search, category queries, item lookups\n  - Verify immutability (mutations don't affect provider)\n\n#### Step 1.4: Stateful Order Manager (Depends on: OrderItem dataclass)\n- [ ] Define `OrderItem` dataclass\n- [ ] Implement `OrderStateManager` class\n  - `add_item()`, `remove_item()`, `update_item_quantity()`\n  - `get_items()`, `get_total_count()`, `get_order_summary()`\n  - `complete_order()`, `clear_order()`\n  - Incremental logging (append to JSONL after each mutation)\n  - Final JSON generation\n- [ ] Write unit tests for OrderStateManager\n  - Test in-memory state operations (fast)\n  - Test file I/O separately (use temp directory)\n  - Verify incremental log appends correctly\n  - Verify final JSON structure\n\n#### Step 1.5: Verify Boundaries\n- [ ] Ensure MenuProvider has no mutable state\n- [ ] Ensure OrderStateManager is single source of truth\n- [ ] Ensure validation functions are pure (no I/O, no side effects)\n- [ ] Run all unit tests - should be fast (<1 second total)\n\n### Phase 2: Coordination Layer (Build tools and wrappers)\n\n**Principle**: Now that we have testable components, build the coordination layer that wires them together.\n\n#### Step 2.1: LLM Tools (Depends on: OrderStateManager, MenuProvider, menu_validation)\n- [ ] Implement `create_order_tools()` in `src/tools/order_tools.py`\n  - Define `add_item_to_order` tool schema\n    - Parameters: category, item_name, modifiers, quantity\n    - Description optimized for LLM understanding\n  - Implement tool function:\n    ```python\n    # 1. Validate using menu_validation.validate_order_item()\n    # 2. If valid: order_state.add_item()\n    # 3. Return structured confirmation\n    ```\n  - Define `complete_order` tool schema\n  - Implement tool function: calls order_state.complete_order()\n- [ ] Write integration tests for order_tools\n  - Mock OrderStateManager, real MenuProvider\n  - Verify validation is called before state mutation\n  - Verify tool returns proper schema\n  - Test invalid inputs (should not mutate state)\n\n#### Step 2.2: LLM Wrapper (Depends on: MenuProvider)\n- [ ] Implement `DriveThruLLM` wrapper\n  - Constructor: receives wrapped_llm, menu_provider, config\n  - `chat()` method:\n    ```python\n    # 1. Extract keywords from latest user message\n    # 2. Query menu_provider.search_items(keyword)\n    # 3. Inject relevant items into chat_ctx (augment system message)\n    # 4. Delegate to wrapped_llm.chat()\n    ```\n  - Keep wrapper STATELESS\n- [ ] Write unit tests for DriveThruLLM\n  - Mock wrapped LLM\n  - Verify menu context is injected into chat_ctx\n  - Verify delegation to wrapped LLM\n  - No state stored in wrapper\n\n#### Step 2.3: Accuracy Strategies (Implement within existing components)\n- [ ] Strategy 1: Function Calling - Already implemented in OrderTools ✓\n- [ ] Strategy 2: Menu Context Injection - Implemented in DriveThruLLM\n- [ ] Strategy 4: Fuzzy String Matching - Implemented in menu_validation.py\n- [ ] Strategy 9: Post-Processing Validation - Implemented in OrderTools (validate before add)\n- [ ] Verify all strategies are in place\n- [ ] Document which component owns which strategy\n\n### Phase 3: Agent Integration (Wire everything together)\n\n**Principle**: Agent is the orchestrator - it owns dependencies and wires them together.\n\n#### Step 3.1: Agent Implementation (Depends on: All components from Phase 1 & 2)\n- [ ] Implement `DriveThruAgent` class\n  - Constructor receives: order_state, menu_provider, config\n  - Sets drive-thru specific instructions (system prompt)\n  - Registers tools: `create_order_tools(order_state, menu_provider, config)`\n  - Agent OWNS OrderStateManager (composition)\n  - Agent RECEIVES MenuProvider (dependency injection)\n- [ ] Define agent instructions/persona\n  - Concise, friendly, efficient\n  - Clear about when to use tools\n  - Handles confirmation flow\n\n#### Step 3.2: App-Level Wiring (Depends on: DriveThruAgent, DriveThruLLM)\n- [ ] Add `DriveThruConfig` to `src/config.py`\n  - menu_file_path, orders_output_dir\n  - fuzzy_match_threshold, max_context_items\n  - enable_confirmation_loop, enable_semantic_search\n- [ ] Create `DriveThruVoiceAgentApp` (or extend `VoiceAgentApp`)\n  - Instantiate MenuProvider (singleton, loaded once)\n  - Wrap base LLM with DriveThruLLM (injecting MenuProvider)\n  - Create OrderStateManager for each session (session_handler)\n  - Create DriveThruAgent (injecting order_state and menu_provider)\n  - Wire to SessionHandler\n- [ ] Verify dependency flow:\n  ```\n  App creates MenuProvider (singleton)\n     ├─> Injects into DriveThruLLM wrapper\n     ├─> Injects into DriveThruAgent\n     └─> Injects into OrderTools\n\n  App creates OrderStateManager per session\n     ├─> Owned by DriveThruAgent\n     └─> Passed to OrderTools\n  ```\n\n#### Step 3.3: Integration Testing\n- [ ] Write integration test: OrderTools + OrderStateManager + MenuProvider\n  - No mocked components, real coordination\n  - Verify end-to-end flow: validate → add → log\n- [ ] Test console mode end-to-end\n  - Use mock LLM or real LLM with simple prompts\n  - Verify order state is persisted correctly\n  - Verify incremental logs and final JSON\n\n### Phase 4: Testing & Refinement (2-3 days)\n- [ ] Write comprehensive test suite (20+ tests)\n- [ ] Test with real voice input (console mode)\n- [ ] Measure accuracy metrics\n- [ ] Identify failure modes\n- [ ] Iterate on prompts and validation logic\n\n### Phase 5: Advanced Strategies (Optional, 2-3 days)\n- [ ] Implement Strategy 3: Explicit Confirmation Loop\n- [ ] Implement Strategy 5: Semantic Search with Embeddings\n- [ ] A/B test different strategy combinations\n- [ ] Optimize for latency and cost\n\n---\n\n## 7. File Structure\n\n```\nsrc/\n├── drive_thru_agent.py          # Agent orchestration (owns OrderStateManager)\n├── drive_thru_llm.py            # LLM wrapper (stateless context injection)\n├── menu_provider.py             # Menu data provider (read-only)\n├── order_state_manager.py       # Order state + persistence (single source of truth)\n├── menu_validation.py           # Pure validation functions\n└── tools/\n    ├── __init__.py\n    └── order_tools.py           # LiveKit Tool definitions (coordination layer)\n\ntests/\n├── test_menu_validation.py      # Unit tests for pure functions (fast)\n├── test_menu_provider.py        # Unit tests for menu queries (fast)\n├── test_order_state.py          # Unit tests for state management (fast)\n├── test_drive_thru_llm.py       # Unit tests for LLM wrapper (fast, mocked LLM)\n├── test_order_tools.py          # Integration tests for tools (medium)\n├── test_drive_thru_agent.py     # End-to-end agent tests (slow, uses real LLM/judge)\n└── test_accuracy.py             # Accuracy benchmarks (slow)\n\norders/\n├── {session_id}/\n│   ├── incremental_log.jsonl    # Per-turn logging\n│   └── final_order.json         # Final order output\n\nmenus/\n└── mcdonalds/\n    ├── models.py                # Pydantic models (Item, Modifier, Menu)\n    └── transformed-data/\n        └── menu-structure-2026-01-21.json\n\nplan/\n└── mcdonalds-drive-thru-agent-plan.md  # This document\n\n\nTest Pyramid (following best practices):\n┌─────────────┐\n│  E2E Tests  │  ← Few, slow, test full agent behavior\n├─────────────┤\n│ Integration │  ← Some, medium, test component interactions\n├─────────────┤\n│ Unit Tests  │  ← Many, fast, test isolated components\n└─────────────┘\n\nUnit tests should be:\n- Fast (no I/O, no real LLM calls)\n- Isolated (test one component at a time)\n- Deterministic (no randomness, no flakiness)\n\nIntegration tests should:\n- Use real components but mock expensive dependencies (e.g., mock LLM)\n- Test interactions between 2-3 components\n\nE2E tests should:\n- Use judge-based evaluation for natural language\n- Cover critical user paths\n- Be fewer in number (expensive to run)\n```\n\n---\n\n## 8. Configuration\n\nAdd to `src/config.py`:\n\n```python\nclass DriveThruConfig(BaseModel):\n    \"\"\"Configuration for drive-thru agent.\"\"\"\n\n    menu_file_path: str = Field(\n        default=\"menus/mcdonalds/transformed-data/menu-structure-2026-01-21.json\",\n        description=\"Path to menu JSON file\"\n    )\n\n    orders_output_dir: str = Field(\n        default=\"orders\",\n        description=\"Directory to save order files\"\n    )\n\n    fuzzy_match_threshold: int = Field(\n        default=85,\n        description=\"Minimum fuzzy match score (0-100)\"\n    )\n\n    enable_confirmation_loop: bool = Field(\n        default=True,\n        description=\"Require confirmation before adding items\"\n    )\n\n    enable_semantic_search: bool = Field(\n        default=False,\n        description=\"Use embeddings for semantic item search\"\n    )\n\n    max_context_items: int = Field(\n        default=50,\n        description=\"Maximum number of menu items to inject into context\"\n    )\n```\n\n---\n\n## 9. Risks & Mitigations\n\n### Risk 1: STT Errors\n**Impact**: Customer says \"Big Mac\" but STT hears \"Big Mack\" or \"big man\"\n**Mitigation**:\n- Fuzzy string matching (Strategy 4)\n- Semantic search (Strategy 5)\n- Confirmation loop (Strategy 3)\n\n### Risk 2: LLM Hallucination\n**Impact**: LLM adds items not on the menu\n**Mitigation**:\n- Function calling with strict validation\n- Menu context injection (Strategy 2)\n- Post-processing validation (Strategy 9)\n\n### Risk 3: Modifier Errors\n**Impact**: Customer wants \"no pickles\" but modifier not captured\n**Mitigation**:\n- Structured modifier field in function calling\n- Validation against available modifiers per item\n- Explicit confirmation\n\n### Risk 4: Latency\n**Impact**: Slow response times frustrate customers\n**Mitigation**:\n- Use faster LLM (GPT-4.1-nano or similar)\n- Optimize context injection (Strategy 10)\n- Precompute embeddings if using Strategy 5\n- Enable preemptive generation\n\n### Risk 5: Multi-Item Order Complexity\n**Impact**: Customer orders 5 items in one utterance, agent misses some\n**Mitigation**:\n- Ask customer to order one item at a time\n- Use two-stage parsing (Strategy 6) if needed\n- Read back full order at end for correction\n\n---\n\n## 10. Success Criteria\n\nThe implementation will be considered successful when:\n\n1. **Accuracy**: ≥95% item name accuracy on test suite\n2. **Modifier Accuracy**: ≥90% modifier accuracy\n3. **Completeness**: ≥95% of orders captured completely\n4. **Latency**: <2 seconds per turn (STT → TTS)\n5. **Robustness**: Handles invalid items gracefully (100% of test cases)\n6. **Output**: Correctly generates incremental logs and final JSON for 100% of orders\n7. **User Experience**: Judge-based tests confirm natural, friendly interaction\n\n---\n\n## 11. Future Enhancements\n\nAfter initial implementation, consider:\n\n1. **Meal Combos**: Support \"Number 1\" style ordering\n2. **Upselling**: \"Would you like to make that a meal?\"\n3. **Menu Recommendations**: Based on time of day, weather, etc.\n4. **Price Calculation**: Calculate total cost\n5. **Multi-Language Support**: Spanish, etc.\n6. **Voice Biometrics**: Remember repeat customers\n7. **Order History**: \"Same as last time\"\n8. **Integration**: Connect to POS system for real orders\n\n---\n\n## 12. Key Design Decisions\n\n### Why Separate DriveThruLLM from OrderStateManager?\n**Principle**: Single Responsibility Principle (SRP)\n\nLLM wrapping (context injection) is orthogonal to state management. By separating:\n- DriveThruLLM can be tested with mock LLM (fast unit tests)\n- OrderStateManager can be tested without LLM (fast unit tests)\n- Each component has one reason to change\n- Components can be swapped independently (e.g., try different context injection strategies)\n\n### Why Pure Functions for Validation?\n**Principle**: Functional Core, Imperative Shell\n\nPure functions are maximally testable:\n- No I/O, no side effects\n- Deterministic outputs for same inputs\n- Fast to execute (no database, no API calls)\n- Easy to reason about\n- Can be reused anywhere\n\nThis enables Test-Driven Development: write test first, implement function, iterate quickly.\n\n### Why MenuProvider Returns Immutable Data?\n**Principle**: Immutability Reduces Bugs\n\nIf MenuProvider returned mutable references:\n- Callers could accidentally modify menu data\n- Hard to track down where menu was corrupted\n- Thread safety issues in concurrent sessions\n\nBy returning immutable copies:\n- Menu data is protected from accidental mutation\n- Single source of truth guaranteed\n- Easier to reason about data flow\n\n### Why OrderStateManager is the Only State Owner?\n**Principle**: Single Source of Truth (SSOT)\n\nAll order mutations flow through one place:\n- Easy to add logging/auditing\n- Persistence logic centralized\n- Impossible to have inconsistent state\n- Debugging is straightforward: check one component\n- Testing is simple: verify state before/after\n\nContrast with diffused state (anti-pattern):\n- State scattered across DriveThruLLM, tools, agent\n- Hard to debug: \"Where did this item come from?\"\n- Hard to test: need to set up multiple components\n- Brittle: changes ripple across multiple components\n\n### Why Tools are Thin Coordination Layer?\n**Principle**: Tell, Don't Ask\n\nTools coordinate but don't implement logic:\n```python\n# Good (coordination)\ndef add_item_to_order_tool(...):\n    result = validate_order_item(...)  # Ask validation layer\n    if result.is_valid:\n        order_state.add_item(...)      # Tell state manager\n    return confirmation\n\n# Bad (implementation leaking into tool)\ndef add_item_to_order_tool(...):\n    # Fuzzy matching logic here\n    # Modifier validation logic here\n    # File I/O logic here\n    # Now tool is hard to test and has multiple responsibilities\n```\n\n### Why Function Calling?\n**Principle**: Make Invalid States Unrepresentable\n\nFunction calling provides structured output that's easy to validate and parse. It forces the LLM to think in terms of discrete actions rather than free-form text, reducing ambiguity.\n\nSchema enforcement means: \"If it parses, it's valid\" (or close to it).\n\n### Why Multiple Strategies?\n**Principle**: Defense in Depth\n\nNo single strategy achieves 100% accuracy. Layering multiple complementary strategies (function calling + fuzzy matching + validation) creates a robust system where failures at one level are caught by another.\n\n### Why Confirmation Loop?\n**Principle**: Human-in-the-Loop\n\nVoice AI has inherent uncertainty (STT errors, LLM mistakes). Confirming each item catches errors before they compound. Cheaper to fix early than to remake entire order.\n\n### Why Incremental Logging?\n**Principle**: Observability & Debuggability\n\nProvides an audit trail and debugging information. If final order is wrong, we can trace back through the conversation to see where it went wrong.\n\nEnables data-driven improvement: analyze logs to find common error patterns.\n\n### Why Focus on Accuracy Over Speed?\n**Principle**: Correctness First, Optimization Second\n\nWrong orders are worse than slow orders. Once accuracy is proven, we can optimize for latency.\n\nPremature optimization is the root of all evil. Get it working, get it right, then make it fast.\n\n### Why Test Pyramid (Many Unit, Few E2E)?\n**Principle**: Fast Feedback Loops (Continuous Delivery)\n\nUnit tests:\n- Run in milliseconds\n- Give instant feedback\n- Pinpoint exact failure\n- Enable rapid iteration\n\nE2E tests:\n- Run in seconds/minutes\n- Slow feedback\n- Hard to debug failures\n- Necessary but expensive\n\nBuild on solid foundation of fast unit tests, use E2E tests for critical paths only.\n\n### Why Dependency Injection?\n**Principle**: Inversion of Control (IoC)\n\nComponents receive dependencies rather than creating them:\n- Easy to substitute mocks for testing\n- Easy to swap implementations (e.g., different LLM, different storage)\n- Explicit dependencies (no hidden coupling)\n- Testable in isolation\n\n```python\n# Good (DI)\nclass DriveThruAgent:\n    def __init__(self, order_state: OrderStateManager, menu: MenuProvider):\n        self.order_state = order_state  # Injected\n        self.menu = menu                # Injected\n\n# Bad (hidden dependencies)\nclass DriveThruAgent:\n    def __init__(self):\n        self.order_state = OrderStateManager()  # Hard-coded\n        self.menu = MenuProvider()              # Hard-coded\n        # Now can't test with mocks, can't swap implementations\n```\n\n---\n\n## 13. Experimentation Framework\n\nTo determine which strategies work best, implement an experimentation framework:\n\n```python\nclass AccuracyExperiment:\n    \"\"\"Framework for testing accuracy strategies.\"\"\"\n\n    def __init__(self, test_cases: list[OrderTestCase]):\n        self.test_cases = test_cases\n\n    async def run_experiment(self, strategy_config: dict) -> ExperimentResults:\n        \"\"\"Run all test cases with a given strategy configuration.\"\"\"\n        results = []\n        for test_case in self.test_cases:\n            result = await self.run_single_test(test_case, strategy_config)\n            results.append(result)\n        return ExperimentResults(results)\n\n    def compare_strategies(self, strategy_a: dict, strategy_b: dict) -> Comparison:\n        \"\"\"A/B test two strategy configurations.\"\"\"\n        results_a = await self.run_experiment(strategy_a)\n        results_b = await self.run_experiment(strategy_b)\n        return Comparison(results_a, results_b)\n```\n\nUse this to answer questions like:\n- Does semantic search improve accuracy over fuzzy matching?\n- What's the optimal fuzzy match threshold?\n- Does chain-of-thought reduce hallucination?\n- What's the latency vs accuracy tradeoff?\n\n---\n\n## 14. Monitoring & Observability\n\nIn production, track:\n- **Per-turn metrics**: Item extraction accuracy, latency\n- **Per-order metrics**: Order completeness, correction rate\n- **LLM metrics**: Token usage, cost per order\n- **Error rates**: Invalid items, failed validations\n- **User satisfaction**: Explicit feedback, order completion rate\n\nUse LiveKit's built-in metrics framework + custom application metrics.\n\n---\n\n## Conclusion\n\nThis plan provides a comprehensive roadmap for building a high-accuracy McDonald's drive-thru order taker. The key insight is that **accuracy requires multiple layered strategies**, not a single silver bullet. By combining function calling, menu context injection, fuzzy matching, and validation, we can achieve 95%+ accuracy while maintaining a natural conversational experience.\n\nThe phased approach allows for iterative development: start with core infrastructure, implement MVP accuracy strategies, test thoroughly, then optimize with advanced strategies as needed.\n\n**Next Steps**:\n1. Review and approve this plan\n2. Begin Phase 1 implementation\n3. Set up testing infrastructure\n4. Iterate based on real-world results\n","numLines":1620,"startLine":1,"totalLines":1620}},"sourceToolAssistantUUID":"837e7495-0027-4319-8976-fc3885bda6d2"}
{"parentUuid":"8f601171-0224-4e82-bbdd-4628e2b76cde","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01P3Vko2yfCGsiEu99i4RhMH","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Great! Now I have a comprehensive understanding of the McDonald's Drive-Thru Agent implementation plan. The user wants me to:\n\n1. Create a plan for BDD scenarios\n2. Write a markdown document describing what a minimal list of BDD scenarios and feature files might look like\n3. Focus on testing behavior, not implementation\n4. Only create the markdown document describing the scenarios - not the actual feature files themselves\n\nBased on the plan I've read, I can see:\n- The system is a voice AI drive-thru order taker for McDonald's\n- It has 212 menu items across 9 categories\n- It uses structured function calling, menu validation, order state management\n- The focus is on accuracy (95%+ target)\n- There's a clear architecture with separation of concerns\n- Testing strategy includes unit, integration, and E2E tests\n\nFor BDD scenarios, I should focus on:\n1. User-facing behavior (what the customer experiences)\n2. Not implementation details (no testing of specific classes or methods)\n3. Key workflows like ordering, confirming, correcting mistakes\n4. Error handling from a user perspective\n5. Different types of orders (simple, complex, with modifiers, etc.)\n\nLet me create a comprehensive markdown document that outlines minimal BDD scenarios organized by feature areas.","signature":"EpYLCkYICxgCKkABknlHq7HQBlV/0fpBTlvOWAmDgocUFnXw8+pAZpsTR2Ge6jPUszIQ1vCU0wa+lW0n1M5lrN+Q31JqWNLWTgf9Egz4R2lJirfRBZTEwZIaDL4ZvWeDtTiwh3ZMJiIwTW9eaXJ5h/845ZEPe/K5enTm93pXYag9FkcZbP0QgmqPWlwK0Ta+kqLRzHb00G5fKv0JZJL6I+OPN5hhLo/8hGt917sAg+Y6aNzBe0yhb/9V4WXs+yJ8BLIswgvg76SwQ5eyBKrnYRBC8mhqxVjaljoCoEzVbYIHcze6gmqCT7p00RgQycdW0EIUm+/4CEieb2IswZE9aWPCrL0BzS2T0KbNJWzZnkgfCRUfjuV2IQDLTB8diXuuCzf3/GQ3O4+YEHz5sWa9E3Xe6Qq08TqBKAk4wUBNi9PCk0y9KjtKAW5a1YOJAH3oyZQ8LxL83w99MplwpOejkb/+edSgKp9R+b8Lls74lIeYYuRT/qnALgdTN3Ag0QbVSlXAX+YsOLv8IFGNIciKC8Rr9KTpDHKYMTR0kiR4wZNagaOfhgjPH3l1wcU8fP1uEY+BeXi3jNDBk9dDQk5wN9OV+sBrWVuuqgDmmTUydwGCLe9LVS9IFTKNIGANTnKpYmgmye2PKqvzThGv7N1b7Kb3U2EFCxKeZlZ4WUMNbkTUwPTvZYrdA6Gr102/m0orgFXcs/rjOfZGEheKFAYXEMUYK43RfQg0T2a2Fa1PvzhgRw3+Ynyf9tzPGSZ2y3/4KtJIX0MpwwHskZPvCWdSK1fGwTcskCnK7/ci/gvGUABwUmEiDmWjq6TaJymjz5w6ebjhvUkXH+HuJKz2pY5lhJDXlT0m5w196GtuX7D0z/BGNnnFURTMt5onY0tlJuEpyd604eNAknFo0NKQsY4OPb41mL9O2pK30OVY1K/MHvk3w82f0SwH/bM1gHPX3n0XbOnrEQvg8upOlHdVfIOuP6OYDCQoNA36a8xn4PRPnJH1CKqLXl3Z0c5WymUf1pYtN8ekwzI+QgYt8DeO1MKo4m98uKFqIJpgTyDZOGromSmRnANfdZOEhTzWyjKuyJ4CMIHeyJgwYrmr2kf+Jd51ff4CUkUEQmLq6SHy8Fe2OmFv3suWpH8n1eQALvsUDQH8jzBipH030KAqsMUv/U23dDwsIhmptqgP7/NWmT/ZLouJ+xUOpiK3qHp0eJNTpXuoxC8irg88szivH7Fs7SMKqJwWLoJDASFxnHDj2viX5UxOvUoxL/4VsxvycxcgXU5LJNpl+Y2ngh0DSBX29sUV8SJbNtWIHEUh+NpeVXC+7HqyvEk7zlUrDx+dgkrl2dHsP7kNPKVbwqv9G/71mbmEyjyK6vAekhrBjjun1em9nHT0EkW8ajzVkeKFPmWvpdxn0RCzAwEvQ93Oads1EO/BFgMfwfh9FFGN7m/8ezTT58HOJbYVRA0Frg72ZS5N+MTytlVE/+x0pwyOYmCErAplqJtgSaQ6YsRMWJOM/0UCLJccKZ4NzbT6IVea/oYot+2CfduDa6pljBH2r5zVVq7MZ8a+k0MbNMdlbJQ55HDcPfxsEaI7/+rALhdSbd1wlGzInABicw8msgFb32HKt8N/xaYNACfdVYLxQ6xUOMwJ/cLxLzTI9mVTPrXjIN/1ni9KgL+JWbdzeif0NzVPCiAoefzuWqMAtAO8Xn8aSRqxmVR9+51ws7aEjsVVSRRW+9RH9wCr2+cH1QLZFqngncN5/7ahQEYbPsho4pjFT5ZjBKOlSMKzzPsl2yoDQ8Egm64ZAoSJ2Xl83Y8NmizMn421lCzQxY1q3cMzzNUX92B8WTuWYf1+3jQOSNVFPc3MyqZrMhHE8AeqFEsKGDFMnOMCcUl89ic5KXlfoAEgk7DfEEZBzA/fTcBwJP4YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":20680,"cache_read_input_tokens":26097,"cache_creation":{"ephemeral_5m_input_tokens":20680,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMVJahhwMTnpCzPexgL3","type":"assistant","uuid":"1131cac8-2613-4bd7-8a41-3e36022bc647","timestamp":"2026-01-22T00:42:52.475Z"}
{"parentUuid":"1131cac8-2613-4bd7-8a41-3e36022bc647","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01P3Vko2yfCGsiEu99i4RhMH","type":"message","role":"assistant","content":[{"type":"text","text":"I'll create a markdown document outlining minimal BDD scenarios for testing the McDonald's Drive-Thru Agent's behavior."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":20680,"cache_read_input_tokens":26097,"cache_creation":{"ephemeral_5m_input_tokens":20680,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMVJahhwMTnpCzPexgL3","type":"assistant","uuid":"af79a51b-fcb8-453f-a153-46b5293acfd6","timestamp":"2026-01-22T00:42:52.910Z"}
{"parentUuid":"af79a51b-fcb8-453f-a153-46b5293acfd6","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01P3Vko2yfCGsiEu99i4RhMH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BpBs42QPJg35J1g68pxtN5","name":"Write","input":{"file_path":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/bdd-testing-strategy.md","content":"# BDD Testing Strategy for McDonald's Drive-Thru Agent\n\n**Created**: 2026-01-21\n**Purpose**: Define minimal set of behavior-driven scenarios for testing the drive-thru agent's behavior, not its implementation\n\n---\n\n## Overview\n\nThis document outlines a minimal but comprehensive set of BDD scenarios using Gherkin syntax to validate the McDonald's Drive-Thru Agent's behavior from a customer perspective. These scenarios test **what the system does**, not **how it does it**.\n\n### Testing Principles\n\n1. **Behavior-Focused**: Test observable customer interactions, not internal implementation\n2. **Black-Box**: Treat the agent as a black box - input (voice) → output (response + order file)\n3. **User Perspective**: Write scenarios from the customer's point of view\n4. **End-to-End**: Each scenario covers a complete customer journey\n5. **Implementation-Agnostic**: Scenarios should remain valid even if internal architecture changes\n\n---\n\n## Feature File Organization\n\n```\ntests/features/agent/\n├── 01_basic_ordering.feature          # Simple, single-item orders\n├── 02_multi_item_ordering.feature     # Multiple items in one order\n├── 03_modifiers.feature               # Items with customizations\n├── 04_order_corrections.feature       # Fixing mistakes\n├── 05_error_handling.feature          # Invalid items and edge cases\n└── 06_order_completion.feature        # Finishing and confirming orders\n```\n\n---\n\n## 1. Basic Ordering (`01_basic_ordering.feature`)\n\n**Purpose**: Verify the agent can handle simple, straightforward orders\n\n### Scenarios\n\n#### Scenario 1.1: Order a single menu item\n```gherkin\nFeature: Basic Single-Item Ordering\n  As a customer\n  I want to order a single item\n  So that I can get my food quickly\n\n  Scenario: Customer orders a Big Mac\n    Given the agent greets the customer\n    When the customer says \"I'll have a Big Mac\"\n    Then the agent confirms \"one Big Mac\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"that's all\"\n    Then the agent reads back the complete order\n    And the order file contains 1 item\n    And the order file shows \"Big Mac\" in category \"Beef & Pork\"\n```\n\n#### Scenario 1.2: Order with explicit quantity\n```gherkin\n  Scenario: Customer orders multiple quantities of same item\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs please\"\n    Then the agent confirms \"two Big Macs\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"no thanks\"\n    Then the order file contains 1 line item with quantity 2\n```\n\n#### Scenario 1.3: Order from breakfast menu\n```gherkin\n  Scenario: Customer orders a breakfast item\n    Given the agent greets the customer\n    When the customer says \"I'd like an Egg McMuffin\"\n    Then the agent confirms the item\n    And the order file shows the item in category \"Breakfast\"\n```\n\n---\n\n## 2. Multi-Item Ordering (`02_multi_item_ordering.feature`)\n\n**Purpose**: Verify the agent can handle orders with multiple different items\n\n### Scenarios\n\n#### Scenario 2.1: Order multiple items sequentially\n```gherkin\nFeature: Multi-Item Ordering\n  As a customer\n  I want to order several different items\n  So that I can get everything I need\n\n  Scenario: Customer orders items one at a time\n    Given the agent greets the customer\n    When the customer says \"I'll have a Big Mac\"\n    Then the agent confirms \"one Big Mac\"\n    When the customer says \"and a medium fries\"\n    Then the agent confirms \"one medium fries\"\n    When the customer says \"and a Coke\"\n    Then the agent confirms the Coke\n    When the customer says \"that's it\"\n    Then the order file contains 3 items\n    And the order includes \"Big Mac\", \"Medium Fries\", and a beverage\n```\n\n#### Scenario 2.2: Order multiple items in one utterance\n```gherkin\n  Scenario: Customer lists multiple items at once\n    Given the agent greets the customer\n    When the customer says \"I want a Big Mac, large fries, and a Sprite\"\n    Then the agent confirms all three items\n    And the order file contains 3 items\n```\n\n#### Scenario 2.3: Mix of quantities and items\n```gherkin\n  Scenario: Customer orders mix of single and multiple items\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs and one large fries\"\n    Then the agent confirms \"two Big Macs and one large fries\"\n    And the order file contains 2 line items\n    And one line item has quantity 2\n    And one line item has quantity 1\n```\n\n---\n\n## 3. Modifiers and Customizations (`03_modifiers.feature`)\n\n**Purpose**: Verify the agent correctly captures item customizations\n\n### Scenarios\n\n#### Scenario 3.1: Item with modifier\n```gherkin\nFeature: Order Customization\n  As a customer\n  I want to customize my items\n  So that I get exactly what I want\n\n  Scenario: Customer adds cheese to Quarter Pounder\n    Given the agent greets the customer\n    When the customer says \"Quarter Pounder with cheese\"\n    Then the agent confirms the item with the modifier\n    And the order file shows \"Quarter Pounder\" with modifier \"Cheese\"\n```\n\n#### Scenario 3.2: Item with removal modifier\n```gherkin\n  Scenario: Customer requests no pickles\n    Given the agent greets the customer\n    When the customer says \"Big Mac with no pickles\"\n    Then the agent confirms \"Big Mac, no pickles\"\n    And the order file shows the \"no pickles\" modifier\n```\n\n#### Scenario 3.3: Multiple modifiers on one item\n```gkerkin\n  Scenario: Customer requests multiple customizations\n    Given the agent greets the customer\n    When the customer says \"Big Mac with no pickles and extra sauce\"\n    Then the agent confirms both modifiers\n    And the order file shows both \"no pickles\" and \"extra sauce\" modifiers\n```\n\n#### Scenario 3.4: Different modifiers on same item type\n```gherkin\n  Scenario: Customer orders two Big Macs with different customizations\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs, one with no pickles\"\n    Then the agent confirms one regular Big Mac and one without pickles\n    And the order file contains 2 separate line items for Big Mac\n    And one line item has \"no pickles\" modifier\n    And one line item has no modifiers\n```\n\n---\n\n## 4. Order Corrections (`04_order_corrections.feature`)\n\n**Purpose**: Verify the agent can handle customer corrections and changes\n\n### Scenarios\n\n#### Scenario 4.1: Correct item before confirming\n```gherkin\nFeature: Order Corrections\n  As a customer\n  I want to correct mistakes in my order\n  So that I get what I actually want\n\n  Scenario: Customer corrects item immediately\n    Given the agent greets the customer\n    When the customer says \"I want a Big Mac\"\n    And the customer says \"actually, make that a McDouble\"\n    Then the agent acknowledges the correction\n    And the order file contains \"McDouble\"\n    And the order file does not contain \"Big Mac\"\n```\n\n#### Scenario 4.2: Change quantity\n```gherkin\n  Scenario: Customer changes quantity of an item\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs\"\n    And the customer says \"actually make that three Big Macs\"\n    Then the agent confirms \"three Big Macs\"\n    And the order file shows quantity 3 for Big Mac\n```\n\n#### Scenario 4.3: Remove item from order\n```gherkin\n  Scenario: Customer removes an item\n    Given the agent has confirmed \"Big Mac\" and \"fries\"\n    When the customer says \"actually, skip the fries\"\n    Then the agent acknowledges the removal\n    And the order file contains only \"Big Mac\"\n    And the order file does not contain \"fries\"\n```\n\n---\n\n## 5. Error Handling (`05_error_handling.feature`)\n\n**Purpose**: Verify the agent handles invalid requests gracefully\n\n### Scenarios\n\n#### Scenario 5.1: Invalid menu item\n```gherkin\nFeature: Error Handling\n  As a customer\n  I want to be informed when I request something unavailable\n  So that I can make a valid choice\n\n  Scenario: Customer requests item not on menu\n    Given the agent greets the customer\n    When the customer says \"I want a Whopper\"\n    Then the agent politely informs the customer the item is not available\n    And the agent suggests looking at the menu\n    And the order file remains empty\n```\n\n#### Scenario 5.2: Ambiguous request\n```gherkin\n  Scenario: Customer makes unclear request\n    Given the agent greets the customer\n    When the customer says \"I want a burger\"\n    Then the agent asks for clarification\n    And the agent may suggest specific burger options\n    And the order file remains empty until clarified\n```\n\n#### Scenario 5.3: Invalid modifier\n```gherkin\n  Scenario: Customer requests unavailable customization\n    Given the agent greets the customer\n    When the customer says \"Big Mac with anchovies\"\n    Then the agent informs the customer that modifier is not available\n    And the agent may suggest valid modifiers\n    And no item is added to the order\n```\n\n#### Scenario 5.4: STT error recovery\n```gherkin\n  Scenario: Customer's words are misheard but corrected\n    Given the agent greets the customer\n    When the customer says something that sounds like \"Big Mack\"\n    Then the agent confirms \"Big Mac\" using fuzzy matching\n    And the order file contains \"Big Mac\" (correct spelling)\n```\n\n---\n\n## 6. Order Completion (`06_order_completion.feature`)\n\n**Purpose**: Verify the agent properly finalizes orders\n\n### Scenarios\n\n#### Scenario 6.1: Complete a simple order\n```gherkin\nFeature: Order Completion\n  As a customer\n  I want my order to be finalized correctly\n  So that I receive what I ordered\n\n  Scenario: Customer completes order\n    Given the agent has confirmed \"Big Mac\" and \"fries\"\n    When the customer says \"that's all\"\n    Then the agent reads back the complete order\n    And the agent thanks the customer\n    And a final order JSON file is created\n    And the JSON file contains all items\n    And the JSON file has correct quantities\n```\n\n#### Scenario 6.2: Cancel entire order\n```gherkin\n  Scenario: Customer cancels order\n    Given the agent has confirmed \"Big Mac\" and \"fries\"\n    When the customer says \"actually, cancel that\"\n    Then the agent acknowledges the cancellation\n    And the order file is empty or marked as cancelled\n```\n\n#### Scenario 6.3: Final confirmation and correction\n```gherkin\n  Scenario: Customer corrects during final readback\n    Given the agent has confirmed \"Big Mac\", \"fries\", and \"Coke\"\n    When the agent reads back the order\n    And the customer says \"no, I wanted a Sprite not a Coke\"\n    Then the agent corrects the order\n    And the final order file shows \"Sprite\"\n    And the final order file does not contain \"Coke\"\n```\n\n---\n\n## Minimal Test Coverage Matrix\n\n### Priority 1: Core Behaviors (Must Have)\n| Feature | Scenarios | Coverage |\n|---------|-----------|----------|\n| Basic Ordering | 1.1, 1.2 | Single item, quantities |\n| Multi-Item | 2.1 | Sequential ordering |\n| Modifiers | 3.1 | Basic customization |\n| Error Handling | 5.1, 5.2 | Invalid items, ambiguity |\n| Completion | 6.1 | Finalize order |\n\n**Total**: ~8 scenarios for smoke testing\n\n### Priority 2: Extended Coverage (Should Have)\n| Feature | Additional Scenarios | Coverage |\n|---------|---------------------|----------|\n| Basic Ordering | 1.3 | Category coverage (breakfast) |\n| Multi-Item | 2.2, 2.3 | Bulk ordering, mixed quantities |\n| Modifiers | 3.2, 3.3, 3.4 | Removals, multiple mods, variations |\n| Corrections | 4.1, 4.2, 4.3 | All correction types |\n| Error Handling | 5.3, 5.4 | Invalid mods, STT recovery |\n| Completion | 6.2, 6.3 | Cancellation, final corrections |\n\n**Total**: ~18 scenarios for comprehensive testing\n\n### Priority 3: Edge Cases (Nice to Have)\n- Ordering from multiple categories\n- Very large orders (10+ items)\n- Rapid corrections (multiple changes)\n- Silence handling (customer doesn't respond)\n- Interruptions (customer talks over agent)\n\n---\n\n## Test Data Requirements\n\n### Menu Items to Cover\n- **Breakfast**: Egg McMuffin, Hash Browns\n- **Beef & Pork**: Big Mac, Quarter Pounder, McDouble\n- **Chicken & Fish**: Chicken McNuggets, Filet-O-Fish\n- **Snacks & Sides**: Fries (Small, Medium, Large), Apple Slices\n- **Beverages**: Coke, Sprite, Water\n- **Coffee & Tea**: Coffee (various sizes)\n- **Desserts**: Apple Pie, McFlurry\n- **Smoothies & Shakes**: Chocolate Shake\n\n### Modifiers to Test\n- Additions: \"with cheese\", \"extra sauce\", \"add bacon\"\n- Removals: \"no pickles\", \"no onions\", \"no ice\"\n- Substitutions: \"egg whites instead of regular eggs\"\n\n### Invalid Items (for error testing)\n- Whopper (Burger King)\n- Baconator (Wendy's)\n- \"Pizza\" (not on menu)\n\n---\n\n## Implementation Guidelines\n\n### Given/When/Then Structure\n\n**Given**: Set up the initial state\n- Agent state (greeted, mid-order, etc.)\n- Existing order contents\n- Session context\n\n**When**: The action/input\n- Customer utterance (what they say)\n- Should be realistic voice input\n\n**Then**: Expected outcomes\n- Agent response (tone, content)\n- Order state (what's in the order file)\n- File system state (what files exist)\n\n### Assertion Types\n\n#### Agent Response Assertions (Behavioral)\n```gherkin\nThen the agent confirms \"one Big Mac\"\nThen the agent asks if the customer wants anything else\nThen the agent politely informs the customer\nThen the agent reads back the complete order\n```\n\n#### Order State Assertions (Observable)\n```gherkin\nThen the order file contains 3 items\nThen the order file shows \"Big Mac\" in category \"Beef & Pork\"\nThen one line item has quantity 2\nThen the order file does not contain \"fries\"\n```\n\n#### Avoid Implementation Assertions (Internal)\n```gherkin\n# ❌ Don't do this (implementation detail)\nThen the OrderStateManager.add_item was called\nThen the fuzzy_match_item function returned 0.95\nThen the DriveThruLLM injected menu context\n\n# ✓ Do this instead (observable behavior)\nThen the order file contains \"Big Mac\"\nThen the agent confirms the item\nThen the order is recorded correctly\n```\n\n---\n\n## BDD Test Execution\n\n### Step Definition Categories\n\n1. **Setup Steps** (Given)\n   - `Given the agent greets the customer`\n   - `Given the agent has confirmed \"Big Mac\" and \"fries\"`\n   - `Given the customer is mid-order`\n\n2. **Action Steps** (When)\n   - `When the customer says \"{utterance}\"`\n   - `When the customer says \"that's all\"`\n   - `When the agent reads back the order`\n\n3. **Verification Steps** (Then)\n   - `Then the agent confirms \"{item}\"`\n   - `Then the order file contains {n} items`\n   - `Then the order file shows \"{item}\" in category \"{category}\"`\n   - `Then the JSON file has correct quantities`\n\n### Judge-Based Assertions\n\nFor natural language responses, use LLM judge:\n\n```python\n@then('the agent confirms \"one Big Mac\"')\ndef verify_agent_confirmation(context):\n    # Use judge to verify intent, not exact wording\n    await result.expect.next_event().is_message(role=\"assistant\").judge(\n        judge_llm,\n        intent=\"Confirms that one Big Mac was added and asks if customer wants more\"\n    )\n```\n\n### File System Assertions\n\nFor order files, use direct JSON comparison:\n\n```python\n@then('the order file contains {n:d} items')\ndef verify_order_count(context, n):\n    order = load_order_json(context.session_id)\n    assert len(order['items']) == n\n```\n\n---\n\n## Continuous Testing Strategy\n\n### Test Pyramid for BDD Scenarios\n\n```\n        /\\\n       /  \\      E2E BDD Scenarios (~18 scenarios)\n      /____\\     Full voice pipeline, judge-based\n     /      \\\n    /        \\   Integration Tests (~30 tests)\n   /__________\\  Component interactions, mocked LLM\n  /            \\\n /              \\ Unit Tests (~100+ tests)\n/________________\\ Pure functions, data models\n```\n\n### When to Run\n\n- **On every commit**: Priority 1 scenarios (smoke tests)\n- **On PR**: Priority 1 + Priority 2 scenarios\n- **Nightly**: Full suite including edge cases\n- **Before release**: Full suite + manual exploratory testing\n\n### Success Criteria\n\n- **All Priority 1 scenarios pass**: Required for merge\n- **95%+ Priority 2 pass rate**: Required for release\n- **Zero regressions**: New features don't break existing scenarios\n\n---\n\n## Example: Complete Feature File\n\nHere's what a complete feature file would look like:\n\n```gherkin\n# tests/features/agent/01_basic_ordering.feature\n\n@voice-agent @order-taking @priority-1\nFeature: Basic Single-Item Ordering\n  As a McDonald's customer\n  I want to order a single menu item\n  So that I can quickly get my food\n\n  Background:\n    Given the McDonald's menu is loaded\n    And the agent is ready to take orders\n\n  @smoke\n  Scenario: Order a Big Mac\n    Given the agent greets the customer\n    When the customer says \"I'll have a Big Mac\"\n    Then the agent confirms \"one Big Mac\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"that's all\"\n    Then the agent reads back the complete order\n    And a final order JSON file is created\n    And the order file contains 1 item\n    And the order file shows \"Big Mac\" in category \"Beef & Pork\"\n    And the item has quantity 1\n    And the item has no modifiers\n\n  @quantities\n  Scenario: Order multiple Big Macs\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs please\"\n    Then the agent confirms \"two Big Macs\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"no thanks\"\n    Then the order file contains 1 line item\n    And the line item has quantity 2\n\n  @breakfast\n  Scenario: Order breakfast item\n    Given the agent greets the customer\n    When the customer says \"I'd like an Egg McMuffin\"\n    Then the agent confirms \"one Egg McMuffin\"\n    When the customer says \"that's it\"\n    Then the order file shows \"Egg McMuffin\" in category \"Breakfast\"\n```\n\n---\n\n## Key Takeaways\n\n1. **Test Behavior, Not Implementation**: Focus on what customers experience\n2. **Minimal but Comprehensive**: 18 scenarios cover all critical paths\n3. **Priority-Based**: Start with 8 smoke tests, expand to 18 for full coverage\n4. **Implementation-Agnostic**: Tests survive architecture refactoring\n5. **Realistic**: Use natural customer language, not technical terms\n6. **Observable**: Assert on files, responses, and end-user visible state\n7. **Maintainable**: Clear structure, reusable steps, good organization\n\n---\n\n## Next Steps\n\n1. **Review this strategy** with the team\n2. **Write actual feature files** following the examples above\n3. **Implement step definitions** for Given/When/Then steps\n4. **Set up test data** (menu JSON, invalid items)\n5. **Configure test runner** (pytest-bdd or behave)\n6. **Run Priority 1** scenarios to validate approach\n7. **Iterate** based on real test results\n8. **Expand** to Priority 2 and Priority 3 as needed\n\nThis BDD testing strategy ensures the McDonald's Drive-Thru Agent behaves correctly from a customer perspective, regardless of internal implementation details.\n"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":20680,"cache_read_input_tokens":26097,"cache_creation":{"ephemeral_5m_input_tokens":20680,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard"}},"requestId":"req_011CXMVJahhwMTnpCzPexgL3","type":"assistant","uuid":"3fa617bd-9598-4673-92ef-7c7e9a1f8d6f","timestamp":"2026-01-22T00:43:49.740Z"}
{"type":"file-history-snapshot","messageId":"3fa617bd-9598-4673-92ef-7c7e9a1f8d6f","snapshot":{"messageId":"6608d435-8dca-423b-b359-dca984633196","trackedFileBackups":{"plan/bdd-testing-strategy.md":{"backupFileName":"f82892693552707e@v1","version":1,"backupTime":"2026-01-22T00:43:49.786Z"}},"timestamp":"2026-01-22T00:42:40.694Z"},"isSnapshotUpdate":true}
{"parentUuid":"3fa617bd-9598-4673-92ef-7c7e9a1f8d6f","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BpBs42QPJg35J1g68pxtN5","type":"tool_result","content":"File created successfully at: /Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/bdd-testing-strategy.md"}]},"uuid":"e23e9899-93c4-485e-83a5-6fd2d71440c3","timestamp":"2026-01-22T00:43:49.786Z","toolUseResult":{"type":"create","filePath":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1/plan/bdd-testing-strategy.md","content":"# BDD Testing Strategy for McDonald's Drive-Thru Agent\n\n**Created**: 2026-01-21\n**Purpose**: Define minimal set of behavior-driven scenarios for testing the drive-thru agent's behavior, not its implementation\n\n---\n\n## Overview\n\nThis document outlines a minimal but comprehensive set of BDD scenarios using Gherkin syntax to validate the McDonald's Drive-Thru Agent's behavior from a customer perspective. These scenarios test **what the system does**, not **how it does it**.\n\n### Testing Principles\n\n1. **Behavior-Focused**: Test observable customer interactions, not internal implementation\n2. **Black-Box**: Treat the agent as a black box - input (voice) → output (response + order file)\n3. **User Perspective**: Write scenarios from the customer's point of view\n4. **End-to-End**: Each scenario covers a complete customer journey\n5. **Implementation-Agnostic**: Scenarios should remain valid even if internal architecture changes\n\n---\n\n## Feature File Organization\n\n```\ntests/features/agent/\n├── 01_basic_ordering.feature          # Simple, single-item orders\n├── 02_multi_item_ordering.feature     # Multiple items in one order\n├── 03_modifiers.feature               # Items with customizations\n├── 04_order_corrections.feature       # Fixing mistakes\n├── 05_error_handling.feature          # Invalid items and edge cases\n└── 06_order_completion.feature        # Finishing and confirming orders\n```\n\n---\n\n## 1. Basic Ordering (`01_basic_ordering.feature`)\n\n**Purpose**: Verify the agent can handle simple, straightforward orders\n\n### Scenarios\n\n#### Scenario 1.1: Order a single menu item\n```gherkin\nFeature: Basic Single-Item Ordering\n  As a customer\n  I want to order a single item\n  So that I can get my food quickly\n\n  Scenario: Customer orders a Big Mac\n    Given the agent greets the customer\n    When the customer says \"I'll have a Big Mac\"\n    Then the agent confirms \"one Big Mac\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"that's all\"\n    Then the agent reads back the complete order\n    And the order file contains 1 item\n    And the order file shows \"Big Mac\" in category \"Beef & Pork\"\n```\n\n#### Scenario 1.2: Order with explicit quantity\n```gherkin\n  Scenario: Customer orders multiple quantities of same item\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs please\"\n    Then the agent confirms \"two Big Macs\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"no thanks\"\n    Then the order file contains 1 line item with quantity 2\n```\n\n#### Scenario 1.3: Order from breakfast menu\n```gherkin\n  Scenario: Customer orders a breakfast item\n    Given the agent greets the customer\n    When the customer says \"I'd like an Egg McMuffin\"\n    Then the agent confirms the item\n    And the order file shows the item in category \"Breakfast\"\n```\n\n---\n\n## 2. Multi-Item Ordering (`02_multi_item_ordering.feature`)\n\n**Purpose**: Verify the agent can handle orders with multiple different items\n\n### Scenarios\n\n#### Scenario 2.1: Order multiple items sequentially\n```gherkin\nFeature: Multi-Item Ordering\n  As a customer\n  I want to order several different items\n  So that I can get everything I need\n\n  Scenario: Customer orders items one at a time\n    Given the agent greets the customer\n    When the customer says \"I'll have a Big Mac\"\n    Then the agent confirms \"one Big Mac\"\n    When the customer says \"and a medium fries\"\n    Then the agent confirms \"one medium fries\"\n    When the customer says \"and a Coke\"\n    Then the agent confirms the Coke\n    When the customer says \"that's it\"\n    Then the order file contains 3 items\n    And the order includes \"Big Mac\", \"Medium Fries\", and a beverage\n```\n\n#### Scenario 2.2: Order multiple items in one utterance\n```gherkin\n  Scenario: Customer lists multiple items at once\n    Given the agent greets the customer\n    When the customer says \"I want a Big Mac, large fries, and a Sprite\"\n    Then the agent confirms all three items\n    And the order file contains 3 items\n```\n\n#### Scenario 2.3: Mix of quantities and items\n```gherkin\n  Scenario: Customer orders mix of single and multiple items\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs and one large fries\"\n    Then the agent confirms \"two Big Macs and one large fries\"\n    And the order file contains 2 line items\n    And one line item has quantity 2\n    And one line item has quantity 1\n```\n\n---\n\n## 3. Modifiers and Customizations (`03_modifiers.feature`)\n\n**Purpose**: Verify the agent correctly captures item customizations\n\n### Scenarios\n\n#### Scenario 3.1: Item with modifier\n```gherkin\nFeature: Order Customization\n  As a customer\n  I want to customize my items\n  So that I get exactly what I want\n\n  Scenario: Customer adds cheese to Quarter Pounder\n    Given the agent greets the customer\n    When the customer says \"Quarter Pounder with cheese\"\n    Then the agent confirms the item with the modifier\n    And the order file shows \"Quarter Pounder\" with modifier \"Cheese\"\n```\n\n#### Scenario 3.2: Item with removal modifier\n```gherkin\n  Scenario: Customer requests no pickles\n    Given the agent greets the customer\n    When the customer says \"Big Mac with no pickles\"\n    Then the agent confirms \"Big Mac, no pickles\"\n    And the order file shows the \"no pickles\" modifier\n```\n\n#### Scenario 3.3: Multiple modifiers on one item\n```gkerkin\n  Scenario: Customer requests multiple customizations\n    Given the agent greets the customer\n    When the customer says \"Big Mac with no pickles and extra sauce\"\n    Then the agent confirms both modifiers\n    And the order file shows both \"no pickles\" and \"extra sauce\" modifiers\n```\n\n#### Scenario 3.4: Different modifiers on same item type\n```gherkin\n  Scenario: Customer orders two Big Macs with different customizations\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs, one with no pickles\"\n    Then the agent confirms one regular Big Mac and one without pickles\n    And the order file contains 2 separate line items for Big Mac\n    And one line item has \"no pickles\" modifier\n    And one line item has no modifiers\n```\n\n---\n\n## 4. Order Corrections (`04_order_corrections.feature`)\n\n**Purpose**: Verify the agent can handle customer corrections and changes\n\n### Scenarios\n\n#### Scenario 4.1: Correct item before confirming\n```gherkin\nFeature: Order Corrections\n  As a customer\n  I want to correct mistakes in my order\n  So that I get what I actually want\n\n  Scenario: Customer corrects item immediately\n    Given the agent greets the customer\n    When the customer says \"I want a Big Mac\"\n    And the customer says \"actually, make that a McDouble\"\n    Then the agent acknowledges the correction\n    And the order file contains \"McDouble\"\n    And the order file does not contain \"Big Mac\"\n```\n\n#### Scenario 4.2: Change quantity\n```gherkin\n  Scenario: Customer changes quantity of an item\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs\"\n    And the customer says \"actually make that three Big Macs\"\n    Then the agent confirms \"three Big Macs\"\n    And the order file shows quantity 3 for Big Mac\n```\n\n#### Scenario 4.3: Remove item from order\n```gherkin\n  Scenario: Customer removes an item\n    Given the agent has confirmed \"Big Mac\" and \"fries\"\n    When the customer says \"actually, skip the fries\"\n    Then the agent acknowledges the removal\n    And the order file contains only \"Big Mac\"\n    And the order file does not contain \"fries\"\n```\n\n---\n\n## 5. Error Handling (`05_error_handling.feature`)\n\n**Purpose**: Verify the agent handles invalid requests gracefully\n\n### Scenarios\n\n#### Scenario 5.1: Invalid menu item\n```gherkin\nFeature: Error Handling\n  As a customer\n  I want to be informed when I request something unavailable\n  So that I can make a valid choice\n\n  Scenario: Customer requests item not on menu\n    Given the agent greets the customer\n    When the customer says \"I want a Whopper\"\n    Then the agent politely informs the customer the item is not available\n    And the agent suggests looking at the menu\n    And the order file remains empty\n```\n\n#### Scenario 5.2: Ambiguous request\n```gherkin\n  Scenario: Customer makes unclear request\n    Given the agent greets the customer\n    When the customer says \"I want a burger\"\n    Then the agent asks for clarification\n    And the agent may suggest specific burger options\n    And the order file remains empty until clarified\n```\n\n#### Scenario 5.3: Invalid modifier\n```gherkin\n  Scenario: Customer requests unavailable customization\n    Given the agent greets the customer\n    When the customer says \"Big Mac with anchovies\"\n    Then the agent informs the customer that modifier is not available\n    And the agent may suggest valid modifiers\n    And no item is added to the order\n```\n\n#### Scenario 5.4: STT error recovery\n```gherkin\n  Scenario: Customer's words are misheard but corrected\n    Given the agent greets the customer\n    When the customer says something that sounds like \"Big Mack\"\n    Then the agent confirms \"Big Mac\" using fuzzy matching\n    And the order file contains \"Big Mac\" (correct spelling)\n```\n\n---\n\n## 6. Order Completion (`06_order_completion.feature`)\n\n**Purpose**: Verify the agent properly finalizes orders\n\n### Scenarios\n\n#### Scenario 6.1: Complete a simple order\n```gherkin\nFeature: Order Completion\n  As a customer\n  I want my order to be finalized correctly\n  So that I receive what I ordered\n\n  Scenario: Customer completes order\n    Given the agent has confirmed \"Big Mac\" and \"fries\"\n    When the customer says \"that's all\"\n    Then the agent reads back the complete order\n    And the agent thanks the customer\n    And a final order JSON file is created\n    And the JSON file contains all items\n    And the JSON file has correct quantities\n```\n\n#### Scenario 6.2: Cancel entire order\n```gherkin\n  Scenario: Customer cancels order\n    Given the agent has confirmed \"Big Mac\" and \"fries\"\n    When the customer says \"actually, cancel that\"\n    Then the agent acknowledges the cancellation\n    And the order file is empty or marked as cancelled\n```\n\n#### Scenario 6.3: Final confirmation and correction\n```gherkin\n  Scenario: Customer corrects during final readback\n    Given the agent has confirmed \"Big Mac\", \"fries\", and \"Coke\"\n    When the agent reads back the order\n    And the customer says \"no, I wanted a Sprite not a Coke\"\n    Then the agent corrects the order\n    And the final order file shows \"Sprite\"\n    And the final order file does not contain \"Coke\"\n```\n\n---\n\n## Minimal Test Coverage Matrix\n\n### Priority 1: Core Behaviors (Must Have)\n| Feature | Scenarios | Coverage |\n|---------|-----------|----------|\n| Basic Ordering | 1.1, 1.2 | Single item, quantities |\n| Multi-Item | 2.1 | Sequential ordering |\n| Modifiers | 3.1 | Basic customization |\n| Error Handling | 5.1, 5.2 | Invalid items, ambiguity |\n| Completion | 6.1 | Finalize order |\n\n**Total**: ~8 scenarios for smoke testing\n\n### Priority 2: Extended Coverage (Should Have)\n| Feature | Additional Scenarios | Coverage |\n|---------|---------------------|----------|\n| Basic Ordering | 1.3 | Category coverage (breakfast) |\n| Multi-Item | 2.2, 2.3 | Bulk ordering, mixed quantities |\n| Modifiers | 3.2, 3.3, 3.4 | Removals, multiple mods, variations |\n| Corrections | 4.1, 4.2, 4.3 | All correction types |\n| Error Handling | 5.3, 5.4 | Invalid mods, STT recovery |\n| Completion | 6.2, 6.3 | Cancellation, final corrections |\n\n**Total**: ~18 scenarios for comprehensive testing\n\n### Priority 3: Edge Cases (Nice to Have)\n- Ordering from multiple categories\n- Very large orders (10+ items)\n- Rapid corrections (multiple changes)\n- Silence handling (customer doesn't respond)\n- Interruptions (customer talks over agent)\n\n---\n\n## Test Data Requirements\n\n### Menu Items to Cover\n- **Breakfast**: Egg McMuffin, Hash Browns\n- **Beef & Pork**: Big Mac, Quarter Pounder, McDouble\n- **Chicken & Fish**: Chicken McNuggets, Filet-O-Fish\n- **Snacks & Sides**: Fries (Small, Medium, Large), Apple Slices\n- **Beverages**: Coke, Sprite, Water\n- **Coffee & Tea**: Coffee (various sizes)\n- **Desserts**: Apple Pie, McFlurry\n- **Smoothies & Shakes**: Chocolate Shake\n\n### Modifiers to Test\n- Additions: \"with cheese\", \"extra sauce\", \"add bacon\"\n- Removals: \"no pickles\", \"no onions\", \"no ice\"\n- Substitutions: \"egg whites instead of regular eggs\"\n\n### Invalid Items (for error testing)\n- Whopper (Burger King)\n- Baconator (Wendy's)\n- \"Pizza\" (not on menu)\n\n---\n\n## Implementation Guidelines\n\n### Given/When/Then Structure\n\n**Given**: Set up the initial state\n- Agent state (greeted, mid-order, etc.)\n- Existing order contents\n- Session context\n\n**When**: The action/input\n- Customer utterance (what they say)\n- Should be realistic voice input\n\n**Then**: Expected outcomes\n- Agent response (tone, content)\n- Order state (what's in the order file)\n- File system state (what files exist)\n\n### Assertion Types\n\n#### Agent Response Assertions (Behavioral)\n```gherkin\nThen the agent confirms \"one Big Mac\"\nThen the agent asks if the customer wants anything else\nThen the agent politely informs the customer\nThen the agent reads back the complete order\n```\n\n#### Order State Assertions (Observable)\n```gherkin\nThen the order file contains 3 items\nThen the order file shows \"Big Mac\" in category \"Beef & Pork\"\nThen one line item has quantity 2\nThen the order file does not contain \"fries\"\n```\n\n#### Avoid Implementation Assertions (Internal)\n```gherkin\n# ❌ Don't do this (implementation detail)\nThen the OrderStateManager.add_item was called\nThen the fuzzy_match_item function returned 0.95\nThen the DriveThruLLM injected menu context\n\n# ✓ Do this instead (observable behavior)\nThen the order file contains \"Big Mac\"\nThen the agent confirms the item\nThen the order is recorded correctly\n```\n\n---\n\n## BDD Test Execution\n\n### Step Definition Categories\n\n1. **Setup Steps** (Given)\n   - `Given the agent greets the customer`\n   - `Given the agent has confirmed \"Big Mac\" and \"fries\"`\n   - `Given the customer is mid-order`\n\n2. **Action Steps** (When)\n   - `When the customer says \"{utterance}\"`\n   - `When the customer says \"that's all\"`\n   - `When the agent reads back the order`\n\n3. **Verification Steps** (Then)\n   - `Then the agent confirms \"{item}\"`\n   - `Then the order file contains {n} items`\n   - `Then the order file shows \"{item}\" in category \"{category}\"`\n   - `Then the JSON file has correct quantities`\n\n### Judge-Based Assertions\n\nFor natural language responses, use LLM judge:\n\n```python\n@then('the agent confirms \"one Big Mac\"')\ndef verify_agent_confirmation(context):\n    # Use judge to verify intent, not exact wording\n    await result.expect.next_event().is_message(role=\"assistant\").judge(\n        judge_llm,\n        intent=\"Confirms that one Big Mac was added and asks if customer wants more\"\n    )\n```\n\n### File System Assertions\n\nFor order files, use direct JSON comparison:\n\n```python\n@then('the order file contains {n:d} items')\ndef verify_order_count(context, n):\n    order = load_order_json(context.session_id)\n    assert len(order['items']) == n\n```\n\n---\n\n## Continuous Testing Strategy\n\n### Test Pyramid for BDD Scenarios\n\n```\n        /\\\n       /  \\      E2E BDD Scenarios (~18 scenarios)\n      /____\\     Full voice pipeline, judge-based\n     /      \\\n    /        \\   Integration Tests (~30 tests)\n   /__________\\  Component interactions, mocked LLM\n  /            \\\n /              \\ Unit Tests (~100+ tests)\n/________________\\ Pure functions, data models\n```\n\n### When to Run\n\n- **On every commit**: Priority 1 scenarios (smoke tests)\n- **On PR**: Priority 1 + Priority 2 scenarios\n- **Nightly**: Full suite including edge cases\n- **Before release**: Full suite + manual exploratory testing\n\n### Success Criteria\n\n- **All Priority 1 scenarios pass**: Required for merge\n- **95%+ Priority 2 pass rate**: Required for release\n- **Zero regressions**: New features don't break existing scenarios\n\n---\n\n## Example: Complete Feature File\n\nHere's what a complete feature file would look like:\n\n```gherkin\n# tests/features/agent/01_basic_ordering.feature\n\n@voice-agent @order-taking @priority-1\nFeature: Basic Single-Item Ordering\n  As a McDonald's customer\n  I want to order a single menu item\n  So that I can quickly get my food\n\n  Background:\n    Given the McDonald's menu is loaded\n    And the agent is ready to take orders\n\n  @smoke\n  Scenario: Order a Big Mac\n    Given the agent greets the customer\n    When the customer says \"I'll have a Big Mac\"\n    Then the agent confirms \"one Big Mac\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"that's all\"\n    Then the agent reads back the complete order\n    And a final order JSON file is created\n    And the order file contains 1 item\n    And the order file shows \"Big Mac\" in category \"Beef & Pork\"\n    And the item has quantity 1\n    And the item has no modifiers\n\n  @quantities\n  Scenario: Order multiple Big Macs\n    Given the agent greets the customer\n    When the customer says \"Two Big Macs please\"\n    Then the agent confirms \"two Big Macs\"\n    And the agent asks if the customer wants anything else\n    When the customer says \"no thanks\"\n    Then the order file contains 1 line item\n    And the line item has quantity 2\n\n  @breakfast\n  Scenario: Order breakfast item\n    Given the agent greets the customer\n    When the customer says \"I'd like an Egg McMuffin\"\n    Then the agent confirms \"one Egg McMuffin\"\n    When the customer says \"that's it\"\n    Then the order file shows \"Egg McMuffin\" in category \"Breakfast\"\n```\n\n---\n\n## Key Takeaways\n\n1. **Test Behavior, Not Implementation**: Focus on what customers experience\n2. **Minimal but Comprehensive**: 18 scenarios cover all critical paths\n3. **Priority-Based**: Start with 8 smoke tests, expand to 18 for full coverage\n4. **Implementation-Agnostic**: Tests survive architecture refactoring\n5. **Realistic**: Use natural customer language, not technical terms\n6. **Observable**: Assert on files, responses, and end-user visible state\n7. **Maintainable**: Clear structure, reusable steps, good organization\n\n---\n\n## Next Steps\n\n1. **Review this strategy** with the team\n2. **Write actual feature files** following the examples above\n3. **Implement step definitions** for Given/When/Then steps\n4. **Set up test data** (menu JSON, invalid items)\n5. **Configure test runner** (pytest-bdd or behave)\n6. **Run Priority 1** scenarios to validate approach\n7. **Iterate** based on real test results\n8. **Expand** to Priority 2 and Priority 3 as needed\n\nThis BDD testing strategy ensures the McDonald's Drive-Thru Agent behaves correctly from a customer perspective, regardless of internal implementation details.\n","structuredPatch":[],"originalFile":null},"sourceToolAssistantUUID":"3fa617bd-9598-4673-92ef-7c7e9a1f8d6f"}
{"parentUuid":"e23e9899-93c4-485e-83a5-6fd2d71440c3","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GFMRPurSTbvs6UzS4F1axu","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good! I've created a comprehensive markdown document outlining the BDD testing strategy. Now let me provide a summary to the user explaining what I've created.","signature":"EsgCCkYICxgCKkD6RtKrCQDdRR1mt1uhlBaI+Cc5lcCK6nchwi9tcs4fPWOvtzX+LWWuMl7kAEBAoXA5a8fusithzYlFfHG76mBEEgyTx+aRLZjFaLbdA2waDITmrw33Sh0qxKLHayIwa+cF3vVNB1S7pstz4J9foeanUeuYLsS1aWJ3l4bvwTcw49eR+pBOZ7tEuHJimjwhKq8BdyVwQ4RfCTRbbTIYc47ykSx2fNfeccoI+JPgYwxmxURb1aivqK8E9JQNTVB24WcBRwKQQlYL1Vf0wX8tU+nwz2CH6D26VmWKVs0QYZbTM6vkXQQIQiJ/6bFnt4UtOO/vlIWx0vrY33OVN8Z//EezK9drvqARw+NbJ4fDDpdyEUdk2HgTVQiFZGJBMHcIrzPtaWffxWX7e8JGY8gKCSCWPY+vwKI5oRLtjUx7Qy1RPRgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":5512,"cache_read_input_tokens":46777,"cache_creation":{"ephemeral_5m_input_tokens":5512,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMVPEcMu917ng7QcKBBf","type":"assistant","uuid":"f0f0f38f-37ed-4df3-bf6e-d7a2a115529e","timestamp":"2026-01-22T00:43:51.516Z"}
{"parentUuid":"f0f0f38f-37ed-4df3-bf6e-d7a2a115529e","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GFMRPurSTbvs6UzS4F1axu","type":"message","role":"assistant","content":[{"type":"text","text":"I've created a comprehensive BDD testing strategy document at `plan/bdd-testing-strategy.md`. This markdown outlines a minimal but thorough set of behavior-driven scenarios for testing the McDonald's Drive-Thru Agent.\n\n## What I've included:\n\n### **6 Feature Areas** with 18 total scenarios:\n1. **Basic Ordering** - Simple single-item orders (3 scenarios)\n2. **Multi-Item Ordering** - Multiple different items (3 scenarios)\n3. **Modifiers & Customizations** - Items with modifications (4 scenarios)\n4. **Order Corrections** - Fixing mistakes mid-order (3 scenarios)\n5. **Error Handling** - Invalid items and edge cases (4 scenarios)\n6. **Order Completion** - Finalizing orders (3 scenarios)\n\n### **Key Features:**\n- **Behavior-focused**: Tests what the customer experiences, not how the code works\n- **Priority-based**: 8 smoke tests (Priority 1) for quick validation, 18 total for comprehensive coverage\n- **Implementation-agnostic**: Tests remain valid even if internal architecture changes\n- **Realistic scenarios**: Written in natural customer language using Gherkin syntax\n\n### **Structure includes:**\n- Complete examples of Gherkin scenarios\n- Test coverage matrix showing priorities\n- Guidelines for writing Given/When/Then steps\n- Assertion patterns (what to test vs. what to avoid)\n- Integration with judge-based LLM evaluation\n- Test pyramid strategy\n\nThe document focuses entirely on **observable behavior** (agent responses, order files) rather than implementation details (internal functions, class methods), which aligns perfectly with BDD principles."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":13,"cache_creation_input_tokens":5512,"cache_read_input_tokens":46777,"cache_creation":{"ephemeral_5m_input_tokens":5512,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CXMVPEcMu917ng7QcKBBf","type":"assistant","uuid":"c229830a-92a4-422a-87b9-6afefbe79cd3","timestamp":"2026-01-22T00:43:56.650Z"}
{"parentUuid":"c229830a-92a4-422a-87b9-6afefbe79cd3","isSidechain":false,"userType":"external","cwd":"/Users/seanreed/PythonProjects/voice-ai/lk-agent-1","sessionId":"df0e9444-77ff-41da-81fd-85c4da80d2d6","version":"2.1.14","gitBranch":"voice-ordering-llm","slug":"jolly-prancing-parnas","type":"system","subtype":"turn_duration","durationMs":75998,"timestamp":"2026-01-22T00:43:56.691Z","uuid":"a5df0d88-ff1c-413b-88ab-fdc4e255eae8","isMeta":false}
{"type":"summary","summary":"McDonald's Drive-Thru Agent BDD Testing Strategy","leafUuid":"c229830a-92a4-422a-87b9-6afefbe79cd3"}
