---
name: makefile
description: Standards for creating and maintaining streamlined, variable-based Makefiles. Use when adding new targets, refactoring existing Makefiles, or creating new build automation.
---

# Makefile Organization Standards

This skill establishes standards for project `Makefiles` to ensure they remain maintainable, discoverable, and user-friendly.

## When to Use This Skill

- Creating a new Makefile from scratch
- Adding new targets to an existing Makefile
- Refactoring complex or unwieldy Makefiles
- Reviewing Makefile quality and maintainability
- Ensuring consistent patterns across project automation
- Teaching others about Makefile best practices

## Core Principles

1. **Minimum Targets Philosophy**: Create the **absolute minimum number of targets** needed. Unless explicitly instructed otherwise, resist the urge to add targets. Use variables (`SCOPE`, `ARGS`, `ACTION`) instead of proliferating similar targets.

2. **Importance-First Ordering**: Place the most important and frequently-used targets at the **top** of the Makefile (immediately after `help`). Order targets by user priority:
   - Most common commands first (e.g., `dev`, `test`, `console`)
   - Setup/configuration second (e.g., `setup`, `install`)
   - Code quality tools third (e.g., `format`, `lint`)
   - Utilities and cleanup last (e.g., `clean`, `download-files`)

3. **Variable-Based Scope**: Use a single target with a `SCOPE` variable instead of creating many similar targets (e.g., `make test SCOPE=api` instead of `make test-api`, `make test-frontend`, etc.).

4. **Consolidated Functional Targets**: Group actions under a few high-level functional targets:
   - `dev` or `run`: Primary execution commands
   - `test`: All testing activities (use `SCOPE` for variants)
   - `setup` or `install`: Dependency installation
   - `format` / `lint`: Code quality
   - `clean`: Cleanup operations

5. **Usage Hints & Error Handling**: Always provide helpful usage instructions if required variables are missing or incorrect.

6. **Self-Documenting Help**: Maintain a robust `make help` target that provides both command descriptions and example usage.

## Implementation Patterns

### 1. Variable Defaults and Scope Selection

Always use `?=` for variables to allow overrides from the environment or command line.

```makefile
SCOPE  ?= all
ACTION ?= up
ARGS   ?=

test:
	@case "$(SCOPE)" in \
		all) $(MAKE) test SCOPE=api; $(MAKE) test SCOPE=frontend ;; \
		api) uv run pytest $(ARGS) ;; \
		frontend) cd frontend && npm test -- $(ARGS) ;; \
		*) echo "Usage: make test SCOPE=[all|api|frontend]"; exit 1 ;; \
	esac
```

### 2. User-Friendly Help Output

Use a visually clean help format with examples.

```makefile
BLUE   := \033[0;34m
GREEN  := \033[0;32m
NC     := \033[0m

help:
	@echo "$(BLUE)Available Commands:$(NC)"
	@echo "  $(GREEN)make test SCOPE=api$(NC)  Run backend tests"
	@echo "  $(GREEN)make dev ACTION=up$(NC)   Start services"
```

### 3. Argument Pass-Through

Use an `ARGS` variable to pass flags to the underlying tools.

```makefile
# Usage: make test SCOPE=api ARGS="-k login"
api:
	uv run pytest $(ARGS)
```

### 4. Color Coding for Output

Use ANSI color codes to improve readability:

```makefile
# Color codes
BLUE   := \033[0;34m   # For informational messages
GREEN  := \033[0;32m   # For success messages
YELLOW := \033[0;33m   # For warnings
CYAN   := \033[0;36m   # For section headers
BOLD   := \033[1m      # For emphasis
NC     := \033[0m      # Reset (No Color)
```

### 5. File Organization

Structure your Makefile with clear sections:

```makefile
# =============================================================================
# Project Name - Makefile
# =============================================================================
# Quick Reference and description
# =============================================================================

.PHONY: help setup dev test lint format clean
.DEFAULT_GOAL := help

# -----------------------------------------------------------------------------
# Colors
# -----------------------------------------------------------------------------
[Color definitions]

# -----------------------------------------------------------------------------
# Default Variables
# -----------------------------------------------------------------------------
[Variable definitions]

# =============================================================================
# HELP
# =============================================================================
[Help target]

# =============================================================================
# SETUP - Install dependencies
# =============================================================================
[Setup target]

# ... (other sections)
```

## Prohibited Patterns

- **Target Proliferation**: Do not create discrete targets like `test-api`, `test-frontend`, `test-api-integration`. Use `SCOPE` and `ARGS`.
- **Local Process Backgrounding**: Avoid `nohup` or `&` in Makefiles for long-running services. Prefer Docker or explicit foreground processes.
- **Redundant Aliases**: Avoid creating multiple names for the same action (e.g., `nuke` vs `clean`).
- **Complex Dynamic Logic**: Avoid complex `MAKECMDGOALS` parsing that makes the Makefile hard to read.

## Best Practices

### Error Handling

Always validate required variables and provide clear error messages:

```makefile
run:
	@if [ -z "$(CMD)" ]; then \
		echo "$(YELLOW)Error: CMD is required$(NC)"; \
		echo "Usage: make run CMD=<command> [ARGS=\"...\"]"; \
		exit 1; \
	fi
```

### Consistent Messaging

Use consistent color-coded output:
- `BLUE` for "Starting..." messages
- `GREEN` for "Complete!" messages
- `YELLOW` for warnings and errors
- `CYAN` for section dividers

### Documentation

Each target should:
1. Include a `##` comment for the help system
2. Provide usage hints when called incorrectly
3. Echo informative messages during execution

## Summary Checklist for New Targets

- [ ] Uses `SCOPE` if applicable to multiple services?
- [ ] Provides pass-through via `ARGS`?
- [ ] Includes a clear usage hint for invalid inputs?
- [ ] Added to `make help` with a realistic example?
- [ ] Uses consistent color coding for output?
- [ ] Properly validates required variables?
- [ ] Follows the established naming conventions?

## Example: Well-Structured Makefile

For a complete reference implementation, see [references/Makefile](references/Makefile) which demonstrates:

- Clean sectional organization
- Variable-based scoping
- Comprehensive help documentation
- Color-coded output
- Error handling with helpful messages
- Argument pass-through
- Consistent patterns across all targets

## Related Documentation

- [makefile-organization.mdc](makefile-organization.mdc) - Detailed organization standards
- [references/Makefile](references/Makefile) - Complete working example
