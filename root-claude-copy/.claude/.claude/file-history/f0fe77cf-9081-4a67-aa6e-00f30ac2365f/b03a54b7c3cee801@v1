#!/bin/bash

# calculate-time-segments.sh
# Calculates optimal time segments to keep commits per segment in target range
#
# Usage: ./calculate-time-segments.sh <repo_path> <author_pattern> <target_commits_per_segment>
# Output: Date ranges, one per line (format: start_date|end_date|commit_count)
# Exit codes: 0=success, 1=invalid repo/args, 2=no commits

set -uo pipefail

# Check arguments
if [ $# -ne 3 ]; then
    echo "Usage: $0 <repo_path> <author_pattern> <target_commits_per_segment>" >&2
    exit 1
fi

REPO_PATH="$1"
AUTHOR_PATTERN="$2"
TARGET_COMMITS="$3"

# Validate target is a positive integer
if ! [[ "$TARGET_COMMITS" =~ ^[0-9]+$ ]] || [ "$TARGET_COMMITS" -le 0 ]; then
    echo "Error: target_commits_per_segment must be a positive integer" >&2
    exit 1
fi

# Validate git repository
if ! git -C "$REPO_PATH" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Error: Not a git repository: $REPO_PATH" >&2
    exit 1
fi

# Get total commit count
TOTAL_COMMITS=$(git -C "$REPO_PATH" log \
    --author="$AUTHOR_PATTERN" \
    --all \
    --oneline | wc -l | tr -d ' ')

# Check if any commits were found
if [ "$TOTAL_COMMITS" -eq 0 ]; then
    echo "Error: No commits found for author: $AUTHOR_PATTERN" >&2
    exit 2
fi

# If total commits <= target, return single segment
if [ "$TOTAL_COMMITS" -le "$TARGET_COMMITS" ]; then
    FIRST_DATE=$(git -C "$REPO_PATH" log \
        --author="$AUTHOR_PATTERN" \
        --all \
        --reverse \
        --format='%ad' \
        --date=short | head -1 2>/dev/null)

    LAST_DATE=$(git -C "$REPO_PATH" log \
        --author="$AUTHOR_PATTERN" \
        --all \
        --format='%ad' \
        --date=short | head -1 2>/dev/null)

    echo "$FIRST_DATE|$LAST_DATE|$TOTAL_COMMITS"
    exit 0
fi

# Calculate number of segments needed
NUM_SEGMENTS=$(( (TOTAL_COMMITS + TARGET_COMMITS - 1) / TARGET_COMMITS ))

# Get first and last commit timestamps
FIRST_TIMESTAMP=$(git -C "$REPO_PATH" log \
    --author="$AUTHOR_PATTERN" \
    --all \
    --reverse \
    --format='%at' | head -1 2>/dev/null)

LAST_TIMESTAMP=$(git -C "$REPO_PATH" log \
    --author="$AUTHOR_PATTERN" \
    --all \
    --format='%at' | head -1 2>/dev/null)

# Calculate initial segment duration
TIMELINE_DURATION=$((LAST_TIMESTAMP - FIRST_TIMESTAMP))
SEGMENT_DURATION=$((TIMELINE_DURATION / NUM_SEGMENTS))

# Minimum segment duration (1 day in seconds)
MIN_SEGMENT_DURATION=86400

if [ "$SEGMENT_DURATION" -lt "$MIN_SEGMENT_DURATION" ]; then
    SEGMENT_DURATION=$MIN_SEGMENT_DURATION
fi

# Generate segments with adaptive boundaries
# Strategy: Start with equal time divisions, then adjust if needed
CURRENT_START=$FIRST_TIMESTAMP
SEGMENTS_GENERATED=0

while [ "$CURRENT_START" -lt "$LAST_TIMESTAMP" ] && [ "$SEGMENTS_GENERATED" -lt "$NUM_SEGMENTS" ]; do
    # Calculate initial end time
    CURRENT_END=$((CURRENT_START + SEGMENT_DURATION))

    # For the last segment, extend to include all remaining commits
    if [ "$SEGMENTS_GENERATED" -eq $((NUM_SEGMENTS - 1)) ]; then
        CURRENT_END=$((LAST_TIMESTAMP + 86400))
    fi

    # Ensure we don't go beyond the last commit
    if [ "$CURRENT_END" -gt "$((LAST_TIMESTAMP + 86400))" ]; then
        CURRENT_END=$((LAST_TIMESTAMP + 86400))
    fi

    # Count commits in this segment
    SEGMENT_COUNT=$(git -C "$REPO_PATH" log \
        --author="$AUTHOR_PATTERN" \
        --all \
        --since="@$CURRENT_START" \
        --until="@$CURRENT_END" \
        --oneline | wc -l | tr -d ' ')

    # Adaptive adjustment: if segment has too many commits and we're not on the last segment
    if [ "$SEGMENT_COUNT" -gt $((TARGET_COMMITS + 100)) ] && [ "$SEGMENTS_GENERATED" -lt $((NUM_SEGMENTS - 1)) ]; then
        # Reduce segment duration to bring it closer to target
        ADJUSTMENT_FACTOR=$(echo "scale=2; $TARGET_COMMITS / $SEGMENT_COUNT" | bc)
        NEW_DURATION=$(echo "$SEGMENT_DURATION * $ADJUSTMENT_FACTOR" | bc | cut -d'.' -f1)

        if [ "$NEW_DURATION" -ge "$MIN_SEGMENT_DURATION" ]; then
            CURRENT_END=$((CURRENT_START + NEW_DURATION))
            SEGMENT_COUNT=$(git -C "$REPO_PATH" log \
                --author="$AUTHOR_PATTERN" \
                --all \
                --since="@$CURRENT_START" \
                --until="@$CURRENT_END" \
                --oneline | wc -l | tr -d ' ')
        fi
    fi

    # Convert timestamps to dates
    if command -v date >/dev/null 2>&1; then
        # Try macOS format first, then Linux format
        START_DATE=$(date -r "$CURRENT_START" '+%Y-%m-%d' 2>/dev/null || date -d "@$CURRENT_START" '+%Y-%m-%d' 2>/dev/null)
        END_DATE=$(date -r "$((CURRENT_END - 86400))" '+%Y-%m-%d' 2>/dev/null || date -d "@$((CURRENT_END - 86400))" '+%Y-%m-%d' 2>/dev/null)
    fi

    # Output segment (only if it has commits)
    if [ "$SEGMENT_COUNT" -gt 0 ]; then
        echo "$START_DATE|$END_DATE|$SEGMENT_COUNT"
        SEGMENTS_GENERATED=$((SEGMENTS_GENERATED + 1))
    fi

    # Move to next segment
    CURRENT_START=$CURRENT_END

    # Safety check: prevent infinite loop
    if [ "$CURRENT_START" -ge "$((LAST_TIMESTAMP + 86400))" ]; then
        break
    fi
done

exit 0
